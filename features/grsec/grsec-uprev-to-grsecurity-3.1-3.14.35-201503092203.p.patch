From 5bce9656b966c1d79058619d3ad93e0840594cdf Mon Sep 17 00:00:00 2001
From: Jianchuan Wang <jianchuan.wang@windriver.com>
Date: Wed, 11 Mar 2015 16:32:49 +0800
Subject: [PATCH] grsec: uprev to grsecurity-3.1-3.14.35-201503092203.patch
 from grsecurity-3.0-3.14.28-201501120819.patch

Signed-off-by: Jianchuan Wang <jianchuan.wang@windriver.com>
---
 arch/powerpc/kernel/Makefile                       |   5 +
 arch/x86/kernel/cpu/microcode/intel.c              |   5 +
 arch/x86/kernel/cpu/microcode/intel_early.c        |   6 +-
 arch/x86/kernel/dumpstack_64.c                     |   2 +-
 arch/x86/kernel/entry_32.S                         |   1 +
 arch/x86/kernel/entry_64.S                         |   1 +
 arch/x86/kernel/process_32.c                       |   2 +-
 arch/x86/kernel/process_64.c                       |   2 +-
 arch/x86/kernel/vmlinux.lds.S                      |   2 +-
 arch/x86/kvm/emulate.c                             |  31 ++---
 arch/x86/kvm/vmx.c                                 |   3 +
 arch/x86/mm/ioremap.c                              |  13 +--
 arch/x86/net/bpf_jit_comp.c                        |  28 +++--
 arch/x86/vdso/vma.c                                |   1 -
 arch/x86/xen/enlighten.c                           |   7 +-
 drivers/char/mem.c                                 |  12 +-
 drivers/gpu/drm/ttm/ttm_page_alloc.c               |   5 +-
 drivers/gpu/drm/ttm/ttm_page_alloc_dma.c           |   5 +-
 drivers/isdn/hardware/eicon/message.c              |   2 +-
 drivers/media/radio/wl128x/fmdrv_common.c          |   2 +-
 drivers/net/ethernet/freescale/gianfar_ethtool.c   |   2 +-
 drivers/net/ethernet/neterion/s2io.c               |  11 +-
 drivers/net/phy/phy_device.c                       |   6 +-
 drivers/staging/line6/driver.c                     |  16 ++-
 drivers/staging/line6/toneport.c                   |  13 ++-
 fs/autofs4/dev-ioctl.c                             |   3 +
 fs/cifs/cifs_debug.c                               |   6 +-
 fs/cifs/smbencrypt.c                               |   2 +-
 fs/dcache.c                                        |   3 +
 fs/exec.c                                          |   4 +-
 fs/fhandle.c                                       |   5 +-
 fs/fs_struct.c                                     |   6 +-
 fs/namei.c                                         |  16 ++-
 grsecurity/Kconfig                                 |  16 +++
 grsecurity/gracl.c                                 | 126 ++++++++++++++-------
 grsecurity/gracl_compat.c                          |   3 +-
 grsecurity/gracl_fs.c                              |   4 +-
 grsecurity/gracl_policy.c                          |  19 ++--
 grsecurity/gracl_segv.c                            |  17 ++-
 grsecurity/grsec_chroot.c                          |  82 ++++++++++++++
 grsecurity/grsec_disabled.c                        |   9 +-
 grsecurity/grsec_init.c                            |   4 +
 grsecurity/grsec_sysctl.c                          |   9 ++
 include/linux/compiler-gcc5.h                      |  22 ++++
 include/linux/dcache.h                             |   3 +
 include/linux/gracl.h                              |  18 +--
 include/linux/gracl_compat.h                       |   6 +-
 include/linux/grinternal.h                         |   1 +
 include/linux/grmsg.h                              |   1 +
 include/linux/grsecurity.h                         |  14 ++-
 include/linux/ipv6.h                               |  10 +-
 include/linux/irqdesc.h                            |   2 +-
 include/linux/mmzone.h                             |   2 +-
 include/linux/percpu.h                             |   2 +-
 include/net/inet_timewait_sock.h                   |   3 +-
 include/net/sock.h                                 |   4 +-
 kernel/fork.c                                      |   2 +-
 kernel/irq/manage.c                                |   2 +-
 kernel/irq/spurious.c                              |   2 +-
 kernel/range.c                                     |  10 +-
 mm/memory.c                                        |  34 ------
 mm/mmap.c                                          |   2 -
 net/bridge/br.c                                    |   2 +
 net/core/dev.c                                     |   6 +-
 net/core/rtnetlink.c                               |   4 +
 net/dccp/minisocks.c                               |   4 +-
 net/ipv4/ping.c                                    |   2 +-
 net/ipv4/tcp_minisocks.c                           |   2 +-
 net/ipv6/addrconf.c                                |  16 +++
 net/ipv6/af_inet6.c                                |   6 +-
 net/ipv6/ip6_gre.c                                 |   4 +-
 net/ipv6/ipv6_sockglue.c                           |   4 +-
 net/ipv6/udp.c                                     |   3 +-
 net/ipv6/xfrm6_policy.c                            |   8 +-
 net/llc/sysctl_net_llc.c                           |   8 +-
 net/netfilter/nf_tables_api.c                      |   2 +
 net/rds/sysctl.c                                   |   4 +-
 net/sched/cls_api.c                                |   7 +-
 net/sched/cls_bpf.c                                |  15 ++-
 net/sctp/socket.c                                  |   7 ++
 scripts/Kbuild.include                             |   2 +-
 scripts/gcc-plugin.sh                              |   4 +-
 security/keys/request_key.c                        |   1 +
 tools/gcc/constify_plugin.c                        |   7 +-
 tools/gcc/gcc-common.h                             |  98 ++++++++++++++--
 .../size_overflow_plugin/size_overflow_hash.data   |   7 ++
 86 files changed, 624 insertions(+), 256 deletions(-)

diff --git a/arch/powerpc/kernel/Makefile b/arch/powerpc/kernel/Makefile
index 07be2bb..10f8e7e 100644
--- a/arch/powerpc/kernel/Makefile
+++ b/arch/powerpc/kernel/Makefile
@@ -14,6 +14,11 @@ CFLAGS_prom_init.o      += -fPIC
 CFLAGS_btext.o		+= -fPIC
 endif
 
+CFLAGS_REMOVE_cputable.o = $(LATENT_ENTROPY_PLUGIN_CFLAGS)
+CFLAGS_REMOVE_prom_init.o = $(LATENT_ENTROPY_PLUGIN_CFLAGS)
+CFLAGS_REMOVE_btext.o = $(LATENT_ENTROPY_PLUGIN_CFLAGS)
+CFLAGS_REMOVE_prom.o = $(LATENT_ENTROPY_PLUGIN_CFLAGS)
+
 ifdef CONFIG_FUNCTION_TRACER
 # Do not trace early boot code
 CFLAGS_REMOVE_cputable.o = -pg -mno-sched-epilog
diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c
index e66810f..3ef18f0 100644
--- a/arch/x86/kernel/cpu/microcode/intel.c
+++ b/arch/x86/kernel/cpu/microcode/intel.c
@@ -196,6 +196,11 @@ static enum ucode_state generic_load_microcode(int cpu, void *data, size_t size,
 		struct microcode_header_intel mc_header;
 		unsigned int mc_size;
 
+		if (leftover < sizeof(mc_header)) {
+			pr_err("error! Truncated header in microcode data file\n");
+			break;
+		}
+
 		if (get_ucode_data(&mc_header, ucode_ptr, sizeof(mc_header)))
 			break;
 
diff --git a/arch/x86/kernel/cpu/microcode/intel_early.c b/arch/x86/kernel/cpu/microcode/intel_early.c
index 18f7391..8c5225d 100644
--- a/arch/x86/kernel/cpu/microcode/intel_early.c
+++ b/arch/x86/kernel/cpu/microcode/intel_early.c
@@ -321,7 +321,11 @@ get_matching_model_microcode(int cpu, unsigned long start,
 	unsigned int mc_saved_count = mc_saved_data->mc_saved_count;
 	int i;
 
-	while (leftover) {
+	while (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) {
+
+		if (leftover < sizeof(mc_header))
+			break;
+
 		mc_header = (struct microcode_header_intel *)ucode_ptr;
 
 		mc_size = get_totalsize(mc_header);
diff --git a/arch/x86/kernel/dumpstack_64.c b/arch/x86/kernel/dumpstack_64.c
index 99080e6..81f4ebf 100644
--- a/arch/x86/kernel/dumpstack_64.c
+++ b/arch/x86/kernel/dumpstack_64.c
@@ -298,7 +298,7 @@ int is_valid_bugaddr(unsigned long ip)
 {
 	unsigned short ud2;
 
-	if (__copy_from_user(&ud2, (const void __user *) ip, sizeof(ud2)))
+	if (probe_kernel_address((unsigned short *)ip, ud2))
 		return 0;
 
 	return ud2 == 0x0b0f;
diff --git a/arch/x86/kernel/entry_32.S b/arch/x86/kernel/entry_32.S
index 228d280..b6a5426 100644
--- a/arch/x86/kernel/entry_32.S
+++ b/arch/x86/kernel/entry_32.S
@@ -301,6 +301,7 @@ ENTRY(pax_erase_kstack)
 	jne 1b
 
 2:	cld
+	or $2*4, %edi
 	mov %esp, %ecx
 	sub %edi, %ecx
 
diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S
index e359caf..ff1450f4 100644
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -695,6 +695,7 @@ ENTRY(pax_erase_kstack)
 	jne 1b
 
 2:	cld
+	or $2*8, %rdi
 	mov %esp, %ecx
 	sub %edi, %ecx
 
diff --git a/arch/x86/kernel/process_32.c b/arch/x86/kernel/process_32.c
index 056b840..b0211fe 100644
--- a/arch/x86/kernel/process_32.c
+++ b/arch/x86/kernel/process_32.c
@@ -138,7 +138,7 @@ int copy_thread(unsigned long clone_flags, unsigned long sp,
 
 	p->thread.sp = (unsigned long) childregs;
 	p->thread.sp0 = (unsigned long) (childregs+1);
-	p->tinfo.lowest_stack = (unsigned long)task_stack_page(p);
+	p->tinfo.lowest_stack = (unsigned long)task_stack_page(p) + 2 * sizeof(unsigned long);
 
 	if (unlikely(p->flags & PF_KTHREAD)) {
 		/* kernel thread */
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index 10f7ec2..d49eb67 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -162,7 +162,7 @@ int copy_thread(unsigned long clone_flags, unsigned long sp,
 	childregs = task_pt_regs(p);
 	p->thread.sp = (unsigned long) childregs;
 	p->thread.usersp = me->thread.usersp;
-	p->tinfo.lowest_stack = (unsigned long)task_stack_page(p);
+	p->tinfo.lowest_stack = (unsigned long)task_stack_page(p) + 2 * sizeof(unsigned long);
 	set_tsk_thread_flag(p, TIF_FORK);
 	p->thread.fpu_counter = 0;
 	p->thread.io_bitmap_ptr = NULL;
diff --git a/arch/x86/kernel/vmlinux.lds.S b/arch/x86/kernel/vmlinux.lds.S
index 977e9cf..7ef6b87 100644
--- a/arch/x86/kernel/vmlinux.lds.S
+++ b/arch/x86/kernel/vmlinux.lds.S
@@ -256,7 +256,6 @@ SECTIONS
 	.init.text (. - __KERNEL_TEXT_OFFSET): AT(init_begin - LOAD_OFFSET) {
 		VMLINUX_SYMBOL(_sinittext) = .;
 		INIT_TEXT
-		VMLINUX_SYMBOL(_einittext) = .;
 		. = ALIGN(PAGE_SIZE);
 	} :text.init
 
@@ -266,6 +265,7 @@ SECTIONS
 	 */
 	.exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
 		EXIT_TEXT
+		VMLINUX_SYMBOL(_einittext) = .;
 		. = ALIGN(16);
 	} :text.exit
 	. = init_begin + SIZEOF(.init.text) + SIZEOF(.exit.text);
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index 3e44696..cdb8f22 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -2258,7 +2258,7 @@ static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	 * Not recognized on AMD in compat mode (but is recognized in legacy
 	 * mode).
 	 */
-	if ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)
+	if ((ctxt->mode != X86EMUL_MODE_PROT64) && (efer & EFER_LMA)
 	    && !vendor_intel(ctxt))
 		return emulate_ud(ctxt);
 
@@ -2271,25 +2271,13 @@ static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	setup_syscalls_segments(ctxt, &cs, &ss);
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);
-	switch (ctxt->mode) {
-	case X86EMUL_MODE_PROT32:
-		if ((msr_data & 0xfffc) == 0x0)
-			return emulate_gp(ctxt, 0);
-		break;
-	case X86EMUL_MODE_PROT64:
-		if (msr_data == 0x0)
-			return emulate_gp(ctxt, 0);
-		break;
-	default:
-		break;
-	}
+	if ((msr_data & 0xfffc) == 0x0)
+		return emulate_gp(ctxt, 0);
 
 	ctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);
-	cs_sel = (u16)msr_data;
-	cs_sel &= ~SELECTOR_RPL_MASK;
+	cs_sel = (u16)msr_data & ~SELECTOR_RPL_MASK;
 	ss_sel = cs_sel + 8;
-	ss_sel &= ~SELECTOR_RPL_MASK;
-	if (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {
+	if (efer & EFER_LMA) {
 		cs.d = 0;
 		cs.l = 1;
 	}
@@ -2298,10 +2286,11 @@ static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	ops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);
-	ctxt->_eip = msr_data;
+	ctxt->_eip = (efer & EFER_LMA) ? msr_data : (u32)msr_data;
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);
-	*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;
+	*reg_write(ctxt, VCPU_REGS_RSP) = (efer & EFER_LMA) ? msr_data :
+							      (u32)msr_data;
 
 	return X86EMUL_CONTINUE;
 }
@@ -3668,8 +3657,8 @@ static const struct opcode group5[] = {
 };
 
 static const struct opcode group6[] = {
-	DI(Prot,	sldt),
-	DI(Prot,	str),
+	DI(Prot | DstMem,	sldt),
+	DI(Prot | DstMem,	str),
 	II(Prot | Priv | SrcMem16, em_lldt, lldt),
 	II(Prot | Priv | SrcMem16, em_ltr, ltr),
 	N, N, N, N,
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 3b0cb83..ec2028e 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -4182,7 +4182,10 @@ static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
 	unsigned long cr4;
 
 	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */
+
+#ifndef CONFIG_PAX_PER_CPU_PGD
 	vmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */
+#endif
 
 	/* Save the most likely value for this task's CR4 in the VMCS. */
 	cr4 = read_cr4();
diff --git a/arch/x86/mm/ioremap.c b/arch/x86/mm/ioremap.c
index 7e48391..49644a3 100644
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@ -317,21 +317,14 @@ EXPORT_SYMBOL(iounmap);
  */
 void *xlate_dev_mem_ptr(unsigned long phys)
 {
-	void *addr;
-	unsigned long start = phys & PAGE_MASK;
-
 	/* If page is RAM, we can use __va. Otherwise ioremap and unmap. */
-	if (page_is_ram(start >> PAGE_SHIFT))
+	if (page_is_ram(phys >> PAGE_SHIFT))
 #ifdef CONFIG_HIGHMEM
-	if ((start >> PAGE_SHIFT) < max_low_pfn)
+	if ((phys >> PAGE_SHIFT) < max_low_pfn)
 #endif
 		return __va(phys);
 
-	addr = (void __force *)ioremap_cache(start, PAGE_SIZE);
-	if (addr)
-		addr = (void *)((unsigned long)addr | (phys & ~PAGE_MASK));
-
-	return addr;
+	return (void __force *)ioremap_cache(phys, PAGE_SIZE);
 }
 
 void unxlate_dev_mem_ptr(unsigned long phys, void *addr)
diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c
index bc63cba..c405730 100644
--- a/arch/x86/net/bpf_jit_comp.c
+++ b/arch/x86/net/bpf_jit_comp.c
@@ -74,7 +74,8 @@ do {						\
 	EMIT2(0x81, 0xf1);			\
 	EMIT((_key) ^ (_off), 4);		\
 } while (0)
-
+#define SHORT_JMP_LENGTH 2
+#define NEAR_JMP_LENGTH (5 + 8)
 #define EMIT1_off32(b1, _off)								\
 do { 											\
 	switch (b1) {									\
@@ -82,13 +83,21 @@ do { 											\
 		case 0x2d: /* sub eax, imm32 */						\
 		case 0x25: /* and eax, imm32 */						\
 		case 0x0d: /* or eax, imm32 */						\
-		case 0xb8: /* mov eax, imm32 */						\
 		case 0x35: /* xor eax, imm32 */						\
 		case 0x3d: /* cmp eax, imm32 */						\
-		case 0xa9: /* test eax, imm32 */					\
 			DILUTE_CONST_SEQUENCE(_off, randkey);				\
 			EMIT2((b1) - 4, 0xc8); /* convert imm instruction to eax, ecx */\
 			break;								\
+		case 0xb8: /* mov eax, imm32 */						\
+			DILUTE_CONST_SEQUENCE(_off, randkey);				\
+			/* mov eax, ecx */						\
+			EMIT2(0x89, 0xc8);						\
+			break;								\
+		case 0xa9: /* test eax, imm32 */					\
+			DILUTE_CONST_SEQUENCE(_off, randkey);				\
+			/* test eax, ecx */						\
+			EMIT2(0x85, 0xc8);						\
+			break;								\
 		case 0xbb: /* mov ebx, imm32 */						\
 			DILUTE_CONST_SEQUENCE(_off, randkey);				\
 			/* mov ebx, ecx */						\
@@ -104,8 +113,9 @@ do { 											\
 			EMIT(_off, 4);							\
 			break;								\
 		case 0xe9: /* jmp rel imm32 */						\
+			BUG_ON((int)(_off) < 0);					\
 			EMIT1(b1);							\
-			EMIT(_off, 4);							\
+			EMIT(_off + 8, 4);						\
 			/* prevent fall-through, we're not called if off = 0 */		\
 			EMIT(0xcccccccc, 4);						\
 			EMIT(0xcccccccc, 4);						\
@@ -133,6 +143,8 @@ do { 									\
 #else
 #define EMIT1_off32(b1, off)	do { EMIT1(b1); EMIT(off, 4);} while (0)
 #define EMIT2_off32(b1, b2, off) do { EMIT2(b1, b2); EMIT(off, 4);} while (0)
+#define SHORT_JMP_LENGTH 2
+#define NEAR_JMP_LENGTH 5
 #endif
 
 #define CLEAR_A() EMIT2(0x31, 0xc0) /* xor %eax,%eax */
@@ -150,6 +162,7 @@ static inline bool is_near(int offset)
 
 #define EMIT_JMP(offset)						\
 do {									\
+        BUG_ON((int)(offset) < 0);					\
 	if (offset) {							\
 		if (is_near(offset))					\
 			EMIT2(0xeb, offset); /* jmp .+off8 */		\
@@ -188,11 +201,12 @@ do {				\
 
 #define EMIT_COND_JMP(op, offset)				\
 do {								\
+        BUG_ON((int)(offset) < 0);				\
 	if (is_near(offset))					\
 		EMIT2(op, offset); /* jxx .+off8 */		\
 	else {							\
 		EMIT2(0x0f, op + 0x10);				\
-		EMIT(offset, 4); /* jxx .+off32 */		\
+		EMIT((offset) + 21, 4); /* jxx .+off32 */		\
 		APPEND_FLOW_VERIFY();				\
 	}							\
 } while (0)
@@ -430,7 +444,7 @@ void bpf_jit_compile(struct sk_filter *fp)
 					EMIT_COND_JMP(X86_JE, addrs[pc_ret0 - 1] -
 								(addrs[i] - 4));
 				} else {
-					EMIT_COND_JMP(X86_JNE, 2 + 5);
+					EMIT_COND_JMP(X86_JNE, 2 + NEAR_JMP_LENGTH);
 					CLEAR_A();
 					EMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4)); /* jmp .+off32 */
 				}
@@ -821,7 +835,7 @@ cond_branch:			f_offset = addrs[i + filter[i].jf] - addrs[i];
 				}
 				if (filter[i].jt != 0) {
 					if (filter[i].jf && f_offset)
-						t_offset += is_near(f_offset) ? 2 : 5;
+						t_offset += is_near(f_offset) ? SHORT_JMP_LENGTH : NEAR_JMP_LENGTH;
 					EMIT_COND_JMP(t_op, t_offset);
 					if (filter[i].jf)
 						EMIT_JMP(f_offset);
diff --git a/arch/x86/vdso/vma.c b/arch/x86/vdso/vma.c
index 1661a97..2a5ff0d 100644
--- a/arch/x86/vdso/vma.c
+++ b/arch/x86/vdso/vma.c
@@ -177,7 +177,6 @@ static int setup_additional_pages(struct linux_binprm *bprm,
 #endif
 
 	addr = vdso_addr(mm->start_stack, size);
-	addr = align_vdso_addr(addr);
 	addr = get_unmapped_area(NULL, addr, size, 0, 0);
 	if (IS_ERR_VALUE(addr)) {
 		ret = addr;
diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c
index e4723e5..2302db1 100644
--- a/arch/x86/xen/enlighten.c
+++ b/arch/x86/xen/enlighten.c
@@ -1451,8 +1451,11 @@ static void __ref xen_setup_gdt(int cpu)
 	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry_boot;
 	pv_cpu_ops.load_gdt = xen_load_gdt_boot;
 
-	setup_stack_canary_segment(0);
-	switch_to_new_gdt(0);
+	setup_stack_canary_segment(cpu);
+#ifdef CONFIG_X86_64
+	load_percpu_segment(cpu);
+#endif
+	switch_to_new_gdt(cpu);
 
 	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry;
 	pv_cpu_ops.load_gdt = xen_load_gdt;
diff --git a/drivers/char/mem.c b/drivers/char/mem.c
index 1be4e4d..2cc937b 100644
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -132,7 +132,7 @@ static ssize_t read_mem(struct file *file, char __user *buf,
 #endif
 
 	while (count > 0) {
-		unsigned long remaining;
+		unsigned long remaining = 0;
 		char *temp;
 
 		sz = size_inside_page(p, count);
@@ -155,12 +155,13 @@ static ssize_t read_mem(struct file *file, char __user *buf,
 			unxlate_dev_mem_ptr(p, ptr);
 			return -ENOMEM;
 		}
-		memcpy(temp, ptr, sz);
+		remaining = probe_kernel_read(temp, ptr, sz);
 #else
 		temp = ptr;
 #endif
 
-		remaining = copy_to_user(buf, temp, sz);
+		if (!remaining)
+			remaining = copy_to_user(buf, temp, sz);
 
 #ifdef CONFIG_PAX_USERCOPY
 		kfree(temp);
@@ -432,12 +433,13 @@ static ssize_t read_kmem(struct file *file, char __user *buf,
 			temp = kmalloc(sz, GFP_KERNEL|GFP_USERCOPY);
 			if (!temp)
 				return -ENOMEM;
-			memcpy(temp, kbuf, sz);
+			err = probe_kernel_read(temp, kbuf, sz);
 #else
 			temp = kbuf;
 #endif
 
-			err = copy_to_user(buf, temp, sz);
+			if (!err)
+				err = copy_to_user(buf, temp, sz);
 
 #ifdef CONFIG_PAX_USERCOPY
 			kfree(temp);
diff --git a/drivers/gpu/drm/ttm/ttm_page_alloc.c b/drivers/gpu/drm/ttm/ttm_page_alloc.c
index c12be36..9c422dd 100644
--- a/drivers/gpu/drm/ttm/ttm_page_alloc.c
+++ b/drivers/gpu/drm/ttm/ttm_page_alloc.c
@@ -299,15 +299,14 @@ static void ttm_pool_update_free_locked(struct ttm_page_pool *pool,
  * @free_all: If set to true will free all pages in pool
  * @use_static: Safe to use static buffer
  **/
-static unsigned long ttm_page_pool_free(struct ttm_page_pool *pool, unsigned nr_free,
+static unsigned long ttm_page_pool_free(struct ttm_page_pool *pool, unsigned long nr_free,
 			      bool use_static)
 {
 	static struct page *static_buf[NUM_PAGES_TO_ALLOC];
 	unsigned long irq_flags;
 	struct page *p;
 	struct page **pages_to_free;
-	unsigned long freed_pages = 0,
-		 npages_to_free = nr_free;
+	unsigned long freed_pages = 0, npages_to_free = nr_free;
 
 	if (NUM_PAGES_TO_ALLOC < nr_free)
 		npages_to_free = NUM_PAGES_TO_ALLOC;
diff --git a/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c b/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
index ef127b8..44bfcb7 100644
--- a/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
+++ b/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
@@ -413,7 +413,7 @@ static void ttm_dma_page_put(struct dma_pool *pool, struct dma_page *d_page)
  * @nr_free: If set to true will free all pages in pool
  * @use_static: Safe to use static buffer
  **/
-static unsigned long ttm_dma_page_pool_free(struct dma_pool *pool, unsigned nr_free,
+static unsigned long ttm_dma_page_pool_free(struct dma_pool *pool, unsigned long nr_free,
 				       bool use_static)
 {
 	static struct page *static_buf[NUM_PAGES_TO_ALLOC];
@@ -421,8 +421,7 @@ static unsigned long ttm_dma_page_pool_free(struct dma_pool *pool, unsigned nr_f
 	struct dma_page *dma_p, *tmp;
 	struct page **pages_to_free;
 	struct list_head d_pages;
-	unsigned long freed_pages = 0,
-		 npages_to_free = nr_free;
+	unsigned long freed_pages = 0, npages_to_free = nr_free;
 
 	if (NUM_PAGES_TO_ALLOC < nr_free)
 		npages_to_free = NUM_PAGES_TO_ALLOC;
diff --git a/drivers/isdn/hardware/eicon/message.c b/drivers/isdn/hardware/eicon/message.c
index a82e542..f766a79 100644
--- a/drivers/isdn/hardware/eicon/message.c
+++ b/drivers/isdn/hardware/eicon/message.c
@@ -1474,7 +1474,7 @@ static byte connect_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
 					add_ai(plci, &parms[5]);
 					sig_req(plci, REJECT, 0);
 				}
-				else if (Reject == 1 || Reject > 9)
+				else if (Reject == 1 || Reject >= 9)
 				{
 					add_ai(plci, &parms[5]);
 					sig_req(plci, HANGUP, 0);
diff --git a/drivers/media/radio/wl128x/fmdrv_common.c b/drivers/media/radio/wl128x/fmdrv_common.c
index 4b2e9e8..c2900d9 100644
--- a/drivers/media/radio/wl128x/fmdrv_common.c
+++ b/drivers/media/radio/wl128x/fmdrv_common.c
@@ -71,7 +71,7 @@ module_param(default_rds_buf, uint, 0444);
 MODULE_PARM_DESC(rds_buf, "RDS buffer entries");
 
 /* Radio Nr */
-static u32 radio_nr = -1;
+static int radio_nr = -1;
 module_param(radio_nr, int, 0444);
 MODULE_PARM_DESC(radio_nr, "Radio Nr");
 
diff --git a/drivers/net/ethernet/freescale/gianfar_ethtool.c b/drivers/net/ethernet/freescale/gianfar_ethtool.c
index 63d2344..65b62c47 100644
--- a/drivers/net/ethernet/freescale/gianfar_ethtool.c
+++ b/drivers/net/ethernet/freescale/gianfar_ethtool.c
@@ -1614,7 +1614,7 @@ static int gfar_write_filer_table(struct gfar_private *priv,
 	lock_rx_qs(priv);
 
 	/* Fill regular entries */
-	for (; i < MAX_FILER_IDX - 1 && (tab->fe[i].ctrl | tab->fe[i].ctrl);
+	for (; i < MAX_FILER_IDX - 1 && (tab->fe[i].ctrl | tab->fe[i].prop);
 	     i++)
 		gfar_write_filer(priv, i, tab->fe[i].ctrl, tab->fe[i].prop);
 	/* Fill the rest with fall-troughs */
diff --git a/drivers/net/ethernet/neterion/s2io.c b/drivers/net/ethernet/neterion/s2io.c
index 9eeddbd..6d9e10d 100644
--- a/drivers/net/ethernet/neterion/s2io.c
+++ b/drivers/net/ethernet/neterion/s2io.c
@@ -6992,7 +6992,9 @@ static int s2io_add_isr(struct s2io_nic *sp)
 			if (sp->s2io_entries[i].in_use == MSIX_FLG) {
 				if (sp->s2io_entries[i].type ==
 				    MSIX_RING_TYPE) {
-					sprintf(sp->desc[i], "%s:MSI-X-%d-RX",
+					snprintf(sp->desc[i],
+						sizeof(sp->desc[i]),
+						"%s:MSI-X-%d-RX",
 						dev->name, i);
 					err = request_irq(sp->entries[i].vector,
 							  s2io_msix_ring_handle,
@@ -7001,7 +7003,9 @@ static int s2io_add_isr(struct s2io_nic *sp)
 							  sp->s2io_entries[i].arg);
 				} else if (sp->s2io_entries[i].type ==
 					   MSIX_ALARM_TYPE) {
-					sprintf(sp->desc[i], "%s:MSI-X-%d-TX",
+					snprintf(sp->desc[i],
+						sizeof(sp->desc[i]),
+						"%s:MSI-X-%d-TX",
 						dev->name, i);
 					err = request_irq(sp->entries[i].vector,
 							  s2io_msix_fifo_handle,
@@ -8159,7 +8163,8 @@ s2io_init_nic(struct pci_dev *pdev, const struct pci_device_id *pre)
 			  "%s: UDP Fragmentation Offload(UFO) enabled\n",
 			  dev->name);
 	/* Initialize device name */
-	sprintf(sp->name, "%s Neterion %s", dev->name, sp->product_name);
+	snprintf(sp->name, sizeof(sp->name), "%s Neterion %s", dev->name,
+		 sp->product_name);
 
 	if (vlan_tag_strip)
 		sp->vlan_strip_flag = 1;
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 25f7419..62ed80a7 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -216,7 +216,7 @@ EXPORT_SYMBOL(phy_device_create);
  *   zero on success.
  *
  */
-static int get_phy_c45_ids(struct mii_bus *bus, int addr, u32 *phy_id,
+static int get_phy_c45_ids(struct mii_bus *bus, int addr, int *phy_id,
 			   struct phy_c45_device_ids *c45_ids) {
 	int phy_reg;
 	int i, reg_addr;
@@ -286,7 +286,7 @@ static int get_phy_c45_ids(struct mii_bus *bus, int addr, u32 *phy_id,
  *   its return value is in turn returned.
  *
  */
-static int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id,
+static int get_phy_id(struct mii_bus *bus, int addr, int *phy_id,
 		      bool is_c45, struct phy_c45_device_ids *c45_ids)
 {
 	int phy_reg;
@@ -324,7 +324,7 @@ static int get_phy_id(struct mii_bus *bus, int addr, u32 *phy_id,
 struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)
 {
 	struct phy_c45_device_ids c45_ids = {0};
-	u32 phy_id = 0;
+	int phy_id = 0;
 	int r;
 
 	r = get_phy_id(bus, addr, &phy_id, is_c45, &c45_ids);
diff --git a/drivers/staging/line6/driver.c b/drivers/staging/line6/driver.c
index 4c55a18..1304fbe 100644
--- a/drivers/staging/line6/driver.c
+++ b/drivers/staging/line6/driver.c
@@ -522,7 +522,7 @@ int line6_write_data(struct usb_line6 *line6, int address, void *data,
 {
 	struct usb_device *usbdev = line6->usbdev;
 	int ret;
-	unsigned char status;
+	unsigned char *status;
 
 	ret = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0), 0x67,
 			      USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,
@@ -535,26 +535,34 @@ int line6_write_data(struct usb_line6 *line6, int address, void *data,
 		return ret;
 	}
 
+	status = kmalloc(1, GFP_KERNEL);
+	if (status == NULL)
+		return -ENOMEM;
+
 	do {
 		ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 				      0x67,
 				      USB_TYPE_VENDOR | USB_RECIP_DEVICE |
 				      USB_DIR_IN,
 				      0x0012, 0x0000,
-				      &status, 1, LINE6_TIMEOUT * HZ);
+				      status, 1, LINE6_TIMEOUT * HZ);
 
 		if (ret < 0) {
 			dev_err(line6->ifcdev,
 				"receiving status failed (error %d)\n", ret);
+			kfree(status);
 			return ret;
 		}
-	} while (status == 0xff);
+	} while (*status == 0xff);
 
-	if (status != 0) {
+	if (*status != 0) {
 		dev_err(line6->ifcdev, "write failed (error %d)\n", ret);
+		kfree(status);
 		return -EINVAL;
 	}
 
+	kfree(status);
+
 	return 0;
 }
 
diff --git a/drivers/staging/line6/toneport.c b/drivers/staging/line6/toneport.c
index af2e7e5..e558d65 100644
--- a/drivers/staging/line6/toneport.c
+++ b/drivers/staging/line6/toneport.c
@@ -11,6 +11,7 @@
  */
 
 #include <linux/wait.h>
+#include <linux/slab.h>
 #include <sound/control.h>
 
 #include "audio.h"
@@ -304,14 +305,20 @@ static void toneport_destruct(struct usb_interface *interface)
 */
 static void toneport_setup(struct usb_line6_toneport *toneport)
 {
-	int ticks;
+	int *ticks;
 	struct usb_line6 *line6 = &toneport->line6;
 	struct usb_device *usbdev = line6->usbdev;
 	u16 idProduct = le16_to_cpu(usbdev->descriptor.idProduct);
 
+	ticks = kmalloc(sizeof(int), GFP_KERNEL);
+	if (ticks == NULL)
+		return;
+
 	/* sync time on device with host: */
-	ticks = (int)get_seconds();
-	line6_write_data(line6, 0x80c6, &ticks, 4);
+	*ticks = (int)get_seconds();
+	line6_write_data(line6, 0x80c6, ticks, sizeof(int));
+
+	kfree(ticks);
 
 	/* enable device: */
 	toneport_send_cmd(usbdev, 0x0301, 0x0000);
diff --git a/fs/autofs4/dev-ioctl.c b/fs/autofs4/dev-ioctl.c
index e3399dc..23b078e 100644
--- a/fs/autofs4/dev-ioctl.c
+++ b/fs/autofs4/dev-ioctl.c
@@ -103,6 +103,9 @@ static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *i
 	if (tmp.size < sizeof(tmp))
 		return ERR_PTR(-EINVAL);
 
+	if (tmp.size > (PATH_MAX + sizeof(tmp)))
+		return ERR_PTR(-ENAMETOOLONG);
+
 	res = memdup_user(in, tmp.size);
 	if (!IS_ERR(res))
 		res->size = tmp.size;
diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c
index 3d2420c..e26bd76 100644
--- a/fs/cifs/cifs_debug.c
+++ b/fs/cifs/cifs_debug.c
@@ -615,9 +615,11 @@ cifs_security_flags_handle_must_flags(unsigned int *flags)
 		*flags = CIFSSEC_MUST_NTLMV2;
 	else if ((*flags & CIFSSEC_MUST_NTLM) == CIFSSEC_MUST_NTLM)
 		*flags = CIFSSEC_MUST_NTLM;
-	else if ((*flags & CIFSSEC_MUST_LANMAN) == CIFSSEC_MUST_LANMAN)
+	else if (CIFSSEC_MUST_LANMAN &&
+		 (*flags & CIFSSEC_MUST_LANMAN) == CIFSSEC_MUST_LANMAN)
 		*flags = CIFSSEC_MUST_LANMAN;
-	else if ((*flags & CIFSSEC_MUST_PLNTXT) == CIFSSEC_MUST_PLNTXT)
+	else if (CIFSSEC_MUST_PLNTXT &&
+		 (*flags & CIFSSEC_MUST_PLNTXT) == CIFSSEC_MUST_PLNTXT)
 		*flags = CIFSSEC_MUST_PLNTXT;
 
 	*flags |= signflags;
diff --git a/fs/cifs/smbencrypt.c b/fs/cifs/smbencrypt.c
index 43eb136..f17e718 100644
--- a/fs/cifs/smbencrypt.c
+++ b/fs/cifs/smbencrypt.c
@@ -220,7 +220,7 @@ E_md4hash(const unsigned char *passwd, unsigned char *p16,
 	}
 
 	rc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));
-	memset(wpwd, 0, 129 * sizeof(__le16));
+	memzero_explicit(wpwd, sizeof(wpwd));
 
 	return rc;
 }
diff --git a/fs/dcache.c b/fs/dcache.c
index 581b312..b8c2cf9 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -1522,6 +1522,9 @@ struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)
 	dentry->d_sb = sb;
 	dentry->d_op = NULL;
 	dentry->d_fsdata = NULL;
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	atomic_set(&dentry->chroot_refcnt, 0);
+#endif
 	INIT_HLIST_BL_NODE(&dentry->d_hash);
 	INIT_LIST_HEAD(&dentry->d_lru);
 	INIT_LIST_HEAD(&dentry->d_subdirs);
diff --git a/fs/exec.c b/fs/exec.c
index cb8ebd8..c3fd55e 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -2054,7 +2054,7 @@ void __check_object_size(const void *ptr, unsigned long n, bool to_user, bool co
 	const char *type;
 #endif
 
-#ifndef CONFIG_STACK_GROWSUP
+#if !defined(CONFIG_STACK_GROWSUP) && !defined(CONFIG_X86_64)
 	unsigned long stackstart = (unsigned long)task_stack_page(current);
 	unsigned long currentsp = (unsigned long)&stackstart;
 	if (unlikely((currentsp < stackstart + 512 ||
@@ -2096,7 +2096,7 @@ void pax_track_stack(void)
 {
 	unsigned long sp = (unsigned long)&sp;
 	if (sp < current_thread_info()->lowest_stack &&
-	    sp > (unsigned long)task_stack_page(current))
+	    sp >= (unsigned long)task_stack_page(current) + 2 * sizeof(unsigned long))
 		current_thread_info()->lowest_stack = sp;
 	if (unlikely((sp & ~(THREAD_SIZE - 1)) < (THREAD_SIZE/16)))
 		BUG();
diff --git a/fs/fhandle.c b/fs/fhandle.c
index ac037c9..2281df9 100644
--- a/fs/fhandle.c
+++ b/fs/fhandle.c
@@ -195,8 +195,9 @@ static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,
 		goto out_err;
 	}
 	/* copy the full handle */
-	if (copy_from_user(handle, ufh,
-			   sizeof(struct file_handle) +
+	*handle = f_handle;
+	if (copy_from_user(&handle->f_handle,
+			   &ufh->f_handle,
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
 		goto out_handle;
diff --git a/fs/fs_struct.c b/fs/fs_struct.c
index 543d620..2f2786d 100644
--- a/fs/fs_struct.c
+++ b/fs/fs_struct.c
@@ -16,6 +16,7 @@ void set_fs_root(struct fs_struct *fs, const struct path *path)
 	struct path old_root;
 
 	path_get(path);
+	gr_inc_chroot_refcnts(path->dentry, path->mnt);
 	spin_lock(&fs->lock);
 	write_seqcount_begin(&fs->seq);
 	old_root = fs->root;
@@ -23,8 +24,10 @@ void set_fs_root(struct fs_struct *fs, const struct path *path)
 	gr_set_chroot_entries(current, path);
 	write_seqcount_end(&fs->seq);
 	spin_unlock(&fs->lock);
-	if (old_root.dentry)
+	if (old_root.dentry) {
+		gr_dec_chroot_refcnts(old_root.dentry, old_root.mnt);
 		path_put(&old_root);
+	}
 }
 
 /*
@@ -91,6 +94,7 @@ void chroot_fs_refs(const struct path *old_root, const struct path *new_root)
 
 void free_fs_struct(struct fs_struct *fs)
 {
+	gr_dec_chroot_refcnts(fs->root.dentry, fs->root.mnt);
 	path_put(&fs->root);
 	path_put(&fs->pwd);
 	kmem_cache_free(fs_cachep, fs);
diff --git a/fs/namei.c b/fs/namei.c
index 34dd17d..07c6710 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -3707,7 +3707,7 @@ static long do_rmdir(int dfd, const char __user *pathname)
 	struct filename *name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	ino_t saved_ino = 0;
+	u64 saved_ino = 0;
 	dev_t saved_dev = 0;
 	unsigned int lookup_flags = 0;
 retry:
@@ -3742,7 +3742,7 @@ retry:
 		goto exit3;
 	}
 
-	saved_ino = dentry->d_inode->i_ino;
+	saved_ino = gr_get_ino_from_dentry(dentry);
 	saved_dev = gr_get_dev_from_dentry(dentry);
 
 	if (!gr_acl_handle_rmdir(dentry, nd.path.mnt)) {
@@ -3845,7 +3845,7 @@ static long do_unlinkat(int dfd, const char __user *pathname)
 	struct nameidata nd;
 	struct inode *inode = NULL;
 	struct inode *delegated_inode = NULL;
-	ino_t saved_ino = 0;
+	u64 saved_ino = 0;
 	dev_t saved_dev = 0;
 	unsigned int lookup_flags = 0;
 retry:
@@ -3875,7 +3875,7 @@ retry_deleg:
 		ihold(inode);
 
 		if (inode->i_nlink <= 1) {
-			saved_ino = inode->i_ino;
+			saved_ino = gr_get_ino_from_dentry(dentry);
 			saved_dev = gr_get_dev_from_dentry(dentry);
 		}
 		if (!gr_acl_handle_unlink(dentry, nd.path.mnt)) {
@@ -4433,6 +4433,14 @@ retry_deleg:
 	if (new_dentry == trap)
 		goto exit5;
 
+	if (gr_bad_chroot_rename(old_dentry, oldnd.path.mnt, new_dentry, newnd.path.mnt)) {
+		/* use EXDEV error to cause 'mv' to switch to an alternative
+		 * method for usability
+		 */
+		error = -EXDEV;
+		goto exit5;
+	}
+
 	error = gr_acl_handle_rename(new_dentry, new_dir, newnd.path.mnt,
 				     old_dentry, old_dir->d_inode, oldnd.path.mnt,
 				     to);
diff --git a/grsecurity/Kconfig b/grsecurity/Kconfig
index cdaa3ef..49e1a77 100644
--- a/grsecurity/Kconfig
+++ b/grsecurity/Kconfig
@@ -640,6 +640,22 @@ config GRKERNSEC_CHROOT_SYSCTL
 	  sysctl option is enabled, a sysctl option with name
 	  "chroot_deny_sysctl" is created.
 
+config GRKERNSEC_CHROOT_RENAME
+	bool "Deny bad renames"
+	default y if GRKERNSEC_CONFIG_AUTO
+	depends on GRKERNSEC_CHROOT
+	help
+	  If you say Y here, an attacker in a chroot will not be able to
+	  abuse the ability to create double chroots to break out of the
+	  chroot by exploiting a race condition between a rename of a directory
+	  within a chroot against an open of a symlink with relative path
+	  components.  This feature will likewise prevent an accomplice outside
+	  a chroot from enabling a user inside the chroot to break out and make
+	  use of their credentials on the global filesystem.  Enabling this
+	  feature is essential to prevent root users from breaking out of a
+	  chroot. If the sysctl option is enabled, a sysctl option with name
+	  "chroot_deny_bad_rename" is created.
+
 config GRKERNSEC_CHROOT_CAPS
 	bool "Capability restrictions"
 	default y if GRKERNSEC_CONFIG_AUTO
diff --git a/grsecurity/gracl.c b/grsecurity/gracl.c
index e56396f..24d5a4c 100644
--- a/grsecurity/gracl.c
+++ b/grsecurity/gracl.c
@@ -105,11 +105,26 @@ static inline dev_t __get_dev(const struct dentry *dentry)
 		return dentry->d_sb->s_dev;
 }
 
+static inline u64 __get_ino(const struct dentry *dentry)
+{
+#if defined(CONFIG_BTRFS_FS) || defined(CONFIG_BTRFS_FS_MODULE)
+	if (dentry->d_sb->s_magic == BTRFS_SUPER_MAGIC)
+		return btrfs_ino(dentry->d_inode);
+	else
+#endif
+		return dentry->d_inode->i_ino;
+}
+
 dev_t gr_get_dev_from_dentry(struct dentry *dentry)
 {
 	return __get_dev(dentry);
 }
 
+u64 gr_get_ino_from_dentry(struct dentry *dentry)
+{
+	return __get_ino(dentry);
+}
+
 static char gr_task_roletype_to_char(struct task_struct *task)
 {
 	switch (task->role->roletype &
@@ -448,7 +463,7 @@ lookup_acl_role_label(const struct task_struct *task, const uid_t uid,
 }
 
 struct acl_subject_label *
-lookup_acl_subj_label(const ino_t ino, const dev_t dev,
+lookup_acl_subj_label(const u64 ino, const dev_t dev,
 		      const struct acl_role_label *role)
 {
 	unsigned int index = gr_fhash(ino, dev, role->subj_hash_size);
@@ -468,7 +483,7 @@ lookup_acl_subj_label(const ino_t ino, const dev_t dev,
 }
 
 struct acl_subject_label *
-lookup_acl_subj_label_deleted(const ino_t ino, const dev_t dev,
+lookup_acl_subj_label_deleted(const u64 ino, const dev_t dev,
 			  const struct acl_role_label *role)
 {
 	unsigned int index = gr_fhash(ino, dev, role->subj_hash_size);
@@ -488,7 +503,7 @@ lookup_acl_subj_label_deleted(const ino_t ino, const dev_t dev,
 }
 
 static struct acl_object_label *
-lookup_acl_obj_label(const ino_t ino, const dev_t dev,
+lookup_acl_obj_label(const u64 ino, const dev_t dev,
 		     const struct acl_subject_label *subj)
 {
 	unsigned int index = gr_fhash(ino, dev, subj->obj_hash_size);
@@ -508,7 +523,7 @@ lookup_acl_obj_label(const ino_t ino, const dev_t dev,
 }
 
 static struct acl_object_label *
-lookup_acl_obj_label_create(const ino_t ino, const dev_t dev,
+lookup_acl_obj_label_create(const u64 ino, const dev_t dev,
 		     const struct acl_subject_label *subj)
 {
 	unsigned int index = gr_fhash(ino, dev, subj->obj_hash_size);
@@ -589,7 +604,7 @@ lookup_name_entry_create(const char *name)
 }
 
 static struct inodev_entry *
-lookup_inodev_entry(const ino_t ino, const dev_t dev)
+lookup_inodev_entry(const u64 ino, const dev_t dev)
 {
 	unsigned int index = gr_fhash(ino, dev, running_polstate.inodev_set.i_size);
 	struct inodev_entry *match;
@@ -814,7 +829,7 @@ chk_glob_label(struct acl_object_label *globbed,
 
 static struct acl_object_label *
 __full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
-	    const ino_t curr_ino, const dev_t curr_dev,
+	    const u64 curr_ino, const dev_t curr_dev,
 	    const struct acl_subject_label *subj, char **path, const int checkglob)
 {
 	struct acl_subject_label *tmpsubj;
@@ -845,7 +860,7 @@ full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
 	    const struct acl_subject_label *subj, char **path, const int checkglob)
 {
 	int newglob = checkglob;
-	ino_t inode;
+	u64 inode;
 	dev_t device;
 
 	/* if we aren't checking a subdirectory of the original path yet, don't do glob checking
@@ -857,7 +872,7 @@ full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
 		newglob = GR_NO_GLOB;
 
 	spin_lock(&curr_dentry->d_lock);
-	inode = curr_dentry->d_inode->i_ino;
+	inode = __get_ino(curr_dentry);
 	device = __get_dev(curr_dentry);
 	spin_unlock(&curr_dentry->d_lock);
 
@@ -990,7 +1005,7 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 			spin_lock(&dentry->d_lock);
 			read_lock(&gr_inode_lock);
 			retval =
-				lookup_acl_subj_label(dentry->d_inode->i_ino,
+				lookup_acl_subj_label(__get_ino(dentry),
 						__get_dev(dentry), role);
 			read_unlock(&gr_inode_lock);
 			spin_unlock(&dentry->d_lock);
@@ -1005,7 +1020,7 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 
 		spin_lock(&dentry->d_lock);
 		read_lock(&gr_inode_lock);
-		retval = lookup_acl_subj_label(dentry->d_inode->i_ino,
+		retval = lookup_acl_subj_label(__get_ino(dentry),
 					  __get_dev(dentry), role);
 		read_unlock(&gr_inode_lock);
 		parent = dentry->d_parent;
@@ -1019,7 +1034,7 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 
 	spin_lock(&dentry->d_lock);
 	read_lock(&gr_inode_lock);
-	retval = lookup_acl_subj_label(dentry->d_inode->i_ino,
+	retval = lookup_acl_subj_label(__get_ino(dentry),
 				  __get_dev(dentry), role);
 	read_unlock(&gr_inode_lock);
 	spin_unlock(&dentry->d_lock);
@@ -1027,7 +1042,7 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 	if (unlikely(retval == NULL)) {
 		/* gr_real_root is pinned, we don't need to hold a reference */
 		read_lock(&gr_inode_lock);
-		retval = lookup_acl_subj_label(gr_real_root.dentry->d_inode->i_ino,
+		retval = lookup_acl_subj_label(__get_ino(gr_real_root.dentry),
 					  __get_dev(gr_real_root.dentry), role);
 		read_unlock(&gr_inode_lock);
 	}
@@ -1154,14 +1169,27 @@ gr_set_proc_res(struct task_struct *task)
 		return;
 
 	for (i = 0; i < RLIM_NLIMITS; i++) {
+		unsigned long rlim_cur, rlim_max;
+
 		if (!(proc->resmask & (1U << i)))
 			continue;
 
-		task->signal->rlim[i].rlim_cur = proc->res[i].rlim_cur;
-		task->signal->rlim[i].rlim_max = proc->res[i].rlim_max;
+		rlim_cur = proc->res[i].rlim_cur;
+		rlim_max = proc->res[i].rlim_max;
+
+		if (i == RLIMIT_NOFILE) {
+			unsigned long saved_sysctl_nr_open = sysctl_nr_open;
+			if (rlim_cur > saved_sysctl_nr_open)
+				rlim_cur = saved_sysctl_nr_open;
+			if (rlim_max > saved_sysctl_nr_open)
+				rlim_max = saved_sysctl_nr_open;
+		}
+
+		task->signal->rlim[i].rlim_cur = rlim_cur;
+		task->signal->rlim[i].rlim_max = rlim_max;
 
 		if (i == RLIMIT_CPU)
-			update_rlimit_cpu(task, proc->res[i].rlim_cur);
+			update_rlimit_cpu(task, rlim_cur);
 	}
 
 	return;
@@ -1171,9 +1199,10 @@ gr_set_proc_res(struct task_struct *task)
 	rcu_read_lock();
 	read_lock(&tasklist_lock);
 	read_lock(&grsec_exec_file_lock);
+   except in the case of gr_set_role_label() (for __gr_get_subject_for_task)
 */
 
-struct acl_subject_label *__gr_get_subject_for_task(const struct gr_policy_state *state, struct task_struct *task, const char *filename)
+struct acl_subject_label *__gr_get_subject_for_task(const struct gr_policy_state *state, struct task_struct *task, const char *filename, int fallback)
 {
 	char *tmpname;
 	struct acl_subject_label *tmpsubj;
@@ -1215,15 +1244,15 @@ struct acl_subject_label *__gr_get_subject_for_task(const struct gr_policy_state
 	/* this also works for the reload case -- if we don't match a potentially inherited subject
 	   then we fall back to a normal lookup based on the binary's ino/dev
 	*/
-	if (tmpsubj == NULL)
+	if (tmpsubj == NULL && fallback)
 		tmpsubj = chk_subj_label(filp->f_path.dentry, filp->f_path.mnt, task->role);
 
 	return tmpsubj;
 }
 
-static struct acl_subject_label *gr_get_subject_for_task(struct task_struct *task, const char *filename)
+static struct acl_subject_label *gr_get_subject_for_task(struct task_struct *task, const char *filename, int fallback)
 {
-	return __gr_get_subject_for_task(&running_polstate, task, filename);
+	return __gr_get_subject_for_task(&running_polstate, task, filename, fallback);
 }
 
 void __gr_apply_subject_to_task(const struct gr_policy_state *state, struct task_struct *task, struct acl_subject_label *subj)
@@ -1287,7 +1316,7 @@ gr_search_file(const struct dentry * dentry, const __u32 mode,
 			task->role = current->role;
 			rcu_read_lock();
 			read_lock(&grsec_exec_file_lock);
-			subj = gr_get_subject_for_task(task, NULL);
+			subj = gr_get_subject_for_task(task, NULL, 1);
 			gr_apply_subject_to_task(task, subj);
 			read_unlock(&grsec_exec_file_lock);
 			rcu_read_unlock();
@@ -1697,6 +1726,7 @@ void
 gr_set_role_label(struct task_struct *task, const kuid_t kuid, const kgid_t kgid)
 {
 	struct acl_role_label *role = task->role;
+	struct acl_role_label *origrole = role;
 	struct acl_subject_label *subj = NULL;
 	struct acl_object_label *obj;
 	struct file *filp;
@@ -1729,10 +1759,28 @@ gr_set_role_label(struct task_struct *task, const kuid_t kuid, const kgid_t kgid
 	     ((role->roletype & GR_ROLE_GROUP) && !gr_acl_is_capable(CAP_SETGID))))
 		return;
 
-	/* perform subject lookup in possibly new role
-	   we can use this result below in the case where role == task->role
-	*/
-	subj = chk_subj_label(filp->f_path.dentry, filp->f_path.mnt, role);
+	task->role = role;
+
+	if (task->inherited) {
+		/* if we reached our subject through inheritance, then first see
+		   if there's a subject of the same name in the new role that has
+		   an object that would result in the same inherited subject
+		*/
+		subj = gr_get_subject_for_task(task, task->acl->filename, 0);
+		if (subj) {
+			obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, subj);
+			if (!(obj->mode & GR_INHERIT))
+				subj = NULL;
+		}
+		
+	}
+	if (subj == NULL) {
+		/* otherwise:
+		   perform subject lookup in possibly new role
+		   we can use this result below in the case where role == task->role
+		*/
+		subj = chk_subj_label(filp->f_path.dentry, filp->f_path.mnt, role);
+	}
 
 	/* if we changed uid/gid, but result in the same role
 	   and are using inheritance, don't lose the inherited subject
@@ -1740,14 +1788,12 @@ gr_set_role_label(struct task_struct *task, const kuid_t kuid, const kgid_t kgid
 	   would result in, we arrived via inheritance, don't
 	   lose subject
 	*/
-	if (role != task->role || (!(task->acl->mode & GR_INHERITLEARN) &&
+	if (role != origrole || (!(task->acl->mode & GR_INHERITLEARN) &&
 				   (subj == task->acl)))
 		task->acl = subj;
 
 	/* leave task->inherited unaffected */
 
-	task->role = role;
-
 	task->is_writable = 0;
 
 	/* ignore additional mmap checks for processes that are writable 
@@ -1846,7 +1892,7 @@ skip_check:
 
 /* always called with valid inodev ptr */
 static void
-do_handle_delete(struct inodev_entry *inodev, const ino_t ino, const dev_t dev)
+do_handle_delete(struct inodev_entry *inodev, const u64 ino, const dev_t dev)
 {
 	struct acl_object_label *matchpo;
 	struct acl_subject_label *matchps;
@@ -1874,7 +1920,7 @@ do_handle_delete(struct inodev_entry *inodev, const ino_t ino, const dev_t dev)
 }
 
 void
-gr_handle_delete(const ino_t ino, const dev_t dev)
+gr_handle_delete(const u64 ino, const dev_t dev)
 {
 	struct inodev_entry *inodev;
 
@@ -1891,8 +1937,8 @@ gr_handle_delete(const ino_t ino, const dev_t dev)
 }
 
 static void
-update_acl_obj_label(const ino_t oldinode, const dev_t olddevice,
-		     const ino_t newinode, const dev_t newdevice,
+update_acl_obj_label(const u64 oldinode, const dev_t olddevice,
+		     const u64 newinode, const dev_t newdevice,
 		     struct acl_subject_label *subj)
 {
 	unsigned int index = gr_fhash(oldinode, olddevice, subj->obj_hash_size);
@@ -1930,8 +1976,8 @@ update_acl_obj_label(const ino_t oldinode, const dev_t olddevice,
 }
 
 static void
-update_acl_subj_label(const ino_t oldinode, const dev_t olddevice,
-		      const ino_t newinode, const dev_t newdevice,
+update_acl_subj_label(const u64 oldinode, const dev_t olddevice,
+		      const u64 newinode, const dev_t newdevice,
 		      struct acl_role_label *role)
 {
 	unsigned int index = gr_fhash(oldinode, olddevice, role->subj_hash_size);
@@ -1969,8 +2015,8 @@ update_acl_subj_label(const ino_t oldinode, const dev_t olddevice,
 }
 
 static void
-update_inodev_entry(const ino_t oldinode, const dev_t olddevice,
-		    const ino_t newinode, const dev_t newdevice)
+update_inodev_entry(const u64 oldinode, const dev_t olddevice,
+		    const u64 newinode, const dev_t newdevice)
 {
 	unsigned int index = gr_fhash(oldinode, olddevice, running_polstate.inodev_set.i_size);
 	struct inodev_entry *match;
@@ -2006,7 +2052,7 @@ update_inodev_entry(const ino_t oldinode, const dev_t olddevice,
 }
 
 static void
-__do_handle_create(const struct name_entry *matchn, ino_t ino, dev_t dev)
+__do_handle_create(const struct name_entry *matchn, u64 ino, dev_t dev)
 {
 	struct acl_subject_label *subj;
 	struct acl_role_label *role;
@@ -2039,7 +2085,7 @@ static void
 do_handle_create(const struct name_entry *matchn, const struct dentry *dentry,
 		 const struct vfsmount *mnt)
 {
-	ino_t ino = dentry->d_inode->i_ino;
+	u64 ino = __get_ino(dentry);
 	dev_t dev = __get_dev(dentry);
 
 	__do_handle_create(matchn, ino, dev);	
@@ -2098,7 +2144,7 @@ gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
 	struct name_entry *matchn;
 	struct inodev_entry *inodev;
 	struct inode *inode = new_dentry->d_inode;
-	ino_t old_ino = old_dentry->d_inode->i_ino;
+	u64 old_ino = __get_ino(old_dentry);
 	dev_t old_dev = __get_dev(old_dentry);
 
 	/* vfs_rename swaps the name and parent link for old_dentry and
@@ -2121,7 +2167,7 @@ gr_handle_rename(struct inode *old_dir, struct inode *new_dir,
 
 	write_lock(&gr_inode_lock);
 	if (unlikely(replace && inode)) {
-		ino_t new_ino = inode->i_ino;
+		u64 new_ino = __get_ino(new_dentry);
 		dev_t new_dev = __get_dev(new_dentry);
 
 		inodev = lookup_inodev_entry(new_ino, new_dev);
@@ -2578,7 +2624,7 @@ int gr_acl_enable_at_secure(void)
 	return 0;
 }
 	
-int gr_acl_handle_filldir(const struct file *file, const char *name, const unsigned int namelen, const ino_t ino)
+int gr_acl_handle_filldir(const struct file *file, const char *name, const unsigned int namelen, const u64 ino)
 {
 	struct task_struct *task = current;
 	struct dentry *dentry = file->f_path.dentry;
diff --git a/grsecurity/gracl_compat.c b/grsecurity/gracl_compat.c
index ca25605..a43dd06 100644
--- a/grsecurity/gracl_compat.c
+++ b/grsecurity/gracl_compat.c
@@ -12,8 +12,7 @@ int copy_gr_arg_wrapper_compat(const char *buf, struct gr_arg_wrapper *uwrap)
         if (copy_from_user(&uwrapcompat, buf, sizeof(uwrapcompat)))
                 return -EFAULT;
 
-        if (((uwrapcompat.version != GRSECURITY_VERSION) &&
-	     (uwrapcompat.version != 0x2901)) ||
+        if ((uwrapcompat.version != GRSECURITY_VERSION) ||
 	    (uwrapcompat.size != sizeof(struct gr_arg_compat)))  
                 return -EINVAL;
 
diff --git a/grsecurity/gracl_fs.c b/grsecurity/gracl_fs.c
index a89b1f4..4c7e00a 100644
--- a/grsecurity/gracl_fs.c
+++ b/grsecurity/gracl_fs.c
@@ -430,7 +430,9 @@ gr_acl_handle_procpidmem(const struct task_struct *task)
 	if (unlikely(!gr_acl_is_enabled()))
 		return 0;
 
-	if (task != current && task->acl->mode & GR_PROTPROCFD)
+	if (task != current && (task->acl->mode & GR_PROTPROCFD) &&
+	    !(current->acl->mode & GR_POVERRIDE) &&
+	    !(current->role->roletype & GR_ROLE_GOD))
 		return -EACCES;
 
 	return 0;
diff --git a/grsecurity/gracl_policy.c b/grsecurity/gracl_policy.c
index 3f8ade0..fd26052 100644
--- a/grsecurity/gracl_policy.c
+++ b/grsecurity/gracl_policy.c
@@ -68,7 +68,7 @@ extern void gr_free_uidset(void);
 extern void gr_remove_uid(uid_t uid);
 extern int gr_find_uid(uid_t uid);
 
-extern struct acl_subject_label *__gr_get_subject_for_task(const struct gr_policy_state *state, struct task_struct *task, const char *filename);
+extern struct acl_subject_label *__gr_get_subject_for_task(const struct gr_policy_state *state, struct task_struct *task, const char *filename, int fallback);
 extern void __gr_apply_subject_to_task(struct gr_policy_state *state, struct task_struct *task, struct acl_subject_label *subj);
 extern int gr_streq(const char *a, const char *b, const unsigned int lena, const unsigned int lenb);
 extern void __insert_inodev_entry(const struct gr_policy_state *state, struct inodev_entry *entry);
@@ -77,8 +77,8 @@ extern void insert_acl_obj_label(struct acl_object_label *obj, struct acl_subjec
 extern void insert_acl_subj_label(struct acl_subject_label *obj, struct acl_role_label *role);
 extern struct name_entry * __lookup_name_entry(const struct gr_policy_state *state, const char *name);
 extern char *gr_to_filename_rbac(const struct dentry *dentry, const struct vfsmount *mnt);
-extern struct acl_subject_label *lookup_acl_subj_label(const ino_t ino, const dev_t dev, const struct acl_role_label *role);
-extern struct acl_subject_label *lookup_acl_subj_label_deleted(const ino_t ino, const dev_t dev, const struct acl_role_label *role);
+extern struct acl_subject_label *lookup_acl_subj_label(const u64 ino, const dev_t dev, const struct acl_role_label *role);
+extern struct acl_subject_label *lookup_acl_subj_label_deleted(const u64 ino, const dev_t dev, const struct acl_role_label *role);
 extern void assign_special_role(const char *rolename);
 extern struct acl_subject_label *chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt, const struct acl_role_label *role);
 extern int gr_rbac_disable(void *unused);
@@ -161,8 +161,7 @@ static int copy_gr_arg_wrapper_normal(const char __user *buf, struct gr_arg_wrap
 	if (copy_from_user(uwrap, buf, sizeof (struct gr_arg_wrapper)))
 		return -EFAULT;
 
-	if (((uwrap->version != GRSECURITY_VERSION) &&
-	     (uwrap->version != 0x2901)) ||
+	if ((uwrap->version != GRSECURITY_VERSION) ||
 	    (uwrap->size != sizeof(struct gr_arg)))
 		return -EINVAL;
 
@@ -347,7 +346,7 @@ insert_acl_role_label(struct acl_role_label *role)
 }
 					
 static int
-insert_name_entry(char *name, const ino_t inode, const dev_t device, __u8 deleted)
+insert_name_entry(char *name, const u64 inode, const dev_t device, __u8 deleted)
 {
 	struct name_entry **curr, *nentry;
 	struct inodev_entry *ientry;
@@ -1173,8 +1172,8 @@ static int gracl_reload_apply_policies(void *reload)
 		}
 		/* this handles non-nested inherited subjects, nested subjects will still
 		   be dropped currently */
-		subj = __gr_get_subject_for_task(polstate, task, task->acl->filename);
-		task->tmpacl = __gr_get_subject_for_task(polstate, task, NULL);
+		subj = __gr_get_subject_for_task(polstate, task, task->acl->filename, 1);
+		task->tmpacl = __gr_get_subject_for_task(polstate, task, NULL, 1);
 		/* change the role back so that we've made no modifications to the policy */
 		task->role = rtmp;
 
@@ -1206,7 +1205,7 @@ static int gracl_reload_apply_policies(void *reload)
 			/* this handles non-nested inherited subjects, nested subjects will still
 			   be dropped currently */
 			if (!reload_state->oldmode && task->inherited)
-				subj = __gr_get_subject_for_task(polstate, task, task->acl->filename);
+				subj = __gr_get_subject_for_task(polstate, task, task->acl->filename, 1);
 			else {
 				/* looked up and tagged to the task previously */
 				subj = task->tmpacl;
@@ -1755,7 +1754,7 @@ gr_set_acls(const int type)
 		if (task->exec_file) {
 			cred = __task_cred(task);
 			task->role = __lookup_acl_role_label(polstate, task, GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid));
-			subj = __gr_get_subject_for_task(polstate, task, NULL);
+			subj = __gr_get_subject_for_task(polstate, task, NULL, 1);
 			if (subj == NULL) {
 				ret = -EINVAL;
 				read_unlock(&grsec_exec_file_lock);
diff --git a/grsecurity/gracl_segv.c b/grsecurity/gracl_segv.c
index 2040e61..218b66b 100644
--- a/grsecurity/gracl_segv.c
+++ b/grsecurity/gracl_segv.c
@@ -28,7 +28,7 @@ static unsigned short uid_used;
 static DEFINE_SPINLOCK(gr_uid_lock);
 extern rwlock_t gr_inode_lock;
 extern struct acl_subject_label *
-	lookup_acl_subj_label(const ino_t inode, const dev_t dev,
+	lookup_acl_subj_label(const u64 inode, const dev_t dev,
 			      struct acl_role_label *role);
 
 static inline dev_t __get_dev(const struct dentry *dentry)
@@ -41,6 +41,16 @@ static inline dev_t __get_dev(const struct dentry *dentry)
 		return dentry->d_sb->s_dev;
 }
 
+static inline u64 __get_ino(const struct dentry *dentry)
+{
+#if defined(CONFIG_BTRFS_FS) || defined(CONFIG_BTRFS_FS_MODULE)
+	if (dentry->d_sb->s_magic == BTRFS_SUPER_MAGIC)
+		return btrfs_ino(dentry->d_inode);
+	else
+#endif
+		return dentry->d_inode->i_ino;
+}
+
 int
 gr_init_uidset(void)
 {
@@ -261,13 +271,14 @@ int
 gr_check_crash_exec(const struct file *filp)
 {
 	struct acl_subject_label *curr;
+	struct dentry *dentry;
 
 	if (unlikely(!gr_acl_is_enabled()))
 		return 0;
 
 	read_lock(&gr_inode_lock);
-	curr = lookup_acl_subj_label(filp->f_path.dentry->d_inode->i_ino,
-				     __get_dev(filp->f_path.dentry),
+	dentry = filp->f_path.dentry;
+	curr = lookup_acl_subj_label(__get_ino(dentry), __get_dev(dentry),
 				     current->role);
 	read_unlock(&gr_inode_lock);
 
diff --git a/grsecurity/grsec_chroot.c b/grsecurity/grsec_chroot.c
index baa635c..2a43673 100644
--- a/grsecurity/grsec_chroot.c
+++ b/grsecurity/grsec_chroot.c
@@ -13,6 +13,88 @@
 int gr_init_ran;
 #endif
 
+void gr_inc_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	struct dentry *tmpd = dentry;
+
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+
+	while (tmpd != mnt->mnt_root) {
+		atomic_inc(&tmpd->chroot_refcnt);
+		tmpd = tmpd->d_parent;
+	}
+	atomic_inc(&tmpd->chroot_refcnt);
+
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+#endif
+}
+
+void gr_dec_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	struct dentry *tmpd = dentry;
+
+	read_seqlock_excl(&mount_lock);
+	write_seqlock(&rename_lock);
+
+	while (tmpd != mnt->mnt_root) {
+		atomic_dec(&tmpd->chroot_refcnt);
+		tmpd = tmpd->d_parent;
+	}
+	atomic_dec(&tmpd->chroot_refcnt);
+
+	write_sequnlock(&rename_lock);
+	read_sequnlock_excl(&mount_lock);
+#endif
+}
+
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+static struct dentry *get_closest_chroot(struct dentry *dentry)
+{
+	write_seqlock(&rename_lock);
+	do {
+		if (atomic_read(&dentry->chroot_refcnt)) {
+			write_sequnlock(&rename_lock);
+			return dentry;
+		}
+		dentry = dentry->d_parent;
+	} while (!IS_ROOT(dentry));
+	write_sequnlock(&rename_lock);
+	return NULL;
+}
+#endif
+
+int gr_bad_chroot_rename(struct dentry *olddentry, struct vfsmount *oldmnt,
+			 struct dentry *newdentry, struct vfsmount *newmnt)
+{
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	struct dentry *chroot;
+
+	if (unlikely(!grsec_enable_chroot_rename))
+		return 0;
+
+	if (likely(!proc_is_chrooted(current) && gr_is_global_root(current_uid())))
+		return 0;
+
+	chroot = get_closest_chroot(olddentry);
+
+	if (chroot == NULL)
+		return 0;
+
+	if (is_subdir(newdentry, chroot))
+		return 0;
+
+	gr_log_fs_generic(GR_DONT_AUDIT, GR_CHROOT_RENAME_MSG, olddentry, oldmnt);
+
+	return 1;
+#else
+	return 0;
+#endif
+}
+
 void gr_set_chroot_entries(struct task_struct *task, const struct path *path)
 {
 #ifdef CONFIG_GRKERNSEC
diff --git a/grsecurity/grsec_disabled.c b/grsecurity/grsec_disabled.c
index 1e028d7..7e8cbe4 100644
--- a/grsecurity/grsec_disabled.c
+++ b/grsecurity/grsec_disabled.c
@@ -119,7 +119,7 @@ gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt,
 }
 
 void
-gr_handle_delete(const ino_t ino, const dev_t dev)
+gr_handle_delete(const u64 ino, const dev_t dev)
 {
 	return;
 }
@@ -319,7 +319,7 @@ gr_acl_handle_rename(const struct dentry *new_dentry,
 
 int
 gr_acl_handle_filldir(const struct file *file, const char *name,
-		      const int namelen, const ino_t ino)
+		      const int namelen, const u64 ino)
 {
 	return 1;
 }
@@ -428,6 +428,11 @@ dev_t gr_get_dev_from_dentry(struct dentry *dentry)
 	return dentry->d_sb->s_dev;
 }
 
+u64 gr_get_ino_from_dentry(struct dentry *dentry)
+{
+	return dentry->d_inode->i_ino;
+}
+
 void gr_put_exec_file(struct task_struct *task)
 {
 	return;
diff --git a/grsecurity/grsec_init.c b/grsecurity/grsec_init.c
index b7cb191..4ed9e7d 100644
--- a/grsecurity/grsec_init.c
+++ b/grsecurity/grsec_init.c
@@ -40,6 +40,7 @@ int grsec_enable_chroot_mknod;
 int grsec_enable_chroot_nice;
 int grsec_enable_chroot_execlog;
 int grsec_enable_chroot_caps;
+int grsec_enable_chroot_rename;
 int grsec_enable_chroot_sysctl;
 int grsec_enable_chroot_unix;
 int grsec_enable_tpe;
@@ -251,6 +252,9 @@ grsecurity_init(void)
 #ifdef CONFIG_GRKERNSEC_CHROOT_CAPS
 	grsec_enable_chroot_caps = 1;
 #endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	grsec_enable_chroot_rename = 1;
+#endif
 #ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
 	grsec_enable_chroot_sysctl = 1;
 #endif
diff --git a/grsecurity/grsec_sysctl.c b/grsecurity/grsec_sysctl.c
index 8159888..cce889e 100644
--- a/grsecurity/grsec_sysctl.c
+++ b/grsecurity/grsec_sysctl.c
@@ -267,6 +267,15 @@ struct ctl_table grsecurity_table[] = {
 		.proc_handler	= &proc_dointvec,
 	},
 #endif
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	{
+		.procname	= "chroot_deny_bad_rename",
+		.data		= &grsec_enable_chroot_rename,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= &proc_dointvec,
+	},
+#endif
 #ifdef CONFIG_GRKERNSEC_CHROOT_SYSCTL
 	{
 		.procname	= "chroot_deny_sysctl",
diff --git a/include/linux/compiler-gcc5.h b/include/linux/compiler-gcc5.h
index cdd1cc2..59dc542 100644
--- a/include/linux/compiler-gcc5.h
+++ b/include/linux/compiler-gcc5.h
@@ -28,6 +28,28 @@
 # define __compiletime_error(message) __attribute__((error(message)))
 #endif /* __CHECKER__ */
 
+#define __alloc_size(...)	__attribute((alloc_size(__VA_ARGS__)))
+#define __bos(ptr, arg)		__builtin_object_size((ptr), (arg))
+#define __bos0(ptr)		__bos((ptr), 0)
+#define __bos1(ptr)		__bos((ptr), 1)
+
+#ifdef CONSTIFY_PLUGIN
+#error not yet
+#define __no_const __attribute__((no_const))
+#define __do_const __attribute__((do_const))
+#endif
+
+#ifdef SIZE_OVERFLOW_PLUGIN
+#error not yet
+#define __size_overflow(...) __attribute__((size_overflow(__VA_ARGS__)))
+#define __intentional_overflow(...) __attribute__((intentional_overflow(__VA_ARGS__)))
+#endif
+
+#ifdef LATENT_ENTROPY_PLUGIN
+#error not yet
+#define __latent_entropy __attribute__((latent_entropy))
+#endif
+
 /*
  * Mark a position in code as unreachable.  This can be used to
  * suppress control flow warnings after asm blocks that transfer
diff --git a/include/linux/dcache.h b/include/linux/dcache.h
index 71a4cec..a3b0c8a 100644
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -123,6 +123,9 @@ struct dentry {
 	unsigned long d_time;		/* used by d_revalidate */
 	void *d_fsdata;			/* fs-specific data */
 
+#ifdef CONFIG_GRKERNSEC_CHROOT_RENAME
+	atomic_t chroot_refcnt;		/* tracks use of directory in chroot */
+#endif
 	struct list_head d_lru;		/* LRU list */
 	/*
 	 * d_child and d_rcu can share memory
diff --git a/include/linux/gracl.h b/include/linux/gracl.h
index edb2cb6..91858e4 100644
--- a/include/linux/gracl.h
+++ b/include/linux/gracl.h
@@ -9,8 +9,8 @@
 
 /* Major status information */
 
-#define GR_VERSION  "grsecurity 3.0"
-#define GRSECURITY_VERSION 0x3000
+#define GR_VERSION  "grsecurity 3.1"
+#define GRSECURITY_VERSION 0x3100
 
 enum {
 	GR_SHUTDOWN = 0,
@@ -55,7 +55,7 @@ struct sprole_pw {
 
 struct name_entry {
 	__u32 key;
-	ino_t inode;
+	u64 inode;
 	dev_t device;
 	char *name;
 	__u16 len;
@@ -103,7 +103,7 @@ struct gr_hash_struct {
 
 struct acl_subject_label {
 	char *filename;
-	ino_t inode;
+	u64 inode;
 	dev_t device;
 	__u32 mode;
 	kernel_cap_t cap_mask;
@@ -191,7 +191,7 @@ struct user_acl_role_db {
 
 struct acl_object_label {
 	char *filename;
-	ino_t inode;
+	u64 inode;
 	dev_t device;
 	__u32 mode;
 
@@ -227,7 +227,7 @@ struct gr_arg {
 	unsigned char sp_role[GR_SPROLE_LEN];
 	struct sprole_pw *sprole_pws;
 	dev_t segv_device;
-	ino_t segv_inode;
+	u64 segv_inode;
 	uid_t segv_uid;
 	__u16 num_sprole_pws;
 	__u16 mode;
@@ -299,9 +299,11 @@ gr_shash(const struct acl_subject_label *userp, const unsigned int sz)
 }
 
 static __inline__ unsigned int
-gr_fhash(const ino_t ino, const dev_t dev, const unsigned int sz)
+gr_fhash(const u64 ino, const dev_t dev, const unsigned int sz)
 {
-	return (((ino + dev) ^ ((ino << 13) + (ino << 23) + (dev << 9))) % sz);
+	unsigned int rem;
+	div_u64_rem((ino + dev) ^ ((ino << 13) + (ino << 23) + (dev << 9)), sz, &rem);
+	return rem;
 }
 
 static __inline__ unsigned int
diff --git a/include/linux/gracl_compat.h b/include/linux/gracl_compat.h
index 33ebd1f..af64092 100644
--- a/include/linux/gracl_compat.h
+++ b/include/linux/gracl_compat.h
@@ -21,7 +21,7 @@ struct gr_hash_struct_compat {
 
 struct acl_subject_label_compat {
 	compat_uptr_t filename;
-	compat_ino_t inode;
+	compat_u64 inode;
 	__u32 device;
 	__u32 mode;
 	kernel_cap_t cap_mask;
@@ -109,7 +109,7 @@ struct user_acl_role_db_compat {
 
 struct acl_object_label_compat {
 	compat_uptr_t filename;
-	compat_ino_t inode;
+	compat_u64 inode;
 	__u32 device;
 	__u32 mode;
 
@@ -141,7 +141,7 @@ struct gr_arg_compat {
 	unsigned char sp_role[GR_SPROLE_LEN];
 	compat_uptr_t sprole_pws;
 	__u32 segv_device;
-	compat_ino_t segv_inode;
+	compat_u64 segv_inode;
 	uid_t segv_uid;
 	__u16 num_sprole_pws;
 	__u16 mode;
diff --git a/include/linux/grinternal.h b/include/linux/grinternal.h
index d25522e..fb1de5d 100644
--- a/include/linux/grinternal.h
+++ b/include/linux/grinternal.h
@@ -57,6 +57,7 @@ extern int grsec_enable_chroot_fchdir;
 extern int grsec_enable_chroot_nice;
 extern int grsec_enable_chroot_execlog;
 extern int grsec_enable_chroot_caps;
+extern int grsec_enable_chroot_rename;
 extern int grsec_enable_chroot_sysctl;
 extern int grsec_enable_chroot_unix;
 extern int grsec_enable_symlinkown;
diff --git a/include/linux/grmsg.h b/include/linux/grmsg.h
index b02ba9d..26ef560 100644
--- a/include/linux/grmsg.h
+++ b/include/linux/grmsg.h
@@ -41,6 +41,7 @@
 #define GR_ATIME_ACL_MSG "%s access time change of %.950s by "
 #define GR_ACCESS_ACL_MSG "%s access of %.950s for%s%s%s by "
 #define GR_CHROOT_CHROOT_MSG "denied double chroot to %.950s by "
+#define GR_CHROOT_RENAME_MSG "denied bad rename of %.950s out of a chroot by "
 #define GR_CHMOD_CHROOT_MSG "denied chmod +s of %.950s by "
 #define GR_CHMOD_ACL_MSG "%s chmod of %.950s by "
 #define GR_CHROOT_FCHDIR_MSG "denied fchdir outside of chroot to %.950s by "
diff --git a/include/linux/grsecurity.h b/include/linux/grsecurity.h
index acda855..0fb332e 100644
--- a/include/linux/grsecurity.h
+++ b/include/linux/grsecurity.h
@@ -165,7 +165,7 @@ __u32 gr_acl_handle_mkdir(const struct dentry *new_dentry,
 				 const struct vfsmount *parent_mnt);
 __u32 gr_acl_handle_rmdir(const struct dentry *dentry,
 				 const struct vfsmount *mnt);
-void gr_handle_delete(const ino_t ino, const dev_t dev);
+void gr_handle_delete(const u64 ino, const dev_t dev);
 __u32 gr_acl_handle_unlink(const struct dentry *dentry,
 				  const struct vfsmount *mnt);
 __u32 gr_acl_handle_symlink(const struct dentry *new_dentry,
@@ -194,7 +194,7 @@ __u32 gr_check_link(const struct dentry *new_dentry,
 			   const struct dentry *old_dentry,
 			   const struct vfsmount *old_mnt);
 int gr_acl_handle_filldir(const struct file *file, const char *name,
-				 const unsigned int namelen, const ino_t ino);
+				 const unsigned int namelen, const u64 ino);
 
 __u32 gr_acl_handle_unix(const struct dentry *dentry,
 				const struct vfsmount *mnt);
@@ -205,6 +205,7 @@ int gr_handle_rofs_mount(struct dentry *dentry, struct vfsmount *mnt, int mnt_fl
 int gr_handle_rofs_blockwrite(struct dentry *dentry, struct vfsmount *mnt, int acc_mode);
 void gr_audit_ptrace(struct task_struct *task);
 dev_t gr_get_dev_from_dentry(struct dentry *dentry);
+u64 gr_get_ino_from_dentry(struct dentry *dentry);
 void gr_put_exec_file(struct task_struct *task);
 
 int gr_ptrace_readexec(struct file *file, int unsafe_flags);
@@ -221,14 +222,19 @@ static inline void gr_learn_resource(const struct task_struct *task, const int r
 
 #ifdef CONFIG_GRKERNSEC_RESLOG
 extern void gr_log_resource(const struct task_struct *task, const int res,
-				   const unsigned long wanted, const int gt);
+				const unsigned long wanted, const int gt);
 #else
 static inline void gr_log_resource(const struct task_struct *task, const int res,
-				   const unsigned long wanted, const int gt)
+				const unsigned long wanted, const int gt)
 {
 }
 #endif
 
+void gr_inc_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt);
+void gr_dec_chroot_refcnts(struct dentry *dentry, struct vfsmount *mnt);
+int gr_bad_chroot_rename(struct dentry *olddentry, struct vfsmount *oldmnt,
+			 struct dentry *newdentry, struct vfsmount *newmnt);
+
 #ifdef CONFIG_GRKERNSEC
 void task_grsec_rbac(struct seq_file *m, struct task_struct *p);
 void gr_handle_vm86(void);
diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h
index 2faef33..33dc081 100644
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -193,7 +193,7 @@ struct ipv6_pinfo {
 	                        sndflow:1,
 				repflow:1,
 				pmtudisc:3,
-				ipv6only:1,
+				padding:1,	/* 1 bit hole */
 				srcprefs:3,	/* 001: prefer temporary address
 						 * 010: prefer public address
 						 * 100: prefer care-of address
@@ -282,8 +282,8 @@ static inline void inet_sk_copy_descendant(struct sock *sk_to,
 	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);
 }
 
-#define __ipv6_only_sock(sk)	(inet6_sk(sk)->ipv6only)
-#define ipv6_only_sock(sk)	((sk)->sk_family == PF_INET6 && __ipv6_only_sock(sk))
+#define __ipv6_only_sock(sk)	(sk->sk_ipv6only)
+#define ipv6_only_sock(sk)	(__ipv6_only_sock(sk))
 #define ipv6_sk_rxinfo(sk)	((sk)->sk_family == PF_INET6 && \
 				 inet6_sk(sk)->rxopt.bits.rxinfo)
 
@@ -296,8 +296,8 @@ static inline const struct in6_addr *inet6_rcv_saddr(const struct sock *sk)
 
 static inline int inet_v6_ipv6only(const struct sock *sk)
 {
-	return likely(sk->sk_state != TCP_TIME_WAIT) ?
-		ipv6_only_sock(sk) : inet_twsk(sk)->tw_ipv6only;
+	/* ipv6only field is at same position for timewait and other sockets */
+	return ipv6_only_sock(sk);
 }
 #else
 #define __ipv6_only_sock(sk)	0
diff --git a/include/linux/irqdesc.h b/include/linux/irqdesc.h
index 472c021..097cc8b 100644
--- a/include/linux/irqdesc.h
+++ b/include/linux/irqdesc.h
@@ -54,7 +54,7 @@ struct irq_desc {
 	unsigned int		irq_count;	/* For detecting broken IRQs */
 	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
 	unsigned int		irqs_unhandled;
-	atomic_t		threads_handled;
+	atomic_unchecked_t	threads_handled;
 	int			threads_handled_last;
 	raw_spinlock_t		lock;
 	struct cpumask		*percpu_enabled;
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index bb74dbe..838afec 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -513,7 +513,7 @@ struct zone {
 
 	ZONE_PADDING(_pad3_)
 	/* Zone statistics */
-	atomic_long_unchecked_t		vm_stat[NR_VM_ZONE_STAT_ITEMS];
+	atomic_long_unchecked_t	vm_stat[NR_VM_ZONE_STAT_ITEMS];
 } ____cacheline_internodealigned_in_smp;
 
 typedef enum {
diff --git a/include/linux/percpu.h b/include/linux/percpu.h
index e3817d2..74af65b 100644
--- a/include/linux/percpu.h
+++ b/include/linux/percpu.h
@@ -59,7 +59,7 @@
  * preallocate for this.  Keep PERCPU_DYNAMIC_RESERVE equal to or
  * larger than PERCPU_DYNAMIC_EARLY_SIZE.
  */
-#define PERCPU_DYNAMIC_EARLY_SLOTS	128
+#define PERCPU_DYNAMIC_EARLY_SLOTS	256
 #define PERCPU_DYNAMIC_EARLY_SIZE	(12 << 10)
 
 /*
diff --git a/include/net/inet_timewait_sock.h b/include/net/inet_timewait_sock.h
index 61474ea..6c56603 100644
--- a/include/net/inet_timewait_sock.h
+++ b/include/net/inet_timewait_sock.h
@@ -108,6 +108,7 @@ struct inet_timewait_sock {
 #define tw_family		__tw_common.skc_family
 #define tw_state		__tw_common.skc_state
 #define tw_reuse		__tw_common.skc_reuse
+#define tw_ipv6only		__tw_common.skc_ipv6only
 #define tw_bound_dev_if		__tw_common.skc_bound_dev_if
 #define tw_node			__tw_common.skc_nulls_node
 #define tw_bind_node		__tw_common.skc_bind_node
@@ -131,7 +132,7 @@ struct inet_timewait_sock {
 	__be16			tw_sport;
 	kmemcheck_bitfield_begin(flags);
 	/* And these are ours. */
-	unsigned int		tw_ipv6only     : 1,
+	unsigned int		tw_pad0		: 1,	/* 1 bit hole */
 				tw_transparent  : 1,
 				tw_flowlabel	: 20,
 				tw_pad		: 2,	/* 2 bits hole */
diff --git a/include/net/sock.h b/include/net/sock.h
index 5233aa0..b05a13e 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -181,7 +181,8 @@ struct sock_common {
 	unsigned short		skc_family;
 	volatile unsigned char	skc_state;
 	unsigned char		skc_reuse:4;
-	unsigned char		skc_reuseport:4;
+	unsigned char		skc_reuseport:1;
+	unsigned char		skc_ipv6only:1;
 	int			skc_bound_dev_if;
 	union {
 		struct hlist_node	skc_bind_node;
@@ -316,6 +317,7 @@ struct sock {
 #define sk_state		__sk_common.skc_state
 #define sk_reuse		__sk_common.skc_reuse
 #define sk_reuseport		__sk_common.skc_reuseport
+#define sk_ipv6only		__sk_common.skc_ipv6only
 #define sk_bound_dev_if		__sk_common.skc_bound_dev_if
 #define sk_bind_node		__sk_common.skc_bind_node
 #define sk_prot			__sk_common.skc_prot
diff --git a/kernel/fork.c b/kernel/fork.c
index 9a6397e..d5a5c13 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -176,7 +176,7 @@ static void free_thread_info(struct thread_info *ti)
 void thread_info_cache_init(void)
 {
 	thread_info_cache = kmem_cache_create("thread_info", THREAD_SIZE,
-					      THREAD_SIZE, 0, NULL);
+					      THREAD_SIZE, SLAB_USERCOPY, NULL);
 	BUG_ON(thread_info_cache == NULL);
 }
 # endif
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index ebb8a9e..16769a5e 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -857,7 +857,7 @@ static int irq_thread(void *data)
 
 		action_ret = handler_fn(desc, action);
 		if (action_ret == IRQ_HANDLED)
-			atomic_inc(&desc->threads_handled);
+			atomic_inc_unchecked(&desc->threads_handled);
 
 		wake_threads_waitq(desc);
 	}
diff --git a/kernel/irq/spurious.c b/kernel/irq/spurious.c
index e2514b0..de3dfe0 100644
--- a/kernel/irq/spurious.c
+++ b/kernel/irq/spurious.c
@@ -337,7 +337,7 @@ void note_interrupt(unsigned int irq, struct irq_desc *desc,
 			 * count. We just care about the count being
 			 * different than the one we saw before.
 			 */
-			handled = atomic_read(&desc->threads_handled);
+			handled = atomic_read_unchecked(&desc->threads_handled);
 			handled |= SPURIOUS_DEFERRED;
 			if (handled != desc->threads_handled_last) {
 				action_ret = IRQ_HANDLED;
diff --git a/kernel/range.c b/kernel/range.c
index 322ea8e..82cfc28 100644
--- a/kernel/range.c
+++ b/kernel/range.c
@@ -113,12 +113,12 @@ static int cmp_range(const void *x1, const void *x2)
 {
 	const struct range *r1 = x1;
 	const struct range *r2 = x2;
-	s64 start1, start2;
 
-	start1 = r1->start;
-	start2 = r2->start;
-
-	return start1 - start2;
+	if (r1->start < r2->start)
+		return -1;
+	if (r1->start > r2->start)
+		return 1;
+	return 0;
 }
 
 int clean_sort_range(struct range *range, int az)
diff --git a/mm/memory.c b/mm/memory.c
index 46a54f5..4118c57 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -3403,40 +3403,6 @@ out_release:
 }
 
 /*
- * This is like a special single-page "expand_{down|up}wards()",
- * except we must first make sure that 'address{-|+}PAGE_SIZE'
- * doesn't hit another vma.
- */
-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)
-{
-	address &= PAGE_MASK;
-	if ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {
-		struct vm_area_struct *prev = vma->vm_prev;
-
-		/*
-		 * Is there a mapping abutting this one below?
-		 *
-		 * That's only ok if it's the same stack mapping
-		 * that has gotten split..
-		 */
-		if (prev && prev->vm_end == address)
-			return prev->vm_flags & VM_GROWSDOWN ? 0 : -ENOMEM;
-
-		return expand_downwards(vma, address - PAGE_SIZE);
-	}
-	if ((vma->vm_flags & VM_GROWSUP) && address + PAGE_SIZE == vma->vm_end) {
-		struct vm_area_struct *next = vma->vm_next;
-
-		/* As VM_GROWSDOWN but s/below/above/ */
-		if (next && next->vm_start == address + PAGE_SIZE)
-			return next->vm_flags & VM_GROWSUP ? 0 : -ENOMEM;
-
-		return expand_upwards(vma, address + PAGE_SIZE);
-	}
-	return 0;
-}
-
-/*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
diff --git a/mm/mmap.c b/mm/mmap.c
index 060a533..916b1d4 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2371,8 +2371,6 @@ static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns
 
 	/* Stack limit test */
 	actual_size = size;
-	if (size && (vma->vm_flags & (VM_GROWSUP | VM_GROWSDOWN)))
-		actual_size -= PAGE_SIZE;
 	gr_learn_resource(current, RLIMIT_STACK, actual_size, 1);
 	if (actual_size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))
 		return -ENOMEM;
diff --git a/net/bridge/br.c b/net/bridge/br.c
index 19311aa..339d794 100644
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@ -49,6 +49,8 @@ static int __init br_init(void)
 {
 	int err;
 
+	BUILD_BUG_ON(sizeof(struct br_input_skb_cb) > FIELD_SIZEOF(struct sk_buff, cb));
+
 	err = stp_proto_register(&br_stp_proto);
 	if (err < 0) {
 		pr_err("bridge: can't register sap for STP\n");
diff --git a/net/core/dev.c b/net/core/dev.c
index df67b50..846845c 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -5066,7 +5066,7 @@ void netdev_upper_dev_unlink(struct net_device *dev,
 }
 EXPORT_SYMBOL(netdev_upper_dev_unlink);
 
-void netdev_adjacent_add_links(struct net_device *dev)
+static void netdev_adjacent_add_links(struct net_device *dev)
 {
 	struct netdev_adjacent *iter;
 
@@ -5091,7 +5091,7 @@ void netdev_adjacent_add_links(struct net_device *dev)
 	}
 }
 
-void netdev_adjacent_del_links(struct net_device *dev)
+static void netdev_adjacent_del_links(struct net_device *dev)
 {
 	struct netdev_adjacent *iter;
 
@@ -6392,7 +6392,7 @@ struct netdev_queue *dev_ingress_queue_create(struct net_device *dev)
 	if (!queue)
 		return NULL;
 	netdev_init_one_queue(dev, queue, NULL);
-	queue->qdisc = &noop_qdisc;
+	RCU_INIT_POINTER(queue->qdisc, &noop_qdisc);
 	queue->qdisc_sleeping = &noop_qdisc;
 	rcu_assign_pointer(dev->ingress_queue, queue);
 #endif
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 4ac0a7f..adf3f59 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -2009,6 +2009,10 @@ replay:
 		if (IS_ERR(dest_net))
 			return PTR_ERR(dest_net);
 
+		err = -EPERM;
+		if (!netlink_ns_capable(skb, dest_net->user_ns, CAP_NET_ADMIN))
+			goto out;
+
 		dev = rtnl_create_link(dest_net, ifname, ops, tb);
 		if (IS_ERR(dev)) {
 			err = PTR_ERR(dev);
diff --git a/net/dccp/minisocks.c b/net/dccp/minisocks.c
index 9e2f78b..c18aad6 100644
--- a/net/dccp/minisocks.c
+++ b/net/dccp/minisocks.c
@@ -55,11 +55,9 @@ void dccp_time_wait(struct sock *sk, int state, int timeo)
 		const int rto = (icsk->icsk_rto << 2) - (icsk->icsk_rto >> 1);
 #if IS_ENABLED(CONFIG_IPV6)
 		if (tw->tw_family == PF_INET6) {
-			const struct ipv6_pinfo *np = inet6_sk(sk);
-
 			tw->tw_v6_daddr = sk->sk_v6_daddr;
 			tw->tw_v6_rcv_saddr = sk->sk_v6_rcv_saddr;
-			tw->tw_ipv6only = np->ipv6only;
+			tw->tw_ipv6only = sk->sk_ipv6only;
 		}
 #endif
 		/* Linkage updates. */
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index c797e75..19da1b9 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -261,7 +261,7 @@ int ping_init_sock(struct sock *sk)
 
 #if IS_ENABLED(CONFIG_IPV6)
 	if (sk->sk_family == AF_INET6)
-		inet6_sk(sk)->ipv6only = 1;
+		sk->sk_ipv6only = 1;
 #endif
 	inet_get_ping_group_range_net(net, &low, &high);
 	if (gid_lte(low, group) && gid_lte(group, high))
diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
index 1b05c59..84279ef 100644
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@ -302,7 +302,7 @@ void tcp_time_wait(struct sock *sk, int state, int timeo)
 			tw->tw_v6_rcv_saddr = sk->sk_v6_rcv_saddr;
 			tw->tw_tclass = np->tclass;
 			tw->tw_flowlabel = np->flow_label >> 12;
-			tw->tw_ipv6only = np->ipv6only;
+			tw->tw_ipv6only = sk->sk_ipv6only;
 		}
 #endif
 
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 5aad945..230c2c5 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -4519,6 +4519,21 @@ static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)
 	return 0;
 }
 
+static const struct nla_policy inet6_af_policy[IFLA_INET6_MAX + 1] = {
+	[IFLA_INET6_TOKEN]		= { .len = sizeof(struct in6_addr) },
+};
+
+static int inet6_validate_link_af(const struct net_device *dev,
+				  const struct nlattr *nla)
+{
+	struct nlattr *tb[IFLA_INET6_MAX + 1];
+
+	if (dev && !__in6_dev_get(dev))
+		return -EAFNOSUPPORT;
+
+	return nla_parse_nested(tb, IFLA_INET6_MAX, nla, inet6_af_policy);
+}
+
 static int inet6_set_link_af(struct net_device *dev, const struct nlattr *nla)
 {
 	int err = -EINVAL;
@@ -5303,6 +5318,7 @@ static struct rtnl_af_ops inet6_ops = {
 	.family		  = AF_INET6,
 	.fill_link_af	  = inet6_fill_link_af,
 	.get_link_af_size = inet6_get_link_af_size,
+	.validate_link_af = inet6_validate_link_af,
 	.set_link_af	  = inet6_set_link_af,
 };
 
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 2f64330..d0f3a63 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -200,7 +200,7 @@ lookup_protocol:
 	np->mcast_hops	= IPV6_DEFAULT_MCASTHOPS;
 	np->mc_loop	= 1;
 	np->pmtudisc	= IPV6_PMTUDISC_WANT;
-	np->ipv6only	= net->ipv6.sysctl.bindv6only;
+	sk->sk_ipv6only	= net->ipv6.sysctl.bindv6only;
 
 	/* Init the ipv4 part of the socket since we can have sockets
 	 * using v6 API for ipv4.
@@ -297,7 +297,7 @@ int inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 		/* Binding to v4-mapped address on a v6-only socket
 		 * makes no sense
 		 */
-		if (np->ipv6only) {
+		if (sk->sk_ipv6only) {
 			err = -EINVAL;
 			goto out;
 		}
@@ -374,7 +374,7 @@ int inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 	if (addr_type != IPV6_ADDR_ANY) {
 		sk->sk_userlocks |= SOCK_BINDADDR_LOCK;
 		if (addr_type != IPV6_ADDR_MAPPED)
-			np->ipv6only = 1;
+			sk->sk_ipv6only = 1;
 	}
 	if (snum)
 		sk->sk_userlocks |= SOCK_BINDPORT_LOCK;
diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c
index a1d47b8..42d6ab42 100644
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@ -413,7 +413,7 @@ static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		if (code == ICMPV6_HDR_FIELD)
 			teli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);
 
-		if (teli && teli == info - 2) {
+		if (teli && teli == be32_to_cpu(info) - 2) {
 			tel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];
 			if (tel->encap_limit == 0) {
 				net_warn_ratelimited("%s: Too small encapsulation limit or routing loop in tunnel!\n",
@@ -425,7 +425,7 @@ static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		}
 		break;
 	case ICMPV6_PKT_TOOBIG:
-		mtu = info - offset;
+		mtu = be32_to_cpu(info) - offset;
 		if (mtu < IPV6_MIN_MTU)
 			mtu = IPV6_MIN_MTU;
 		t->dev->mtu = mtu;
diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
index bec42b2..123e322 100644
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -235,7 +235,7 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,
 		if (optlen < sizeof(int) ||
 		    inet_sk(sk)->inet_num)
 			goto e_inval;
-		np->ipv6only = valbool;
+		sk->sk_ipv6only = valbool;
 		retv = 0;
 		break;
 
@@ -1058,7 +1058,7 @@ static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,
 	}
 
 	case IPV6_V6ONLY:
-		val = np->ipv6only;
+		val = sk->sk_ipv6only;
 		break;
 
 	case IPV6_RECVPKTINFO:
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 31a777d..babfcb8 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -83,7 +83,6 @@ extern int grsec_enable_blackhole;
 int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)
 {
 	const struct in6_addr *sk2_rcv_saddr6 = inet6_rcv_saddr(sk2);
-	int sk_ipv6only = ipv6_only_sock(sk);
 	int sk2_ipv6only = inet_v6_ipv6only(sk2);
 	int addr_type = ipv6_addr_type(&sk->sk_v6_rcv_saddr);
 	int addr_type2 = sk2_rcv_saddr6 ? ipv6_addr_type(sk2_rcv_saddr6) : IPV6_ADDR_MAPPED;
@@ -99,7 +98,7 @@ int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)
 		return 1;
 
 	if (addr_type == IPV6_ADDR_ANY &&
-	    !(sk_ipv6only && addr_type2 == IPV6_ADDR_MAPPED))
+	    !(ipv6_only_sock(sk) && addr_type2 == IPV6_ADDR_MAPPED))
 		return 1;
 
 	if (sk2_rcv_saddr6 &&
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index 9e02f78..776fc30 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -134,8 +134,14 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 	u16 offset = sizeof(*hdr);
 	struct ipv6_opt_hdr *exthdr;
 	const unsigned char *nh = skb_network_header(skb);
-	u8 nexthdr = nh[IP6CB(skb)->nhoff];
+	u16 nhoff = IP6CB(skb)->nhoff;
 	int oif = 0;
+	u8 nexthdr;
+
+	if (!nhoff)
+		nhoff = offsetof(struct ipv6hdr, nexthdr);
+
+	nexthdr = nh[nhoff];
 
 	if (skb_dst(skb))
 		oif = skb_dst(skb)->dev->ifindex;
diff --git a/net/llc/sysctl_net_llc.c b/net/llc/sysctl_net_llc.c
index 612a5dd..799bafc 100644
--- a/net/llc/sysctl_net_llc.c
+++ b/net/llc/sysctl_net_llc.c
@@ -18,28 +18,28 @@ static struct ctl_table llc2_timeout_table[] = {
 	{
 		.procname	= "ack",
 		.data		= &sysctl_llc2_ack_timeout,
-		.maxlen		= sizeof(long),
+		.maxlen		= sizeof(sysctl_llc2_ack_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= "busy",
 		.data		= &sysctl_llc2_busy_timeout,
-		.maxlen		= sizeof(long),
+		.maxlen		= sizeof(sysctl_llc2_busy_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= "p",
 		.data		= &sysctl_llc2_p_timeout,
-		.maxlen		= sizeof(long),
+		.maxlen		= sizeof(sysctl_llc2_p_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= "rej",
 		.data		= &sysctl_llc2_rej_timeout,
-		.maxlen		= sizeof(long),
+		.maxlen		= sizeof(sysctl_llc2_rej_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 8d52d50..3bed3f0 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -789,9 +789,11 @@ nf_tables_counters(struct nft_base_chain *chain, const struct nlattr *attr)
 	/* Restore old counters on this cpu, no problem. Per-cpu statistics
 	 * are not exposed to userspace.
 	 */
+	preempt_disable();
 	stats = this_cpu_ptr(newstats);
 	stats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));
 	stats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));
+	preempt_enable();
 
 	if (chain->stats) {
 		/* nfnl_lock is held, add some nfnl function for this, later */
diff --git a/net/rds/sysctl.c b/net/rds/sysctl.c
index b5cb2aa..35773ad 100644
--- a/net/rds/sysctl.c
+++ b/net/rds/sysctl.c
@@ -71,14 +71,14 @@ static struct ctl_table rds_sysctl_rds_table[] = {
 	{
 		.procname	= "max_unacked_packets",
 		.data		= &rds_sysctl_max_unacked_packets,
-		.maxlen         = sizeof(unsigned long),
+		.maxlen         = sizeof(int),
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
 	{
 		.procname	= "max_unacked_bytes",
 		.data		= &rds_sysctl_max_unacked_bytes,
-		.maxlen         = sizeof(unsigned long),
+		.maxlen         = sizeof(int),
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index bdbdb1a..1afc85f 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -555,8 +555,9 @@ void tcf_exts_change(struct tcf_proto *tp, struct tcf_exts *dst,
 }
 EXPORT_SYMBOL(tcf_exts_change);
 
-#define tcf_exts_first_act(ext) \
-		list_first_entry(&(exts)->actions, struct tc_action, list)
+#define tcf_exts_first_act(ext)					\
+	list_first_entry_or_null(&(exts)->actions,		\
+				 struct tc_action, list)
 
 int tcf_exts_dump(struct sk_buff *skb, struct tcf_exts *exts)
 {
@@ -597,7 +598,7 @@ int tcf_exts_dump_stats(struct sk_buff *skb, struct tcf_exts *exts)
 {
 #ifdef CONFIG_NET_CLS_ACT
 	struct tc_action *a = tcf_exts_first_act(exts);
-	if (tcf_action_copy_stats(skb, a, 1) < 0)
+	if (a != NULL && tcf_action_copy_stats(skb, a, 1) < 0)
 		return -1;
 #endif
 	return 0;
diff --git a/net/sched/cls_bpf.c b/net/sched/cls_bpf.c
index 8e3cf49..4a8e322 100644
--- a/net/sched/cls_bpf.c
+++ b/net/sched/cls_bpf.c
@@ -182,6 +182,11 @@ static int cls_bpf_modify_existing(struct net *net, struct tcf_proto *tp,
 	}
 
 	bpf_size = bpf_len * sizeof(*bpf_ops);
+	if (bpf_size != nla_len(tb[TCA_BPF_OPS])) {
+		ret = -EINVAL;
+		goto errout;
+	}
+
 	bpf_ops = kzalloc(bpf_size, GFP_KERNEL);
 	if (bpf_ops == NULL) {
 		ret = -ENOMEM;
@@ -228,15 +233,21 @@ static u32 cls_bpf_grab_new_handle(struct tcf_proto *tp,
 				   struct cls_bpf_head *head)
 {
 	unsigned int i = 0x80000000;
+	u32 handle;
 
 	do {
 		if (++head->hgen == 0x7FFFFFFF)
 			head->hgen = 1;
 	} while (--i > 0 && cls_bpf_get(tp, head->hgen));
-	if (i == 0)
+
+	if (unlikely(i == 0)) {
 		pr_err("Insufficient number of handles\n");
+		handle = 0;
+	} else {
+		handle = head->hgen;
+	}
 
-	return i;
+	return handle;
 }
 
 static int cls_bpf_change(struct net *net, struct sk_buff *in_skb,
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index f87f0a3..990354d 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -1605,6 +1605,7 @@ static int sctp_sendmsg(struct kiocb *iocb, struct sock *sk,
 	sctp_scope_t scope;
 	long timeo;
 	__u16 sinfo_flags = 0;
+	bool wait_connect = false;
 	struct sctp_datamsg *datamsg;
 	int msg_flags = msg->msg_flags;
 
@@ -1924,6 +1925,7 @@ static int sctp_sendmsg(struct kiocb *iocb, struct sock *sk,
 		if (err < 0)
 			goto out_free;
 
+		wait_connect = true;
 		pr_debug("%s: we associated primitively\n", __func__);
 	}
 
@@ -1961,6 +1963,11 @@ static int sctp_sendmsg(struct kiocb *iocb, struct sock *sk,
 	sctp_datamsg_put(datamsg);
 	err = msg_len;
 
+	if (unlikely(wait_connect)) {
+		timeo = sock_sndtimeo(sk, msg_flags & MSG_DONTWAIT);
+		sctp_wait_for_connect(asoc, &timeo);
+	}
+
 	/* If we are already past ASSOCIATE, the lower
 	 * layers are responsible for association cleanup.
 	 */
diff --git a/scripts/Kbuild.include b/scripts/Kbuild.include
index 547e15d..e550fa6 100644
--- a/scripts/Kbuild.include
+++ b/scripts/Kbuild.include
@@ -143,7 +143,7 @@ cc-ifversion = $(shell [ $(call cc-version, $(CC)) $(1) $(2) ] && echo $(3))
 # cc-ldoption
 # Usage: ldflags += $(call cc-ldoption, -Wl$(comma)--hash-style=both)
 cc-ldoption = $(call try-run,\
-	$(CC) $(1) -nostdlib -x c /dev/null -o "$$TMP",$(1),$(2))
+	$(CC) $(1) -Wl,-r -nostdlib -x c /dev/null -o "$$TMP",$(1),$(2))
 
 # ld-option
 # Usage: LDFLAGS += $(call ld-option, -X)
diff --git a/scripts/gcc-plugin.sh b/scripts/gcc-plugin.sh
index 42018ed..822fa9e 100644
--- a/scripts/gcc-plugin.sh
+++ b/scripts/gcc-plugin.sh
@@ -1,7 +1,7 @@
 #!/bin/sh
 srctree=$(dirname "$0")
 gccplugins_dir=$($3 -print-file-name=plugin)
-plugincc=$($1 -E - -o /dev/null -I${srctree}/../tools/gcc -I${gccplugins_dir}/include 2>&1 <<EOF
+plugincc=$($1 -E - -o /dev/null -I"${srctree}"/../tools/gcc -I"${gccplugins_dir}"/include 2>&1 <<EOF
 #include "gcc-common.h"
 #if BUILDING_GCC_VERSION >= 4008 || defined(ENABLE_BUILD_WITH_CXX)
 #warning $2 CXX
@@ -32,7 +32,7 @@ case "$plugincc" in
 esac
 
 # we need a c++ compiler that supports the designated initializer GNU extension
-plugincc=$($2 -c -x c++ -std=gnu++98 - -fsyntax-only -I${srctree}/../tools/gcc -I${gccplugins_dir}/include 2>&1 <<EOF
+plugincc=$($2 -c -x c++ -std=gnu++98 - -fsyntax-only -I"${srctree}"/../tools/gcc -I"${gccplugins_dir}"/include 2>&1 <<EOF
 #include "gcc-common.h"
 class test {
 public:
diff --git a/security/keys/request_key.c b/security/keys/request_key.c
index 3814119..2e8ebaa 100644
--- a/security/keys/request_key.c
+++ b/security/keys/request_key.c
@@ -432,6 +432,7 @@ link_check_failed:
 
 link_prealloc_failed:
 	mutex_unlock(&user->cons_lock);
+	key_put(key);
 	kleave(" = %d [prelink]", ret);
 	return ret;
 
diff --git a/tools/gcc/constify_plugin.c b/tools/gcc/constify_plugin.c
index 82bc5a8..3b5af59 100644
--- a/tools/gcc/constify_plugin.c
+++ b/tools/gcc/constify_plugin.c
@@ -431,7 +431,8 @@ static struct gimple_opt_pass check_local_variables_pass = {
 #if BUILDING_GCC_VERSION >= 4008
 		.optinfo_flags		= OPTGROUP_NONE,
 #endif
-#if BUILDING_GCC_VERSION >= 4009
+#if BUILDING_GCC_VERSION >= 5000
+#elif BUILDING_GCC_VERSION >= 4009
 		.has_gate		= false,
 		.has_execute		= true,
 #else
@@ -539,8 +540,8 @@ int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version
 		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
 	}
 
-	if (strcmp(lang_hooks.name, "GNU C")) {
-		inform(UNKNOWN_LOCATION, G_("%s supports C only"), plugin_name);
+	if (strncmp(lang_hooks.name, "GNU C", 5) && !strncmp(lang_hooks.name, "GNU C+", 6)) {
+		inform(UNKNOWN_LOCATION, G_("%s supports C only, not %s"), plugin_name, lang_hooks.name);
 		constify = false;
 	}
 
diff --git a/tools/gcc/gcc-common.h b/tools/gcc/gcc-common.h
index e90c205..de1d984 100644
--- a/tools/gcc/gcc-common.h
+++ b/tools/gcc/gcc-common.h
@@ -34,7 +34,13 @@
 #include "timevar.h"
 
 #include "params.h"
+
+#if BUILDING_GCC_VERSION <= 4009
 #include "pointer-set.h"
+#else
+#include "hash-map.h"
+#endif
+
 #include "emit-rtl.h"
 //#include "reload.h"
 //#include "ira.h"
@@ -49,11 +55,21 @@
 //#include "coverage.h"
 //#include "value-prof.h"
 
+#if BUILDING_GCC_VERSION == 4005
+#include <sys/mman.h>
+#endif
+
 #if BUILDING_GCC_VERSION >= 4007
 #include "tree-pretty-print.h"
 #include "gimple-pretty-print.h"
-#include "c-tree.h"
-//#include "alloc-pool.h"
+#endif
+
+#if BUILDING_GCC_VERSION >= 4006
+//#include "c-tree.h"
+//#include "cp/cp-tree.h"
+#include "c-family/c-common.h"
+#else
+#include "c-common.h"
 #endif
 
 #if BUILDING_GCC_VERSION <= 4008
@@ -75,6 +91,7 @@
 #include "stor-layout.h"
 #include "internal-fn.h"
 #include "gimple-expr.h"
+#include "gimple-fold.h"
 //#include "diagnostic-color.h"
 #include "context.h"
 #include "tree-ssa-alias.h"
@@ -97,7 +114,11 @@
 #endif
 
 //#include "lto/lto.h"
+#if BUILDING_GCC_VERSION >= 4007
 //#include "data-streamer.h"
+#else
+//#include "lto-streamer.h"
+#endif
 //#include "lto-compress.h"
 
 //#include "expr.h" where are you...
@@ -107,6 +128,15 @@ extern rtx emit_move_insn(rtx x, rtx y);
 extern void debug_dominance_info(enum cdi_direction dir);
 extern void debug_dominance_tree(enum cdi_direction dir, basic_block root);
 
+#ifdef __cplusplus
+static inline void debug_tree(const_tree t)
+{
+	debug_tree(CONST_CAST_TREE(t));
+}
+#else
+#define debug_tree(t) debug_tree(CONST_CAST_TREE(t))
+#endif
+
 #define __unused __attribute__((__unused__))
 
 #define DECL_NAME_POINTER(node) IDENTIFIER_POINTER(DECL_NAME(node))
@@ -114,12 +144,20 @@ extern void debug_dominance_tree(enum cdi_direction dir, basic_block root);
 #define TYPE_NAME_POINTER(node) IDENTIFIER_POINTER(TYPE_NAME(node))
 #define TYPE_NAME_LENGTH(node) IDENTIFIER_LENGTH(TYPE_NAME(node))
 
+// should come from c-tree.h if only it were installed for gcc 4.5...
+#define C_TYPE_FIELDS_READONLY(TYPE) TREE_LANG_FLAG_1(TYPE)
+
 #if BUILDING_GCC_VERSION == 4005
-#define FOR_EACH_LOCAL_DECL(FUN, I, D) for (tree vars = (FUN)->local_decls; vars && (D = TREE_VALUE(vars)); vars = TREE_CHAIN(vars), I)
+#define FOR_EACH_VEC_ELT_REVERSE(T,V,I,P) for (I = VEC_length(T, (V)) - 1; VEC_iterate(T, (V), (I), (P)); (I)--)
+#define FOR_EACH_LOCAL_DECL(FUN, I, D) FOR_EACH_VEC_ELT_REVERSE(tree, (FUN)->local_decls, I, D)
 #define DECL_CHAIN(NODE) (TREE_CHAIN(DECL_MINIMAL_CHECK(NODE)))
 #define FOR_EACH_VEC_ELT(T, V, I, P) for (I = 0; VEC_iterate(T, (V), (I), (P)); ++(I))
 #define TODO_rebuild_cgraph_edges 0
 
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+
 static inline bool gimple_call_builtin_p(gimple stmt, enum built_in_function code)
 {
 	tree fndecl;
@@ -169,25 +207,45 @@ static inline bool is_simple_builtin(tree decl)
 #if BUILDING_GCC_VERSION <= 4006
 #define ANY_RETURN_P(rtx) (GET_CODE(rtx) == RETURN)
 #define C_DECL_REGISTER(EXP) DECL_LANG_FLAG_4(EXP)
-
-// should come from c-tree.h if only it were installed for gcc 4.5...
-#define C_TYPE_FIELDS_READONLY(TYPE) TREE_LANG_FLAG_1(TYPE)
+#define EDGE_PRESERVE 0ULL
+#define HOST_WIDE_INT_PRINT_HEX_PURE "%" HOST_WIDE_INT_PRINT "x"
+#define flag_fat_lto_objects true
 
 #define get_random_seed(noinit) ({						\
 	unsigned HOST_WIDE_INT seed;						\
 	sscanf(get_random_seed(noinit), "%" HOST_WIDE_INT_PRINT "x", &seed);	\
 	seed * seed; })
 
+#define int_const_binop(code, arg1, arg2) int_const_binop((code), (arg1), (arg2), 0)
+
 static inline bool gimple_clobber_p(gimple s)
 {
 	return false;
 }
 
+static inline bool gimple_asm_clobbers_memory_p(const_gimple stmt)
+{
+	unsigned i;
+
+	for (i = 0; i < gimple_asm_nclobbers(stmt); i++) {
+		tree op = gimple_asm_clobber_op(stmt, i);
+		if (!strcmp(TREE_STRING_POINTER(TREE_VALUE(op)), "memory"))
+			return true;
+	}
+
+	return false;
+}
+
 static inline tree builtin_decl_implicit(enum built_in_function fncode)
 {
 	return implicit_built_in_decls[fncode];
 }
 
+static inline int ipa_reverse_postorder(struct cgraph_node **order)
+{
+	return cgraph_postorder(order);
+}
+
 static inline struct cgraph_node *cgraph_get_create_node(tree decl)
 {
 	struct cgraph_node *node = cgraph_get_node(decl);
@@ -233,8 +291,11 @@ extern void dump_gimple_stmt(pretty_printer *, gimple, int, int);
 #endif
 
 #if BUILDING_GCC_VERSION <= 4007
+#define FOR_EACH_FUNCTION(node) for (node = cgraph_nodes; node; node = node->next)
 #define FOR_EACH_VARIABLE(node) for (node = varpool_nodes; node; node = node->next)
 #define PROP_loops 0
+#define NODE_SYMBOL(node) (node)
+#define NODE_DECL(node) (node)->decl
 
 static inline int bb_loop_depth(const_basic_block bb)
 {
@@ -264,6 +325,8 @@ static inline bool gimple_store_p(gimple gs)
 #define last_basic_block_for_fn(FN)	((FN)->cfg->x_last_basic_block)
 #define label_to_block_map_for_fn(FN)	((FN)->cfg->x_label_to_block_map)
 #define profile_status_for_fn(FN)	((FN)->cfg->x_profile_status)
+#define BASIC_BLOCK_FOR_FN(FN, N)	BASIC_BLOCK_FOR_FUNCTION((FN), (N))
+#define NODE_IMPLICIT_ALIAS(node)	(node)->same_body_alias
 
 static inline const char *get_tree_code_name(enum tree_code code)
 {
@@ -275,9 +338,8 @@ static inline const char *get_tree_code_name(enum tree_code code)
 #endif
 
 #if BUILDING_GCC_VERSION == 4008
-#define NODE_DECL(node) node->symbol.decl
-#else
-#define NODE_DECL(node) node->decl
+#define NODE_SYMBOL(node) (&(node)->symbol)
+#define NODE_DECL(node) (node)->symbol.decl
 #endif
 
 #if BUILDING_GCC_VERSION >= 4008
@@ -288,8 +350,26 @@ static inline const char *get_tree_code_name(enum tree_code code)
 #define TODO_dump_cgraph 0
 #endif
 
+#if BUILDING_GCC_VERSION <= 4009
+#define TODO_verify_il 0
+#endif
+
 #if BUILDING_GCC_VERSION >= 4009
 #define TODO_ggc_collect 0
+#define NODE_SYMBOL(node) (node)
+#define NODE_DECL(node) (node)->decl
+#define cgraph_node_name(node) (node)->name()
+#define NODE_IMPLICIT_ALIAS(node) (node)->cpp_implicit_alias
+#endif
+
+#if BUILDING_GCC_VERSION >= 5000
+#define TODO_verify_ssa TODO_verify_il
+#define TODO_verify_flow TODO_verify_il
+#define TODO_verify_stmts TODO_verify_il
+#define TODO_verify_rtl_sharing TODO_verify_il
+
+#define debug_cgraph_node(node) (node)->debug()
+#define cgraph_get_node(decl) cgraph_node::get(decl)
 #endif
 
 #endif
diff --git a/tools/gcc/size_overflow_plugin/size_overflow_hash.data b/tools/gcc/size_overflow_plugin/size_overflow_hash.data
index 19cb000..3d3508d 100644
--- a/tools/gcc/size_overflow_plugin/size_overflow_hash.data
+++ b/tools/gcc/size_overflow_plugin/size_overflow_hash.data
@@ -912,6 +912,7 @@ rx_out_of_mem_read_10157 rx_out_of_mem_read 3 10157 NULL
 hidg_alloc_ep_req_10159 hidg_alloc_ep_req 2 10159 NULL
 asd_store_update_bios_10165 asd_store_update_bios 4 10165 NULL
 kstrtol_from_user_10168 kstrtol_from_user 2 10168 NULL
+persistent_ram_vmap_10169 persistent_ram_vmap 2-1 10169 NULL
 proc_pid_attr_read_10173 proc_pid_attr_read 3 10173 NULL
 jffs2_user_setxattr_10182 jffs2_user_setxattr 4 10182 NULL
 xfs_attr_rmtval_copyout_10222 xfs_attr_rmtval_copyout 0 10222 NULL nohasharray
@@ -966,6 +967,7 @@ vhost_add_used_n_10760 vhost_add_used_n 3 10760 NULL
 rd_build_prot_space_10761 rd_build_prot_space 2-3 10761 NULL
 kvm_read_guest_atomic_10765 kvm_read_guest_atomic 4 10765 NULL
 __qp_memcpy_to_queue_10779 __qp_memcpy_to_queue 2-4 10779 NULL
+ttm_dma_page_pool_free_10796 ttm_dma_page_pool_free 2-0 10796 NULL
 diva_set_trace_filter_10820 diva_set_trace_filter 0-1 10820 NULL
 lbs_sleepparams_read_10840 lbs_sleepparams_read 3 10840 NULL
 ida_get_new_above_10853 ida_get_new_above 0 10853 NULL
@@ -2077,6 +2079,7 @@ ext4_ext_direct_IO_22679 ext4_ext_direct_IO 4 22679 NULL
 l2tp_ip_recvmsg_22681 l2tp_ip_recvmsg 4 22681 NULL
 bch_dump_read_22685 bch_dump_read 3 22685 NULL
 reg_umr_22686 reg_umr 5 22686 NULL
+nr_cpusets_22705 nr_cpusets 0 22705 NULL
 alloc_libipw_22708 alloc_libipw 1 22708 NULL
 cx18_copy_buf_to_user_22735 cx18_copy_buf_to_user 4-0 22735 NULL
 ceph_decode_32_22738 ceph_decode_32 0 22738 NULL nohasharray
@@ -2273,6 +2276,7 @@ rtw_set_wps_assoc_resp_24440 rtw_set_wps_assoc_resp 3 24440 &smk_user_access_244
 evdev_do_ioctl_24459 evdev_do_ioctl 2 24459 NULL
 lbs_highsnr_write_24460 lbs_highsnr_write 3 24460 NULL
 skb_copy_and_csum_datagram_iovec_24466 skb_copy_and_csum_datagram_iovec 2 24466 NULL
+ttm_page_pool_free_24486 ttm_page_pool_free 2-0 24486 NULL
 dut_mode_read_24489 dut_mode_read 3 24489 NULL
 read_file_spec_scan_ctl_24491 read_file_spec_scan_ctl 3 24491 NULL
 pd_video_read_24510 pd_video_read 3 24510 NULL
@@ -2729,6 +2733,7 @@ probes_write_29711 probes_write 3 29711 NULL
 read_cis_cache_29735 read_cis_cache 4 29735 NULL
 xfs_new_eof_29737 xfs_new_eof 2 29737 NULL
 std_nic_write_29752 std_nic_write 3 29752 NULL
+static_key_count_29771 static_key_count 0 29771 NULL
 dbAlloc_29794 dbAlloc 0 29794 NULL
 tcp_sendpage_29829 tcp_sendpage 4 29829 NULL
 __probe_kernel_write_29842 __probe_kernel_write 3 29842 NULL
@@ -3658,6 +3663,7 @@ do_surface_dirty_sou_39678 do_surface_dirty_sou 7 39678 NULL
 sd_completed_bytes_39705 sd_completed_bytes 0 39705 NULL
 ftrace_pid_write_39710 ftrace_pid_write 3 39710 NULL
 adt7316_spi_multi_read_39765 adt7316_spi_multi_read 3 39765 NULL
+persistent_ram_buffer_map_39776 persistent_ram_buffer_map 1-2 39776 NULL
 security_inode_listsecurity_39812 security_inode_listsecurity 0 39812 NULL
 snd_pcm_oss_writev3_39818 snd_pcm_oss_writev3 3 39818 NULL
 get_priv_size_39828 get_priv_size 0-1 39828 NULL
@@ -5771,6 +5777,7 @@ rx_rx_timeout_read_62389 rx_rx_timeout_read 3 62389 NULL
 altera_irscan_62396 altera_irscan 2 62396 NULL
 set_ssp_62411 set_ssp 4 62411 NULL
 udf_expand_file_adinicb_62470 udf_expand_file_adinicb 0 62470 NULL
+persistent_ram_new_62493 persistent_ram_new 1-2 62493 NULL
 ext_rts51x_sd_execute_read_data_62501 ext_rts51x_sd_execute_read_data 9 62501 NULL
 pep_sendmsg_62524 pep_sendmsg 4 62524 NULL
 test_iso_queue_62534 test_iso_queue 5 62534 NULL
-- 
1.9.1

