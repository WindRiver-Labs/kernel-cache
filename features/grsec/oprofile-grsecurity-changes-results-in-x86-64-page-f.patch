From 0cf27dccfb39021c238e6c4ce693f354945560e9 Mon Sep 17 00:00:00 2001
From: Amy Fong <Amy.Fong@windriver.com>
Date: Mon, 11 Feb 2013 11:18:03 -0500
Subject: [PATCH] oprofile: grsecurity changes results in x86-64 page fault

If profiling starts, shortly thereafter, we see an oops/page fault
in print_context_stack, or more specifically, at the line:

    while ( .... test to see if stack address is valid ...) {
         addr = *stack;
         stack++
    }

We appear to be walking out of range.

This patch modifies the start of the stack as follows:

    stack_start = (void *)((unsigned long)stack & ~(THREAD_SIZE-1));
to
    stack_start = (void *)current_thread_info();

The grsecurity, or more specifically the pax patches do the following:

"in particular we moved the thread info structure off the kernel stack
and into task struct (it's a long story, it was basically in response
to a particular kernel exploitation technique presented at HES'11 and
INFILTRATE'11 by Jon Oberheide and Dan Rosenberg, [1]).

<snip>

... depending on the circumstances
you can calculate the base address of the stack as you did above or use
the task_stack_page macro (which is the portable way across archs in linux
but it needs a struct task pointer)."

Signed-off-by: Amy Fong <Amy.Fong@windriver.com>
---
 arch/x86/kernel/dumpstack_64.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/x86/kernel/dumpstack_64.c b/arch/x86/kernel/dumpstack_64.c
index 9623722..536ff3d 100644
--- a/arch/x86/kernel/dumpstack_64.c
+++ b/arch/x86/kernel/dumpstack_64.c
@@ -193,7 +193,7 @@ void dump_trace(struct task_struct *task, struct pt_regs *regs,
 	/*
 	 * This handles the process stack:
 	 */
-	stack_start = (void *)((unsigned long)stack & ~(THREAD_SIZE-1));
+	stack_start = (void *)current_thread_info();
 	bp = ops->walk_stack(task, stack_start, stack, bp, ops, data, NULL, &graph);
 out:
 	put_cpu();
-- 
1.7.9.7

