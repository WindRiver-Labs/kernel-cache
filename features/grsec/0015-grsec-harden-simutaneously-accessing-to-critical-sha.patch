From 6eae7ceedf221d78cb2775987496ff309ba65c03 Mon Sep 17 00:00:00 2001
From: Han Chao <chan@windriver.com>
Date: Mon, 17 Mar 2014 17:05:52 +0800
Subject: [PATCH 15/16] grsec: harden simutaneously accessing to critical
 shared variables

GRsecurity added two critical variables in processes' tcb as:
: @@ -1594,6 +1621,27 @@ struct task_struct {
:         unsigned long default_timer_slack_ns;
: +       struct acl_subject_label *acl;
: +       struct acl_role_label *role;
: ...

Unfortunately, those 2 variable both are frequently written and read by
syscalls and interrupt ISR everywhere simutaneously without well access
control, for example:

3093 ssize_t
3094 write_grsec_handler(struct file *file, const char * buf, size_t count, loff_t *ppos)
3174     case GR_SHUTDOWN:
3175         if ((gr_status & GR_READY)
3181             gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SHUTS_ACL_MSG);
3182             free_variables();

 954 free_variables(void)
 963     read_lock(&tasklist_lock);
 964     do_each_thread(task2, task) {
 965         task->acl_sp_role = 0;
 966         task->acl_role_id = 0;
 967         task->acl = NULL;
 968         task->role = NULL;
 969     } while_each_thread(task2, task);

and

2050 gr_search_file(const struct dentry * dentry, const __u32 mode,
2051            const struct vfsmount * mnt)
2057     if (unlikely(!(gr_status & GR_READY)))
2058         return (mode & ~GR_AUDITS);
2059
2060     curracl = current->acl;

There is good chance that 'current->acl' becomes NULL when above interrupted
by free_variables()'s 'task->acl = NULL;' statement, as a result, it causes
system crash as:

[  164.729304] BUG: unable to handle kernel NULL pointer dereference at 00000190
[  164.729388] IP: [<0031a6b0>] __full_lookup+0x30/0xd0
[  164.729447] *pdpt = 000000003501b001 *pde = 0000000000000000
[  164.729495] Oops: 0000 [#1] PREEMPT SMP
[  164.729538] LTT NESTING LEVEL : 0
[  164.729880]
[  164.729911] Pid: 4593, comm: multiwan Not tainted 3.4.43-grsec-WR5.0.1.0_standard #6 N/A N/A/nanoETXexpress-TT
[  164.729973] EIP: 0060:[<0031a6b0>] EFLAGS: 00010217 CPU: 1
[  164.730009] EIP is at __full_lookup+0x30/0xd0
[  164.730038] EAX: c2051024 EBX: 00000000 ECX: 00000000 EDX: 00000002
[  164.730069] ESI: 00800001 EDI: 000068df EBP: f5071be8 ESP: f5071bd0
[  164.730101]  DS: 0068 ES: 0068 FS: 00d8 GS: 0033 SS: 0068
[  164.730131] CR0: 80050033 CR2: 00000190 CR3: 01c05020 CR4: 000007f0
[  164.730159] DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000
[  164.730185] DR6: ffff0ff0 DR7: 00000400
[  164.730214] Process multiwan (pid: 4593, ti=f5fcb688 task=f5fcb300 task.ti=f5fcb688)
[  164.730239] Stack:
[  164.730258]  f6cdb6d0 f6cdb6d0 c243c880 c243c780 c243c880 00800001 f5071c30 0031a85d
[  164.730344]  00800001 00000000 f5071c38 00000000 c243c8cc 017472db f6cdb6c0 f6cdb6d0
[  164.730420]  c243c880 00000000 000068df 00000000 f6cdb6d0 00000000 c243c880 f5fcb300
[  164.730493] Call Trace:
[  164.730534]  [<00800001>] ? 0x800000
[  164.730568]  [<0031a85d>] __chk_obj_label+0x10d/0x3a0
[  164.730600]  [<00800001>] ? 0x800000
[  164.730635]  [<000068df>] ? show_trace+0x1f/0x30
[  164.730669]  [<0031d4e0>] gr_search_file+0x50/0x160
[  164.730705]  [<00404010>] ? i915_read_indexed+0x40/0x40
[  164.730739]  [<00321138>] gr_acl_handle_open+0x48/0x170
[  166.407383]  [<0012556d>] do_last.isra.30+0x2cd/0x8e0
[  166.407470]  [<00125c1f>] path_openat+0x9f/0x3c0
[  166.407553]  [<00126142>] do_filp_open+0x32/0x80
[  166.407872]  [<0011588a>] do_sys_open+0xfa/0x2b0

This commit just make situation sort of better, to make system strong enough
to survive endurance such as:

$ while :; do
	gradm -E >/dev/null 2>&1;
	sleep 1;
	echo windriver|gradm -D;
done

However this is just the best workaround available we have so far at this moment.

Signed-off-by: Yang, Xiao <xiao.yang@windriver.com> 
Signed-off-by: Han Chao <chan@windriver.com>
---
 fs/binfmt_elf.c         |    3 +++
 fs/compat.c             |    7 +++++-
 fs/exec.c               |    3 +++
 grsecurity/gracl.c      |   58 ++++++++++++++++++++++++++++++++++++++++++-----
 grsecurity/gracl_cap.c  |    3 +++
 grsecurity/gracl_fs.c   |    8 +++++++
 grsecurity/gracl_ip.c   |    2 ++
 grsecurity/gracl_segv.c |    6 +++--
 include/linux/gracl.h   |    1 +
 kernel/cred.c           |    3 +++
 mm/mmap.c               |    9 ++++++--
 11 files changed, 92 insertions(+), 11 deletions(-)

diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index b3f05e9..4c28b0b 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -41,6 +41,7 @@
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
+#include <linux/gracl.h>
 
 #ifndef user_long_t
 #define user_long_t long
@@ -1099,8 +1100,10 @@ static int load_elf_binary(struct linux_binprm *bprm)
 #ifdef CONFIG_PAX_HAVE_ACL_FLAGS
 	pax_set_initial_flags(bprm);
 #elif defined(CONFIG_PAX_HOOK_ACL_FLAGS)
+	read_lock(&grsec_tcb_lock);
 	if (pax_set_initial_flags_func)
 		(pax_set_initial_flags_func)(bprm);
+	read_unlock(&grsec_tcb_lock);
 #endif
 
 #ifdef CONFIG_ARCH_TRACK_EXEC_LIMIT
diff --git a/fs/compat.c b/fs/compat.c
index 7b568ae..40eb043 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -46,6 +46,7 @@
 #include <linux/mm.h>
 #include <linux/fs_struct.h>
 #include <linux/slab.h>
+#include <linux/gracl.h>
 #include <linux/pagemap.h>
 #include <linux/aio.h>
 
@@ -852,8 +853,12 @@ static int compat_fillonedir(void *__buf, const char *name, int namlen,
 		return -EOVERFLOW;
 	}
 
-	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino))
+	read_lock(&grsec_tcb_lock);
+	if (!gr_acl_handle_filldir(buf->file, name, namlen, ino)) {
+		read_unlock(&grsec_tcb_lock);
 		return 0;
+	}
+	read_unlock(&grsec_tcb_lock);
 
 	buf->result++;
 	dirent = buf->dirent;
diff --git a/fs/exec.c b/fs/exec.c
index c875ac4..efd4867 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -77,6 +77,7 @@
 #include "coredump.h"
 
 #include <trace/events/sched.h>
+#include <linux/gracl.h>
 
 #ifdef CONFIG_PAX_HAVE_ACL_FLAGS
 void __weak pax_set_initial_flags(struct linux_binprm *bprm)
@@ -1678,8 +1679,10 @@ static int do_execve_common(const char *filename,
 		goto out_fail;
 	}
 
+    read_lock(&grsec_tcb_lock);
 	retval = gr_set_proc_label(file->f_path.dentry, file->f_path.mnt,
 					bprm->unsafe);
+    read_unlock(&grsec_tcb_lock);
 	if (retval < 0)
 		goto out_fail;
 
diff --git a/grsecurity/gracl.c b/grsecurity/gracl.c
index 27f30d9..b208353 100644
--- a/grsecurity/gracl.c
+++ b/grsecurity/gracl.c
@@ -62,6 +62,7 @@ static u16 acl_sp_role_value;
 extern char *gr_shared_page[4];
 static DEFINE_MUTEX(gr_dev_mutex);
 DEFINE_RWLOCK(gr_inode_lock);
+DEFINE_RWLOCK(grsec_tcb_lock);
 
 struct gr_arg *gr_usermode;
 
@@ -630,9 +631,13 @@ struct acl_subject_label *
 lookup_acl_subj_label(const ino_t ino, const dev_t dev,
 		      const struct acl_role_label *role)
 {
-	unsigned int index = gr_fhash(ino, dev, role->subj_hash_size);
+	unsigned int index;
 	struct acl_subject_label *match;
 
+	if (unlikely(!role))
+		return NULL;
+
+	index = gr_fhash(ino, dev, role->subj_hash_size);
 	match = role->subj_hash[index];
 
 	while (match && (match->inode != ino || match->device != dev ||
@@ -1100,6 +1105,7 @@ free_variables(void)
 
 	gr_clear_learn_entries();
 
+	write_lock(&grsec_tcb_lock);
 	read_lock(&tasklist_lock);
 	do_each_thread(task2, task) {
 		task->acl_sp_role = 0;
@@ -1108,6 +1114,7 @@ free_variables(void)
 		task->role = NULL;
 	} while_each_thread(task2, task);
 	read_unlock(&tasklist_lock);
+	write_unlock(&grsec_tcb_lock);
 
 	/* release the reference to the real root dentry and vfsmount */
 	path_put(&real_root);
@@ -1890,6 +1897,10 @@ __full_lookup(const struct dentry *orig_dentry, const struct vfsmount *orig_mnt,
 	struct acl_object_label *retval2;
 
 	tmpsubj = (struct acl_subject_label *) subj;
+	if (unlikely (!tmpsubj)) {
+		return NULL;
+	}
+
 	read_lock(&gr_inode_lock);
 	do {
 		retval = lookup_acl_obj_label(curr_ino, curr_dev, tmpsubj);
@@ -2055,6 +2066,7 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 			if (!mnt_has_parent(real_mnt))
 				break;
 
+			read_lock(&grsec_tcb_lock);
 			spin_lock(&dentry->d_lock);
 			read_lock(&gr_inode_lock);
 			retval =
@@ -2062,6 +2074,7 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 						__get_dev(dentry), role);
 			read_unlock(&gr_inode_lock);
 			spin_unlock(&dentry->d_lock);
+			read_unlock(&grsec_tcb_lock);
 			if (retval != NULL)
 				goto out;
 
@@ -2071,6 +2084,7 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 			continue;
 		}
 
+		read_lock(&grsec_tcb_lock);
 		spin_lock(&dentry->d_lock);
 		read_lock(&gr_inode_lock);
 		retval = lookup_acl_subj_label(dentry->d_inode->i_ino,
@@ -2078,6 +2092,7 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 		read_unlock(&gr_inode_lock);
 		parent = dentry->d_parent;
 		spin_unlock(&dentry->d_lock);
+		read_unlock(&grsec_tcb_lock);
 
 		if (retval != NULL)
 			goto out;
@@ -2085,19 +2100,23 @@ chk_subj_label(const struct dentry *l_dentry, const struct vfsmount *l_mnt,
 		dentry = parent;
 	}
 
+	read_lock(&grsec_tcb_lock);
 	spin_lock(&dentry->d_lock);
 	read_lock(&gr_inode_lock);
 	retval = lookup_acl_subj_label(dentry->d_inode->i_ino,
 				  __get_dev(dentry), role);
 	read_unlock(&gr_inode_lock);
 	spin_unlock(&dentry->d_lock);
+	read_unlock(&grsec_tcb_lock);
 
 	if (unlikely(retval == NULL)) {
 		/* real_root is pinned, we don't need to hold a reference */
+		read_lock(&grsec_tcb_lock);
 		read_lock(&gr_inode_lock);
 		retval = lookup_acl_subj_label(real_root.dentry->d_inode->i_ino,
 					  __get_dev(real_root.dentry), role);
 		read_unlock(&gr_inode_lock);
+		read_unlock(&grsec_tcb_lock);
 	}
 out:
 	write_sequnlock(&rename_lock);
@@ -2114,6 +2133,9 @@ gr_log_learn(const struct dentry *dentry, const struct vfsmount *mnt, const __u3
 	struct task_struct *task = current;
 	const struct cred *cred = current_cred();
 
+	if(unlikely(!task->acl || !task->role)) {
+		return;
+	}
 	security_learn(GR_LEARN_AUDIT_MSG, task->role->rolename, task->role->roletype,
 		       GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid), task->exec_file ? gr_to_filename1(task->exec_file->f_path.dentry,
 		       task->exec_file->f_path.mnt) : task->acl->filename, task->acl->filename,
@@ -2128,6 +2150,9 @@ gr_log_learn_uid_change(const kuid_t real, const kuid_t effective, const kuid_t
 	struct task_struct *task = current;
 	const struct cred *cred = current_cred();
 
+	if(unlikely(!task->acl || !task->role)) {
+		return;
+	}
 	security_learn(GR_ID_LEARN_MSG, task->role->rolename, task->role->roletype,
 		       GR_GLOBAL_UID(cred->uid), GR_GLOBAL_GID(cred->gid), task->exec_file ? gr_to_filename1(task->exec_file->f_path.dentry,
 		       task->exec_file->f_path.mnt) : task->acl->filename, task->acl->filename,
@@ -2161,6 +2186,9 @@ gr_search_file(const struct dentry * dentry, const __u32 mode,
 	if (unlikely(!(gr_status & GR_READY)))
 		return (mode & ~GR_AUDITS);
 
+	if (unlikely(!current->acl))
+		return (mode & ~GR_AUDITS);
+
 	curracl = current->acl;
 
 	currobj = chk_obj_label(dentry, mnt, curracl);
@@ -2458,7 +2486,7 @@ gr_check_user_change(kuid_t real, kuid_t effective, kuid_t fs)
 skipit:
 #endif
 
-	if (unlikely(!(gr_status & GR_READY)))
+	if (unlikely(!(gr_status & GR_READY) || !current->acl))
 		return 0;
 
 	if (current->acl->mode & (GR_LEARN | GR_INHERITLEARN))
@@ -2622,6 +2650,9 @@ gr_set_role_label(struct task_struct *task, const kuid_t kuid, const kgid_t kgid
 	uid = GR_GLOBAL_UID(kuid);
 	gid = GR_GLOBAL_GID(kgid);
 
+	if (unlikely(!role))
+		return;
+
 	filp = task->exec_file;
 
 	/* kernel process, we'll give them the kernel role */
@@ -2687,6 +2718,9 @@ gr_set_proc_label(const struct dentry *dentry, const struct vfsmount *mnt,
 	if (unlikely(!(gr_status & GR_READY)))
 		return 0;
 
+	if (unlikely(!task->role))
+		return 0;
+
 	newacl = chk_subj_label(dentry, mnt, task->role);
 
 	/* special handling for if we did an strace -f -p <pid> from an admin role, where pid then
@@ -2767,8 +2801,10 @@ do_handle_delete(struct inodev_entry *inodev, const ino_t ino, const dev_t dev)
 			if ((matchpo = lookup_acl_obj_label(ino, dev, subj)) != NULL)
 				matchpo->mode |= GR_DELETED;
 		FOR_EACH_NESTED_SUBJECT_END(subj)
+		read_lock(&grsec_tcb_lock);
 		if ((matchps = lookup_acl_subj_label(ino, dev, role)) != NULL)
 			matchps->mode |= GR_DELETED;
+		read_unlock(&grsec_tcb_lock);
 	FOR_EACH_ROLE_END(role)
 
 	inodev->nentry->deleted = 1;
@@ -3411,10 +3447,12 @@ write_grsec_handler(struct file *file, const char __user * buf, size_t count, lo
 			gr_log_noargs(GR_DONT_AUDIT_GOOD, GR_SEGVMODS_ACL_MSG);
 			if (gr_usermode->segv_device && gr_usermode->segv_inode) {
 				struct acl_subject_label *segvacl;
+				read_lock(&grsec_tcb_lock);
 				segvacl =
 				    lookup_acl_subj_label(gr_usermode->segv_inode,
 							  gr_usermode->segv_device,
 							  current->role);
+				read_unlock(&grsec_tcb_lock);
 				if (segvacl) {
 					segvacl->crashes = 0;
 					segvacl->expires = 0;
@@ -3547,6 +3585,7 @@ int gr_apply_subject_to_task(struct task_struct *task)
 	nmatch = lookup_name_entry(tmpname);
 	preempt_enable();
 	tmpsubj = NULL;
+	read_lock(&grsec_tcb_lock);
 	if (nmatch) {
 		if (nmatch->deleted)
 			tmpsubj = lookup_acl_subj_label_deleted(nmatch->inode, nmatch->device, task->role);
@@ -3555,6 +3594,7 @@ int gr_apply_subject_to_task(struct task_struct *task)
 		if (tmpsubj != NULL)
 			task->acl = tmpsubj;
 	}
+	read_unlock(&grsec_tcb_lock);
 	if (tmpsubj == NULL)
 		task->acl = chk_subj_label(filp->f_path.dentry, filp->f_path.mnt,
 					   task->role);
@@ -3709,8 +3749,11 @@ pax_set_initial_flags(struct linux_binprm *bprm)
         struct acl_subject_label *proc;
 	unsigned long flags;
 
-        if (unlikely(!(gr_status & GR_READY)))
-                return;
+	if (unlikely(!(gr_status & GR_READY)))
+		return;
+
+	if (unlikely(!task->acl))
+		return;
 
 	flags = pax_get_flags(task);
 
@@ -3892,6 +3935,9 @@ static int is_writable_mmap(const struct file *filp)
 	struct task_struct *task = current;
 	struct acl_object_label *obj, *obj2;
 
+	if (unlikely(!task->role))
+		return 0;
+
 	if (gr_status & GR_READY && !(task->acl->mode & GR_OVERRIDE) &&
 	    !task->is_writable && S_ISREG(filp->f_path.dentry->d_inode->i_mode) && (filp->f_path.mnt != shm_mnt || (filp->f_path.dentry->d_inode->i_nlink > 0))) {
 		obj = chk_obj_label(filp->f_path.dentry, filp->f_path.mnt, default_role->root_label);
@@ -4067,7 +4113,7 @@ int gr_is_taskstats_denied(int pid)
 */
 int gr_acl_enable_at_secure(void)
 {
-	if (unlikely(!(gr_status & GR_READY)))
+	if (unlikely(!(gr_status & GR_READY) || !current->acl))
 		return 0;
 
 	if (current->acl->mode & GR_ATSECURE)
@@ -4088,7 +4134,7 @@ int gr_acl_handle_filldir(const struct file *file, const char *name, const unsig
 	char *path;
 	dev_t dev = __get_dev(dentry);
 
-	if (unlikely(!(gr_status & GR_READY)))
+	if (unlikely(!(gr_status & GR_READY) || !task->acl))
 		return 1;
 
 	if (task->acl->mode & (GR_LEARN | GR_INHERITLEARN))
diff --git a/grsecurity/gracl_cap.c b/grsecurity/gracl_cap.c
index bdd51ea..7d97a35 100644
--- a/grsecurity/gracl_cap.c
+++ b/grsecurity/gracl_cap.c
@@ -16,6 +16,9 @@ int gr_task_acl_is_capable(const struct task_struct *task, const struct cred *cr
 
 	if (!gr_acl_is_enabled())
 		return 1;
+	if (unlikely(!task->acl || !task->role)) {
+		return 1;
+	}
 
 	curracl = task->acl;
 
diff --git a/grsecurity/gracl_fs.c b/grsecurity/gracl_fs.c
index a340c17..1742fdf 100644
--- a/grsecurity/gracl_fs.c
+++ b/grsecurity/gracl_fs.c
@@ -13,6 +13,8 @@ gr_acl_umask(void)
 {
 	if (unlikely(!gr_acl_is_enabled()))
 		return 0;
+	if (unlikely(!current->role))
+		return 0;
 
 	return current->role->umask;
 }
@@ -26,8 +28,10 @@ gr_acl_handle_hidden_file(const struct dentry * dentry,
 	if (unlikely(!dentry->d_inode))
 		return GR_FIND;
 
+	read_lock(&grsec_tcb_lock);
 	mode =
 	    gr_search_file(dentry, GR_FIND | GR_AUDIT_FIND | GR_SUPPRESS, mnt);
+	read_unlock(&grsec_tcb_lock);
 
 	if (unlikely(mode & GR_FIND && mode & GR_AUDIT_FIND)) {
 		gr_log_fs_rbac_generic(GR_DO_AUDIT, GR_HIDDEN_ACL_MSG, dentry, mnt);
@@ -58,9 +62,11 @@ gr_acl_handle_open(const struct dentry * dentry, const struct vfsmount * mnt,
 	if ((acc_mode & MAY_READ) && !S_ISDIR(dentry->d_inode->i_mode))
 		reqmode |= GR_READ;
 
+	read_lock(&grsec_tcb_lock);
 	mode =
 	    gr_search_file(dentry, reqmode | to_gr_audit(reqmode) | GR_SUPPRESS,
 			   mnt);
+	read_unlock(&grsec_tcb_lock);
 
 	if (unlikely(((mode & reqmode) == reqmode) && mode & GR_AUDITS)) {
 		gr_log_fs_rbac_mode2(GR_DO_AUDIT, GR_OPEN_ACL_MSG, dentry, mnt,
@@ -423,6 +429,8 @@ gr_acl_handle_procpidmem(const struct task_struct *task)
 {
 	if (unlikely(!gr_acl_is_enabled()))
 		return 0;
+	if (unlikely(!task->acl))
+		return 0;
 
 	if (task != current && task->acl->mode & GR_PROTPROCFD)
 		return -EACCES;
diff --git a/grsecurity/gracl_ip.c b/grsecurity/gracl_ip.c
index a3a0304..9077ec8 100644
--- a/grsecurity/gracl_ip.c
+++ b/grsecurity/gracl_ip.c
@@ -102,6 +102,8 @@ gr_search_socket(const int domain, const int type, const int protocol)
 	    (domain >= AF_MAX) || (type >= SOCK_MAX) || (protocol >= IPPROTO_MAX))
 		goto exit;	// let the kernel handle it
 
+	if (unlikely(!current->acl || !current->role))
+		goto exit;
 	curr = current->acl;
 
 	if (curr->sock_families[domain / 32] & (1U << (domain % 32))) {
diff --git a/grsecurity/gracl_segv.c b/grsecurity/gracl_segv.c
index 3c38bfe..5a3e276 100644
--- a/grsecurity/gracl_segv.c
+++ b/grsecurity/gracl_segv.c
@@ -192,7 +192,7 @@ gr_handle_crash(struct task_struct *task, const int sig)
 	if (sig != SIGSEGV && sig != SIGKILL && sig != SIGBUS && sig != SIGILL)
 		return;
 
-	if (unlikely(!gr_acl_is_enabled()))
+	if (unlikely(!gr_acl_is_enabled() || !task->acl))
 		return;
 
 	curr = task->acl;
@@ -254,14 +254,16 @@ gr_check_crash_exec(const struct file *filp)
 {
 	struct acl_subject_label *curr;
 
-	if (unlikely(!gr_acl_is_enabled()))
+	if (unlikely(!gr_acl_is_enabled() || !current->role))
 		return 0;
 
+	read_lock(&grsec_tcb_lock);
 	read_lock(&gr_inode_lock);
 	curr = lookup_acl_subj_label(filp->f_path.dentry->d_inode->i_ino,
 				     __get_dev(filp->f_path.dentry),
 				     current->role);
 	read_unlock(&gr_inode_lock);
+	read_unlock(&grsec_tcb_lock);
 
 	if (!curr || !(curr->resmask & (1U << GR_CRASH_RES)) ||
 	    (!curr->crashes && !curr->expires))
diff --git a/include/linux/gracl.h b/include/linux/gracl.h
index ebe6d72..dc2d020 100644
--- a/include/linux/gracl.h
+++ b/include/linux/gracl.h
@@ -250,6 +250,7 @@ struct acl_subj_map_db {
 	__u32 s_size;
 };
 
+extern rwlock_t grsec_tcb_lock;
 /* End Data Structures Section */
 
 /* Hash functions generated by empirical testing by Brad Spengler
diff --git a/kernel/cred.c b/kernel/cred.c
index 3874e41..1f66ccf 100644
--- a/kernel/cred.c
+++ b/kernel/cred.c
@@ -18,6 +18,7 @@
 #include <linux/security.h>
 #include <linux/binfmts.h>
 #include <linux/cn_proc.h>
+#include <linux/gracl.h>
 
 #if 0
 #define kdebug(FMT, ...) \
@@ -440,7 +441,9 @@ static int __commit_creds(struct cred *new)
 
 	get_cred(new); /* we will require a ref for the subj creds too */
 
+	read_lock(&grsec_tcb_lock);
 	gr_set_role_label(task, new->uid, new->gid);
+	read_unlock(&grsec_tcb_lock);
 
 	/* dumpability changes */
 	if (!uid_eq(old->euid, new->euid) ||
diff --git a/mm/mmap.c b/mm/mmap.c
index e2332c5..248aeb8 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -37,6 +37,7 @@
 #include <linux/notifier.h>
 #include <linux/memory.h>
 #include <linux/random.h>
+#include <linux/gracl.h>
 
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
@@ -1466,9 +1467,13 @@ unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,
 			vm_flags |= VM_NORESERVE;
 	}
 
-	if (!gr_acl_handle_mmap(file, prot))
+	read_lock(&grsec_tcb_lock);
+	if (!gr_acl_handle_mmap(file, prot)) {
+		read_unlock(&grsec_tcb_lock);
 		return -EACCES;
-	
+	}
+	read_unlock(&grsec_tcb_lock);
+
 	addr = mmap_region(file, addr, len, vm_flags, pgoff);
 	if (!IS_ERR_VALUE(addr) &&
 	    ((vm_flags & VM_LOCKED) ||
-- 
1.7.9.5

