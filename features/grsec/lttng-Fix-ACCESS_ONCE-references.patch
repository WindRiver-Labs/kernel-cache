From 70c3dedc33bddd20321975a7741d83fed7f4a35b Mon Sep 17 00:00:00 2001
From: Joe MacDonald <joe.macdonald@windriver.com>
Date: Thu, 19 Jul 2012 16:51:52 -0400
Subject: [PATCH 4/6] lttng: Fix ACCESS_ONCE references

PAX introduces a new macro, ACCESS_ONCE_RW that indicates we intend to
update the value we're referencing.  lttng had several places that needed
to be updated as a consequence.

Signed-off-by: Joe MacDonald <joe.macdonald@windriver.com>
---
 .../lttng2/lib/ringbuffer/backend_internal.h       |    6 +++---
 .../lttng2/lib/ringbuffer/ring_buffer_frontend.c   |    6 +++---
 drivers/staging/lttng2/lttng-events.c              |   12 ++++++------
 3 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/lttng2/lib/ringbuffer/backend_internal.h b/drivers/staging/lttng2/lib/ringbuffer/backend_internal.h
index 3e262c2..69e8607 100644
--- a/drivers/staging/lttng2/lib/ringbuffer/backend_internal.h
+++ b/drivers/staging/lttng2/lib/ringbuffer/backend_internal.h
@@ -165,7 +165,7 @@ void subbuffer_id_set_noref_offset(const struct lib_ring_buffer_config *config,
 		tmp |= offset << SB_ID_OFFSET_SHIFT;
 		tmp |= SB_ID_NOREF_MASK;
 		/* Volatile store, read concurrently by readers. */
-		ACCESS_ONCE(*id) = tmp;
+		ACCESS_ONCE_RW(*id) = tmp;
 	}
 }
 
@@ -320,7 +320,7 @@ void lib_ring_buffer_clear_noref(const struct lib_ring_buffer_config *config,
 	 * Performing a volatile access to read the sb_pages, because we want to
 	 * read a coherent version of the pointer and the associated noref flag.
 	 */
-	id = ACCESS_ONCE(bufb->buf_wsb[idx].id);
+	id = ACCESS_ONCE_RW(bufb->buf_wsb[idx].id);
 	for (;;) {
 		/* This check is called on the fast path for each record. */
 		if (likely(!subbuffer_id_is_noref(config, id))) {
@@ -389,7 +389,7 @@ int update_read_sb_index(const struct lib_ring_buffer_config *config,
 	if (config->mode == RING_BUFFER_OVERWRITE) {
 		/*
 		 * Exchange the target writer subbuffer with our own unused
-		 * subbuffer. No need to use ACCESS_ONCE() here to read the
+		 * subbuffer. No need to use ACCESS_ONCE_RW() here to read the
 		 * old_wpage, because the value read will be confirmed by the
 		 * following cmpxchg().
 		 */
diff --git a/drivers/staging/lttng2/lib/ringbuffer/ring_buffer_frontend.c b/drivers/staging/lttng2/lib/ringbuffer/ring_buffer_frontend.c
index dc0357f..e318603 100644
--- a/drivers/staging/lttng2/lib/ringbuffer/ring_buffer_frontend.c
+++ b/drivers/staging/lttng2/lib/ringbuffer/ring_buffer_frontend.c
@@ -745,7 +745,7 @@ void *channel_destroy(struct channel *chan)
 			 * Perform flush before writing to finalized.
 			 */
 			smp_wmb();
-			ACCESS_ONCE(buf->finalized) = 1;
+			ACCESS_ONCE_RW(buf->finalized) = 1;
 			wake_up_interruptible(&buf->read_wait);
 		}
 	} else {
@@ -759,10 +759,10 @@ void *channel_destroy(struct channel *chan)
 		 * Perform flush before writing to finalized.
 		 */
 		smp_wmb();
-		ACCESS_ONCE(buf->finalized) = 1;
+		ACCESS_ONCE_RW(buf->finalized) = 1;
 		wake_up_interruptible(&buf->read_wait);
 	}
-	ACCESS_ONCE(chan->finalized) = 1;
+	ACCESS_ONCE_RW(chan->finalized) = 1;
 	wake_up_interruptible(&chan->hp_wait);
 	wake_up_interruptible(&chan->read_wait);
 	priv = chan->backend.priv;
diff --git a/drivers/staging/lttng2/lttng-events.c b/drivers/staging/lttng2/lttng-events.c
index 8af92d0..eaf7aef 100644
--- a/drivers/staging/lttng2/lttng-events.c
+++ b/drivers/staging/lttng2/lttng-events.c
@@ -79,7 +79,7 @@ void lttng_session_destroy(struct lttng_session *session)
 	int ret;
 
 	mutex_lock(&sessions_mutex);
-	ACCESS_ONCE(session->active) = 0;
+	ACCESS_ONCE_RW(session->active) = 0;
 	list_for_each_entry(chan, &session->chan, list) {
 		ret = lttng_syscalls_unregister(chan);
 		WARN_ON(ret);
@@ -122,16 +122,16 @@ int lttng_session_enable(struct lttng_session *session)
 			chan->header_type = 2;	/* large */
 	}
 
-	ACCESS_ONCE(session->active) = 1;
-	ACCESS_ONCE(session->been_active) = 1;
+	ACCESS_ONCE_RW(session->active) = 1;
+	ACCESS_ONCE_RW(session->been_active) = 1;
 	ret = _lttng_session_metadata_statedump(session);
 	if (ret) {
-		ACCESS_ONCE(session->active) = 0;
+		ACCESS_ONCE_RW(session->active) = 0;
 		goto end;
 	}
 	ret = lttng_statedump_start(session);
 	if (ret)
-		ACCESS_ONCE(session->active) = 0;
+		ACCESS_ONCE_RW(session->active) = 0;
 end:
 	mutex_unlock(&sessions_mutex);
 	return ret;
@@ -146,7 +146,7 @@ int lttng_session_disable(struct lttng_session *session)
 		ret = -EBUSY;
 		goto end;
 	}
-	ACCESS_ONCE(session->active) = 0;
+	ACCESS_ONCE_RW(session->active) = 0;
 end:
 	mutex_unlock(&sessions_mutex);
 	return ret;
-- 
1.7.9.7

