From 664e01bef177e5059bb8ec7bd9dafc665d1ec73b Mon Sep 17 00:00:00 2001
From: Roy.Li <rongqing.li@windriver.com>
Date: Wed, 6 Mar 2013 16:44:26 +0800
Subject: [PATCH] powerpc/ptrace: make the read/write registers successful in PowerPC CGL kernel

To meet the security requirements of the PAX_USERCOPY feature, and allow
gdb/usermode-agent to work on grsec enabled powerpc kernels, we need
a two step copy procedure.

We first copy the registers from the task struct to stack memory, and
then copy the stack memory to userspace.

The same technique allows register writing to succeed.

Signed-off-by: Roy.Li <rongqing.li@windriver.com>
---
 arch/powerpc/kernel/ptrace.c |  100 +++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 98 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/kernel/ptrace.c b/arch/powerpc/kernel/ptrace.c
index 7b8c9c8..7726591 100644
--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@ -230,15 +230,37 @@ int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)
 	return -EIO;
 }
 
+#ifdef CONFIG_PAX_USERCOPY
+/*
+ * MAX_REGS_LENGTH should be the maximum size of gpr, evr, namely
+ * the maximum of sizeof(struct ptr_regs), sizeof(thread->evr) +
+ * sizeof(thread ->acc)
+ */
+#define MAX_REGS_LENGTH ELF_NGREG
+#endif
+
 static int gpr_get(struct task_struct *target, const struct user_regset *regset,
 		   unsigned int pos, unsigned int count,
 		   void *kbuf, void __user *ubuf)
 {
 	int i, ret;
 
+#ifdef CONFIG_PAX_USERCOPY
+	int to_user = 0;
+	long mbuf[MAX_REGS_LENGTH];
+#endif
 	if (target->thread.regs == NULL)
 		return -EIO;
 
+#ifdef CONFIG_PAX_USERCOPY
+	if (!kbuf) {
+		kbuf = mbuf;
+		to_user = count;
+
+		if (count > sizeof(long)*MAX_REGS_LENGTH)
+			return -ENOMEM;
+	}
+#endif
 	if (!FULL_REGS(target->thread.regs)) {
 		/* We have a partial register set.  Fill 14-31 with bogus values */
 		for (i = 14; i < 32; i++)
@@ -268,6 +290,10 @@ static int gpr_get(struct task_struct *target, const struct user_regset *regset,
 		ret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,
 					       sizeof(struct pt_regs), -1);
 
+#ifdef CONFIG_PAX_USERCOPY
+	if (to_user)
+		__copy_to_user(ubuf, kbuf, to_user);
+#endif
 	return ret;
 }
 
@@ -277,10 +303,21 @@ static int gpr_set(struct task_struct *target, const struct user_regset *regset,
 {
 	unsigned long reg;
 	int ret;
-
+#ifdef CONFIG_PAX_USERCOPY
+	long mbuf[MAX_REGS_LENGTH];
+#endif
 	if (target->thread.regs == NULL)
 		return -EIO;
 
+#ifdef CONFIG_PAX_USERCOPY
+	if (!kbuf) {
+		if (count > sizeof(long)*MAX_REGS_LENGTH)
+			return -ENOMEM;
+
+		kbuf = mbuf;
+		__copy_from_user((void *)kbuf, ubuf, count);
+	}
+#endif
 	CHECK_FULL_REGS(target->thread.regs);
 
 	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
@@ -406,7 +443,17 @@ static int vr_get(struct task_struct *target, const struct user_regset *regset,
 		  void *kbuf, void __user *ubuf)
 {
 	int ret;
+#ifdef CONFIG_PAX_USERCOPY
+	int to_user = 0;
 
+	if (!kbuf) {
+		kbuf = kmalloc(count, GFP_KERNEL);
+		if (!kbuf)
+			return -ENOMEM;
+
+		to_user = count;
+	}
+#endif
 	flush_altivec_to_thread(target);
 
 	BUILD_BUG_ON(offsetof(struct thread_struct, vscr) !=
@@ -428,7 +475,12 @@ static int vr_get(struct task_struct *target, const struct user_regset *regset,
 		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,
 					  33 * sizeof(vector128), -1);
 	}
-
+#ifdef CONFIG_PAX_USERCOPY
+	if (to_user) {
+		__copy_to_user(ubuf, kbuf, to_user);
+		kfree(kbuf);
+	}
+#endif
 	return ret;
 }
 
@@ -438,6 +490,18 @@ static int vr_set(struct task_struct *target, const struct user_regset *regset,
 {
 	int ret;
 
+#ifdef CONFIG_PAX_USERCOPY
+	int from_user = 0;
+
+	if (!kbuf) {
+		kbuf = kmalloc(count, GFP_KERNEL);
+		if (!kbuf)
+			return -ENOMEM;
+
+		from_user = count;
+		__copy_from_user(kbuf, ubuf, count);
+	}
+#endif
 	flush_altivec_to_thread(target);
 
 	BUILD_BUG_ON(offsetof(struct thread_struct, vscr) !=
@@ -461,6 +525,10 @@ static int vr_set(struct task_struct *target, const struct user_regset *regset,
 			target->thread.vrsave = vrsave.word;
 	}
 
+#ifdef CONFIG_PAX_USERCOPY
+	if (from_user)
+		kfree(kbuf);
+#endif
 	return ret;
 }
 #endif /* CONFIG_ALTIVEC */
@@ -540,6 +608,18 @@ static int evr_get(struct task_struct *target, const struct user_regset *regset,
 {
 	int ret;
 
+#ifdef CONFIG_PAX_USERCOPY
+	int to_user = 0;
+	long mbuf[MAX_REGS_LENGTH];
+
+	if (!kbuf) {
+		kbuf = mbuf;
+		to_user = count;
+
+		if (count > sizeof(long)*MAX_REGS_LENGTH)
+			return -ENOMEM;
+	}
+#endif
 	flush_spe_to_thread(target);
 
 	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
@@ -554,6 +634,10 @@ static int evr_get(struct task_struct *target, const struct user_regset *regset,
 					  &target->thread.acc,
 					  sizeof(target->thread.evr), -1);
 
+#ifdef CONFIG_PAX_USERCOPY
+	if (to_user)
+		__copy_to_user(ubuf, kbuf, to_user);
+#endif
 	return ret;
 }
 
@@ -563,6 +647,18 @@ static int evr_set(struct task_struct *target, const struct user_regset *regset,
 {
 	int ret;
 
+#ifdef CONFIG_PAX_USERCOPY
+	long mbuf[MAX_REGS_LENGTH];
+
+	if (!kbuf) {
+		if (count > sizeof(long)*MAX_REGS_LENGTH)
+			return -ENOMEM;
+
+		kbuf = mbuf;
+		__copy_from_user((void *)kbuf, ubuf, count);
+	}
+#endif
+
 	flush_spe_to_thread(target);
 
 	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
-- 
1.7.0

