From 0d7dec6f6d4fea4a85bf531b80cc5ffd850d8604 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Mon, 4 Mar 2013 15:14:24 +0800
Subject: [PATCH] pax/cgl: module: fix module_alloc_exec

When we load kernel module in kmemleak enabled CGL kernel, we'll see
kernel call trace like this:

...
kmemleak: Trying to color unknown object at 0xc1723000 as Grey
Pid: 131, comm: modprobe Not tainted 3.4.28-grsec-WR5.0.1.0_cgl #1
Call Trace:
[<00128018>] paint_ptr+0x88/0xa0
[<006f1f98>] kmemleak_not_leak+0x28/0x60
[<00085d82>] sys_init_module+0x832/0x1dd0
[<0071948a>] ? do_page_fault+0x3ba/0x7f0
[<00030564>] ? put_online_cpus+0x44/0x60
[<0001fc9c>] ? native_apic_mem_read+0xc/0x20
[<000223ac>] ? do_sys_vm86+0x13c/0x2c0
[<00715fd6>] syscall_call+0x7/0xb
[<00030564>] ? put_online_cpus+0x44/0x60
[<0071007b>] ? dotest+0x8d/0x23e
[<007190d0>] ? spurious_fault+0x100/0x100
[<00010296>] ? show_cpuinfo+0x3a6/0x400
[<007190d0>] ? spurious_fault+0x100/0x100
[<00307c08>] ? trace_hardirqs_on_thunk+0xc/0x10
[<00716005>] ? restore_all+0xf/0xf
[<007190d0>] ? spurious_fault+0x100/0x100
[<00010246>] ? show_cpuinfo+0x356/0x400
kmemleak: Trying to color unknown object at 0xc174b000 as Grey
Pid: 131, comm: modprobe Not tainted 3.4.28-grsec-WR5.0.1.0_cgl #1
Call Trace:
[<00128018>] paint_ptr+0x88/0xa0
[<006f1f98>] kmemleak_not_leak+0x28/0x60
[<00085df7>] sys_init_module+0x8a7/0x1dd0
[<0071948a>] ? do_page_fault+0x3ba/0x7f0
[<00030564>] ? put_online_cpus+0x44/0x60
[<0001fc9c>] ? native_apic_mem_read+0xc/0x20
[<000223ac>] ? do_sys_vm86+0x13c/0x2c0
[<00715fd6>] syscall_call+0x7/0xb
[<00030564>] ? put_online_cpus+0x44/0x60
[<0071007b>] ? dotest+0x8d/0x23e
[<007190d0>] ? spurious_fault+0x100/0x100
[<00010296>] ? show_cpuinfo+0x3a6/0x400
[<007190d0>] ? spurious_fault+0x100/0x100
[<00307c08>] ? trace_hardirqs_on_thunk+0xc/0x10
[<00716005>] ? restore_all+0xf/0xf
[<007190d0>] ? spurious_fault+0x100/0x100
[<00010246>] ? show_cpuinfo+0x356/0x400
...

The call trace is triggered by x86-32 PAX implementation on CGL kernel,
where it does not register the memory with kmemleak.

The call trace is triggered by the kmemleak_not_leak, the reason is
that the ptr returned by module_alloc_update_bounds_rx is not
registered to kmemleak properly. Check the implementation of
module_alloc_update_bounds_rx, where it calls module_alloc_exec.

The error is reported in paint_ptr.  The call to
find_and_get_object(prt, 0) will return NULL hence produce the warning.

We should register memory blocks to kmemleak properly in
module_free_exec.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/x86/kernel/module.c |   12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/arch/x86/kernel/module.c b/arch/x86/kernel/module.c
index 61565cd..f069002 100644
--- a/arch/x86/kernel/module.c
+++ b/arch/x86/kernel/module.c
@@ -29,6 +29,9 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 
+#include <linux/slab.h>
+#include <linux/kmemleak.h>
+
 #if 0
 #define DEBUGP printk
 #else
@@ -65,12 +68,19 @@ void *module_alloc_exec(unsigned long size)
 		return NULL;
 
 	area = __get_vm_area(size, VM_ALLOC, (unsigned long)&MODULES_EXEC_VADDR, (unsigned long)&MODULES_EXEC_END);
-	return area ? area->addr : NULL;
+
+	if (!area)
+		return NULL;
+
+	kmemleak_alloc(area->addr, size, 0, 0);
+
+	return area->addr;
 }
 EXPORT_SYMBOL(module_alloc_exec);
 
 void module_free_exec(struct module *mod, void *module_region)
 {
+	kmemleak_free(module_region);
 	vunmap(module_region);
 }
 EXPORT_SYMBOL(module_free_exec);
-- 
1.7.9.7

