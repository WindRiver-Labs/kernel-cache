From f02aa098bbd51a29dd1a065cf6f65b5719b72972 Mon Sep 17 00:00:00 2001
From: Jonas Rendel <Jonas.Rendel@windriver.com>
Date: Tue, 6 Jan 2009 14:09:32 -0500
Subject: [PATCH] [PATCH] adapted grsecurity to the ANT stack

From 066c208915de83174bb281e8539048a74515833c Mon Sep 17 00:00:00 2001
Subject: [PATCH] adapted grsecurity to the ANT stack
---
 grsecurity/gracl_ip.c   |   71 +++++++++++++++++++++++++++++++++++++++++++---
 grsecurity/grsec_sock.c |   23 +++++++++++++++
 2 files changed, 89 insertions(+), 5 deletions(-)

diff --git a/grsecurity/gracl_ip.c b/grsecurity/gracl_ip.c
index 443681d..d6255aa 100644
--- a/grsecurity/gracl_ip.c
+++ b/grsecurity/gracl_ip.c
@@ -159,7 +159,9 @@ gr_search_connectbind(const int mode, const struct sock *sk,
 	struct acl_subject_label *curr;
 	struct acl_ip_label *ip;
 	struct net_device *dev;
+#ifndef CONFIG_INTERPEAK
 	struct in_device *idev;
+#endif
 	unsigned long i;
 	int ret;
 	__u32 ip_addr = 0;
@@ -201,6 +203,37 @@ gr_search_connectbind(const int mode, const struct sock *sk,
 			dev = dev_get_by_name(sock_net(sk), iface);
 			if (dev == NULL)
 				continue;
+#ifdef CONFIG_INTERPEAK
+			{
+				struct ifreq	   ifr;
+				struct sockaddr_in *sin;
+				struct socket	   *sock;
+
+				if (sock_create_kern(AF_INET, SOCK_DGRAM,
+					IPPROTO_UDP, &sock) < 0)
+					continue;
+
+				strcpy(ifr.ifr_name, dev->name);
+				sin = (struct sockaddr_in*)&ifr.ifr_addr;
+
+				if (kernel_sock_ioctl(sock, SIOCGIFADDR, (unsigned long)&ifr) < 0) {
+					sock_release(sock);
+					continue;
+				}
+
+				sock_release(sock);
+
+				our_addr = sin->sin_addr.s_addr;
+				our_netmask = 0xffffffff;
+
+				ret = check_ip_policy(ip, ip_addr, ip_port, sk->sk_protocol, mode, type, our_addr, our_netmask);
+
+				if (ret == 1)
+					return 1;
+				else if (ret == 2)
+					goto denied;
+			}
+#else
 			idev = in_dev_get(dev);
 			if (idev == NULL) {
 				dev_put(dev);
@@ -228,6 +261,7 @@ gr_search_connectbind(const int mode, const struct sock *sk,
 			rcu_read_unlock();
 			in_dev_put(idev);
 			dev_put(dev);
+#endif
 		} else {
 			our_addr = ip->addr;
 			our_netmask = ip->netmask;
@@ -264,10 +298,19 @@ int gr_search_listen(const struct socket *sock)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_in addr;
-
+#ifdef CONFIG_INTERPEAK
+    int addr_sz = sizeof(addr);
+
+    if (sk && sk->sk_family == AF_INET) {
+        if (kernel_getsockname((struct socket*)sock, (struct sockaddr*)&addr, &addr_sz) < 0)
+		return -1;
+    } else {
+        memset(&addr,0,sizeof(addr));
+    }
+#else
 	addr.sin_addr.s_addr = inet_sk(sk)->saddr;
 	addr.sin_port = inet_sk(sk)->sport;
-
+#endif
 	return gr_search_connectbind(GR_BIND, sock->sk, &addr, sock->type);
 }
 
@@ -275,10 +318,19 @@ int gr_search_accept(const struct socket *sock)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_in addr;
-
+#ifdef CONFIG_INTERPEAK
+    int addr_sz = sizeof(addr);
+
+    if (sk && sk->sk_family == AF_INET) {
+        if (kernel_getsockname((struct socket*)sock, (struct sockaddr*)&addr, &addr_sz) < 0)
+		return -1;
+    } else {
+        memset(&addr,0,sizeof(addr));
+    }
+#else
 	addr.sin_addr.s_addr = inet_sk(sk)->saddr;
 	addr.sin_port = inet_sk(sk)->sport;
-
+#endif
 	return gr_search_connectbind(GR_BIND, sock->sk, &addr, sock->type);
 }
 
@@ -289,11 +341,20 @@ gr_search_udp_sendmsg(const struct sock *sk, const struct sockaddr_in *addr)
 		return gr_search_connectbind(GR_CONNECT, sk, addr, SOCK_DGRAM);
 	else {
 		struct sockaddr_in sin;
+#ifdef CONFIG_INTERPEAK
+        int sin_sz = sizeof(sin);
+        if (sk && sk->sk_family == AF_INET) {
+            if (kernel_getpeername(sk->sk_socket, (struct sockaddr*)&sin, &sin_sz) < 0)
+		return -1;
+        } else {
+            memset(&sin,0,sizeof(sin));
+        }
+#else
 		const struct inet_sock *inet = inet_sk(sk);
 
 		sin.sin_addr.s_addr = inet->daddr;
 		sin.sin_port = inet->dport;
-
+#endif
 		return gr_search_connectbind(GR_CONNECT, sk, &sin, SOCK_DGRAM);
 	}
 }
diff --git a/grsecurity/grsec_sock.c b/grsecurity/grsec_sock.c
index 6cab618..d2bc22c 100644
--- a/grsecurity/grsec_sock.c
+++ b/grsecurity/grsec_sock.c
@@ -165,16 +165,35 @@ gr_attach_curr_ip(const struct sock *sk)
 {
 #ifdef CONFIG_GRKERNSEC
 	struct signal_struct *p, *set;
+#ifdef CONFIG_INTERPEAK
+	struct sockaddr_in src;
+	struct sockaddr_in dst;
+    size_t len = sizeof(struct sockaddr_in);
+#else
 	const struct inet_sock *inet = inet_sk(sk);	
+#endif
 
 	if (unlikely(sk->sk_protocol != IPPROTO_TCP))
 		return;
 
 	set = current->signal;
 
+
+#ifdef CONFIG_INTERPEAK
+	if (kernel_getsockname(sk->sk_socket, (struct sockaddr*)&src, &len) < 0)
+		return;
+
+	if (kernel_getpeername(sk->sk_socket, (struct sockaddr*)&dst, &len) < 0)
+	       return;
+
+	spin_lock_bh(&gr_conn_table_lock);
+	p = gr_lookup_task_ip_table(dst.sin_addr.s_addr, src.sin_addr.s_addr,
+				    dst.sin_port, src.sin_port);
+#else
 	spin_lock_bh(&gr_conn_table_lock);
 	p = gr_lookup_task_ip_table(inet->daddr, inet->rcv_saddr,
 				    inet->dport, inet->sport);
+#endif
 	if (unlikely(p != NULL)) {
 		set->curr_ip = p->curr_ip;
 		set->used_accept = 1;
@@ -184,7 +203,11 @@ gr_attach_curr_ip(const struct sock *sk)
 	}
 	spin_unlock_bh(&gr_conn_table_lock);
 
+#ifdef CONFIG_INTERPEAK
+	set->curr_ip = dst.sin_addr.s_addr;
+#else
 	set->curr_ip = inet->daddr;
+#endif
 	set->used_accept = 1;
 #endif
 	return;
-- 
1.6.0.3

