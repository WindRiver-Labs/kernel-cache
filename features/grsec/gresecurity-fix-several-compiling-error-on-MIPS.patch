From 7c85929aed261eeb88d1ef3a74da3869c67ba011 Mon Sep 17 00:00:00 2001
From: "Roy.Li" <rongqing.li@windriver.com>
Date: Fri, 19 Apr 2013 15:37:38 +0800
Subject: [PATCH] gresecurity: fix several compiling error on MIPS

1. machine_power_off/halt/restart have been defined as noreturn function,
but they will exit in MIPS arch. now make them  as noreturn.

	arch/mips/kernel/reset.c:44:1: error: 'noreturn' function does
	return [-Werror]

2. fix a typOS, backport from grsecurity-2.9.1-3.2.39-201302252105.patch

	arch/mips/mm/mmap.c:152:29: error: 'vmm' undeclared (first use in
	this function)

3. include <linux/prefetch.h> explicitly, to avoid the compile error, because
prefetch funtion is not defined in <asm/processor.h> which is included by
sched.h indirectly. like on MIPS arch, when CPU_HAS_PREFETCH is disabled.

	grsecurity/gracl.c:215:3: error: implicit declaration of function
	'prefetch' [-Werror=implicit-function-declaration]

Signed-off-by: Roy.Li <rongqing.li@windriver.com>
---
 arch/mips/kernel/reset.c |    9 ++++++---
 arch/mips/mm/mmap.c      |    8 ++++----
 grsecurity/gracl.c       |    1 +
 3 files changed, 11 insertions(+), 7 deletions(-)

diff --git a/arch/mips/kernel/reset.c b/arch/mips/kernel/reset.c
index 07fc524..2b9fc67 100644
--- a/arch/mips/kernel/reset.c
+++ b/arch/mips/kernel/reset.c
@@ -25,20 +25,23 @@ void (*pm_power_off)(void);
 
 EXPORT_SYMBOL(pm_power_off);
 
-void machine_restart(char *command)
+void __noreturn machine_restart(char *command)
 {
 	if (_machine_restart)
 		_machine_restart(command);
+	while (1);
 }
 
-void machine_halt(void)
+void __noreturn machine_halt(void)
 {
 	if (_machine_halt)
 		_machine_halt();
+	while (1);
 }
 
-void machine_power_off(void)
+void __noreturn machine_power_off(void)
 {
 	if (pm_power_off)
 		pm_power_off();
+	while (1);
 }
diff --git a/arch/mips/mm/mmap.c b/arch/mips/mm/mmap.c
index 7d35bf8..a451234 100644
--- a/arch/mips/mm/mmap.c
+++ b/arch/mips/mm/mmap.c
@@ -107,7 +107,7 @@ static unsigned long arch_get_unmapped_area_common(struct file *filp,
 			addr = PAGE_ALIGN(addr);
 
 		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr && check_heap_stack_gap(vmm, addr, len))
+		if (TASK_SIZE - len >= addr && check_heap_stack_gap(vma, addr, len))
 			return addr;
 	}
 
@@ -122,7 +122,7 @@ static unsigned long arch_get_unmapped_area_common(struct file *filp,
 			/* At this point:  (!vma || addr < vma->vm_end). */
 			if (TASK_SIZE - len < addr)
 				return -ENOMEM;
-			if (check_heap_stack_gap(vmm, addr, len))
+			if (check_heap_stack_gap(vma, addr, len))
 				return addr;
 			addr = vma->vm_end;
 			if (do_color_align)
@@ -149,7 +149,7 @@ static unsigned long arch_get_unmapped_area_common(struct file *filp,
 		/* make sure it can fit in the remaining address space */
 		if (likely(addr > len)) {
 			vma = find_vma(mm, addr - len);
-			if (check_heap_stack_gap(vmm, addr - len, len))
+			if (check_heap_stack_gap(vma, addr - len, len)) {
 				/* cache the address as a hint for next time */
 				return mm->free_area_cache = addr - len;
 			}
@@ -169,7 +169,7 @@ static unsigned long arch_get_unmapped_area_common(struct file *filp,
 			 * return with success:
 			 */
 			vma = find_vma(mm, addr);
-			if (check_heap_stack_gap(vmm, addr, len)) {
+			if (check_heap_stack_gap(vma, addr, len)) {
 				/* cache the address as a hint for next time */
 				return mm->free_area_cache = addr;
 			}
diff --git a/grsecurity/gracl.c b/grsecurity/gracl.c
index 31c0077..9bbec09 100644
--- a/grsecurity/gracl.c
+++ b/grsecurity/gracl.c
@@ -22,6 +22,7 @@
 #include <linux/pid_namespace.h>
 #include <linux/fdtable.h>
 #include <linux/percpu.h>
+#include <linux/prefetch.h>
 #include "../fs/mount.h"
 
 #include <asm/uaccess.h>
-- 
1.7.5.4

