Allow write access to process vm.

CQID: WIND00121593

Based on the patch provided by Jason Wessel <jason.wessel@windriver.com>
to support kgdb access to process memory, this version will also use the
normal GRSecurity logging mechanism to report failed connect attempts.

Signed-off-by: Joe MacDonald <joe.macdonald@windriver.com>

---
 grsecurity/Kconfig    |    7 +++++++
 include/linux/grmsg.h |    1 +
 mm/memory.c           |   20 ++++++++++++++++++++
 3 files changed, 28 insertions(+), 0 deletions(-)

diff --git a/grsecurity/Kconfig b/grsecurity/Kconfig
index 8be9ab0..a0005d9 100644
--- a/grsecurity/Kconfig
+++ b/grsecurity/Kconfig
@@ -602,6 +602,13 @@ config GRKERNSEC_AUDIT_IPC
 	  and shared memory will be logged.  If the sysctl option is enabled, a
 	  sysctl option with name "audit_ipc" is created.
 
+config GRSEC_PROC_VM_ACCESS
+	bool "Allow debug access to process VM"
+	default n
+	help
+	  If you say Y here, processes will be allowed to access the VM of
+	  another process in order to support tools like userspace debuggers.
+
 config GRKERNSEC_SIGNAL
 	bool "Signal logging"
 	help
diff --git a/include/linux/grmsg.h b/include/linux/grmsg.h
index e230f65..a7b35d5 100644
--- a/include/linux/grmsg.h
+++ b/include/linux/grmsg.h
@@ -106,3 +106,4 @@
 #define GR_SHMR_AUDIT_MSG "shared memory of uid:%u euid:%u removed by "
 #define GR_RESOURCE_MSG "denied resource overstep by requesting %lu for %.16s against limit %lu for "
 #define GR_TEXTREL_AUDIT_MSG "text relocation in %s, VMA:0x%08lx 0x%08lx by "
+#define GR_ACCESS_PROC_VM_MSG "denied access to process memory "
diff --git a/mm/memory.c b/mm/memory.c
index da7c544..5a4626f 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -3291,6 +3291,26 @@ int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, in
 			 * Check if this is a VM_IO | VM_PFNMAP VMA, which
 			 * we can access using slightly different code.
 			 */
+#ifdef CONFIG_GRSEC_PROC_VM_ACCESS
+			if (write) {
+				struct vm_area_struct *tvma, *prev;
+				int sv = ret;
+
+				ret = get_user_pages(tsk, mm, addr, 1,
+						     0, 1, &page, &vma);
+				if (ret <= 0)
+					break;
+
+				tvma = find_vma_prev(mm, addr, &prev);
+				if (!(tvma->vm_flags & (VM_MAYWRITE | VM_WRITE))) {
+					tvma->vm_flags |= VM_MAYWRITE;
+					if (mprotect_fixup(vma, &prev, addr, vma->vm_end,
+							   tvma->vm_flags))
+						gr_log_int(GR_DONT_AUDIT, GR_ACCESS_PROC_VM_MSG, error);
+				}
+				ret = sv;
+			}
+#endif
 #ifdef CONFIG_HAVE_IOREMAP_PROT
 			vma = find_vma(mm, addr);
 			if (!vma)
