From b6c20ababdbd805af149fc6ec530810d3bdfc3c4 Mon Sep 17 00:00:00 2001
From: Michael Spang <Michael.Spang@windriver.com>
Date: Wed, 22 Apr 2009 21:30:42 -0400
Subject: [PATCH] PaX: Fix sporadic death of new children by SIGILL

Fix extracted from:
http://www.grsecurity.net/~paxguy1/pax-linux-2.6.29.1-test8.patch

Due to a bug in the page-based no-execute protection feature of PaX,
the child process of a fork() call may die immediately if a rare set
of events occur:

1. The parent process is descheduled on CPU A during execv().
2. The idle process is scheduled on CPU A.
3. The parent process is scheduled on CPU B and continues execv().
4. The parent changes its memory map as part of execv(), and
   raises its user code segment limit to suit the new mapping.
4. The parent process calls fork().
5. The new child is scheduled on CPU A. As CPU A still has
   the old code segment limit, a GPF occurs and it crashes.

It must be the case that the only intervening process on CPU A between
the parent and child is the system idle process. Because the idle
process has no memory mapping of its own, the active mapping on CPU A
is still the parent's mapping. The updated limit is reflected in this
mapping, but the GDT on CPU A was never updated.

When the child is scheduled on CPU A, PaX checks to see if the GDT
needs to be updated. PaX compares the child's desired limit with the
limit in current->mm, which is the parent's new limit. They compare
equal, so the GDT is not updated. The child then begins executing with
the old, incorrect limit in the GDT.

This patch changes the code to always reset the segment limit in the
GDT whenever leaving a process with no memory mapping ("lazy TLB
mode"). It was written by the PaX maintainer and should be in the next
release.

This bug only affects x86-32, and is much more likely if glibc is
prelinked (in fact, it has not been observed otherwise).

Signed-off-by: Michael Spang <Michael.Spang@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 include/asm-x86/mmu_context_32.h |    9 ++++++++-
 1 files changed, 8 insertions(+), 1 deletions(-)

diff --git a/include/asm-x86/mmu_context_32.h b/include/asm-x86/mmu_context_32.h
index e95c922..81a158d 100644
--- a/include/asm-x86/mmu_context_32.h
+++ b/include/asm-x86/mmu_context_32.h
@@ -15,11 +15,17 @@ static inline void switch_mm(struct mm_struct *prev,
 			     struct task_struct *tsk)
 {
 	int cpu = smp_processor_id();
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	int tlbstate = TLBSTATE_OK;
+#endif
 
 	if (likely(prev != next)) {
 		/* stop flush ipis for the previous mm */
 		cpu_clear(cpu, prev->cpu_vm_mask);
 #ifdef CONFIG_SMP
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		tlbstate = x86_read_percpu(cpu_tlbstate.state);
+#endif
 		per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;
 		per_cpu(cpu_tlbstate, cpu).active_mm = next;
 #endif
@@ -45,7 +51,8 @@ static inline void switch_mm(struct mm_struct *prev,
 
 #if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
 		if (unlikely(prev->context.user_cs_base != next->context.user_cs_base ||
-			     prev->context.user_cs_limit != next->context.user_cs_limit))
+			     prev->context.user_cs_limit != next->context.user_cs_limit ||
+			     tlbstate != TLBSTATE_OK))
 			set_user_cs(next->context.user_cs_base, next->context.user_cs_limit, cpu);
 #endif
 
-- 
1.6.0.4

