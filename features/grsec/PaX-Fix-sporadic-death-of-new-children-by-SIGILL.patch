From 8213aa75a01bb03c9a88fc9aa95a71712f029c1a Mon Sep 17 00:00:00 2001
From: Michael Spang <Michael.Spang@windriver.com>
Date: Wed, 22 Apr 2009 21:30:42 -0400
Subject: [PATCH] PaX: Fix sporadic death of new children by SIGILL

Fix extracted from:
http://www.grsecurity.net/~paxguy1/pax-linux-2.6.29.1-test8.patch

Due to a bug in the page-based no-execute protection feature of PaX,
the child process of a fork() call may die immediately if a rare set
of events occur:

1. The parent process is descheduled on CPU A during execv().
2. The idle process is scheduled on CPU A.
3. The parent process is scheduled on CPU B and continues execv().
4. The parent changes its memory map as part of execv(), and
   raises its user code segment limit to suit the new mapping.
4. The parent process calls fork().
5. The new child is scheduled on CPU A. As CPU A still has
   the old code segment limit, a GPF occurs and it crashes.

It must be the case that the only intervening process on CPU A between
the parent and child is the system idle process. Because the idle
process has no memory mapping of its own, the active mapping on CPU A
is still the parent's mapping. The updated limit is reflected in this
mapping, but the GDT on CPU A was never updated.

When the child is scheduled on CPU A, PaX checks to see if the GDT
needs to be updated. PaX compares the child's desired limit with the
limit in current->mm, which is the parent's new limit. They compare
equal, so the GDT is not updated. The child then begins executing with
the old, incorrect limit in the GDT.

This patch changes the code to always reset the segment limit in the
GDT whenever leaving a process with no memory mapping ("lazy TLB
mode"). It was written by the PaX maintainer and should be in the next
release.

This bug only affects x86-32, and is much more likely if glibc is
prelinked (in fact, it has not been observed otherwise).

Signed-off-by: Michael Spang <Michael.Spang@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 include/asm-x86/mmu_context_32.h |    9 ++++++++-
 include/asm-x86/tlbflush.h       |    6 +++---
 2 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/include/asm-x86/mmu_context_32.h b/include/asm-x86/mmu_context_32.h
index 588cd79..02190be 100644
--- a/include/asm-x86/mmu_context_32.h
+++ b/include/asm-x86/mmu_context_32.h
@@ -15,6 +15,9 @@ static inline void switch_mm(struct mm_struct *prev,
 			     struct task_struct *tsk)
 {
 	int cpu = smp_processor_id();
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	int tlbstate = TLBSTATE_OK;
+#endif
 
 	if (likely(prev != next)) {
 		/* stop flush ipis for the previous mm */
@@ -22,6 +25,9 @@ static inline void switch_mm(struct mm_struct *prev,
 		cpu_clear(cpu, prev->cpu_vm_mask);
 #endif
 #ifdef CONFIG_SMP
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		tlbstate = x86_read_percpu(cpu_tlbstate.state);
+#endif
 		per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;
 		per_cpu(cpu_tlbstate, cpu).active_mm = next;
 #endif
@@ -47,7 +53,8 @@ static inline void switch_mm(struct mm_struct *prev,
 
 #if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
 		if (unlikely(prev->context.user_cs_base != next->context.user_cs_base ||
-			     prev->context.user_cs_limit != next->context.user_cs_limit))
+			     prev->context.user_cs_limit != next->context.user_cs_limit ||
+			     tlbstate != TLBSTATE_OK))
 			set_user_cs(next->context.user_cs_base, next->context.user_cs_limit, cpu);
 #endif
 
diff --git a/include/asm-x86/tlbflush.h b/include/asm-x86/tlbflush.h
index 35c76ce..6ddddc3 100644
--- a/include/asm-x86/tlbflush.h
+++ b/include/asm-x86/tlbflush.h
@@ -87,6 +87,9 @@ static inline void __flush_tlb_one(unsigned long addr)
  * range a few INVLPGs in a row are a win.
  */
 
+#define TLBSTATE_OK	1
+#define TLBSTATE_LAZY	2
+
 #ifndef CONFIG_SMP
 
 #define flush_tlb() __flush_tlb()
@@ -141,9 +144,6 @@ static inline void flush_tlb_range(struct vm_area_struct *vma,
 void native_flush_tlb_others(const cpumask_t *cpumask, struct mm_struct *mm,
 			     unsigned long va);
 
-#define TLBSTATE_OK	1
-#define TLBSTATE_LAZY	2
-
 #ifdef CONFIG_X86_32
 struct tlb_state {
 	struct mm_struct *active_mm;
-- 
1.7.0

