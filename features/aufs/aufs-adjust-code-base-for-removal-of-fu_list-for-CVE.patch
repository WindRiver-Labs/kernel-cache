From 42822809fc2aae48315b780d47f343fade43d31f Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 7 Apr 2015 19:54:34 -0400
Subject: [PATCH 3/3] aufs: adjust code base for removal of fu_list for CVE
 backport

As a part of a seurity fix, we've backported the commit "get rid of s_files
and files_lock" [eee5cc2702929fd41cce28058dc6d6717f723f87 upstream]

As a part of that commit, the function do_file_list_for_each_entry() and
similar are removed, as they used to iterate over the now dead fu_list.

The aufs code had its own copy of the same function and it will break for
the same reason -- trying to access a now non-existent field.

To avoid this, we look ahead to the 3.14 based aufs codebase that is
found in git://github.com/sfjro/aufs3-linux.git and update the code to
match the functions that used to use do_file_list_for_each_entry.

This entails some subsequent related changes, like those related to
fi_hlist, fi_file and si_files variable handling, but remains reasonably
contained notwithstanding.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 fs/aufs/branch.c | 15 +++++++++------
 fs/aufs/dir.c    |  2 ++
 fs/aufs/f_op.c   |  2 ++
 fs/aufs/file.c   |  8 ++++++++
 fs/aufs/file.h   |  2 ++
 fs/aufs/sbinfo.c |  2 ++
 fs/aufs/super.h  |  3 +++
 fs/aufs/sysrq.c  | 13 ++++++++-----
 fs/aufs/vfsub.h  | 31 -------------------------------
 9 files changed, 36 insertions(+), 42 deletions(-)

diff --git a/fs/aufs/branch.c b/fs/aufs/branch.c
index 581980946d01..d742ed9c80bf 100644
--- a/fs/aufs/branch.c
+++ b/fs/aufs/branch.c
@@ -1005,22 +1005,25 @@ static unsigned long long au_farray_cb(void *a,
 {
 	unsigned long long n;
 	struct file **p, *f;
+	struct au_sphlhead *files;
+	struct au_finfo *finfo;
 	struct super_block *sb = arg;
 
 	n = 0;
 	p = a;
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (au_fi(f)
-		    && file_count(f)
+	files = &au_sbi(sb)->si_files;
+	spin_lock(&files->spin);
+	hlist_for_each_entry(finfo, &files->head, fi_hlist) {
+		f = finfo->fi_file;
+		if (file_count(f)
 		    && !special_file(file_inode(f)->i_mode)) {
 			get_file(f);
 			*p++ = f;
 			n++;
 			AuDebugOn(n > max);
 		}
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
+	}
+	spin_unlock(&files->spin);
 
 	return n;
 }
diff --git a/fs/aufs/dir.c b/fs/aufs/dir.c
index 568ea0a3bec9..28e6d5c8d41d 100644
--- a/fs/aufs/dir.c
+++ b/fs/aufs/dir.c
@@ -222,6 +222,8 @@ static int aufs_release_dir(struct inode *inode __maybe_unused,
 	finfo = au_fi(file);
 	fidir = finfo->fi_hdir;
 	if (fidir) {
+		au_sphl_del(&finfo->fi_hlist,
+			    &au_sbi(file->f_dentry->d_sb)->si_files);
 		vdir_cache = fidir->fd_vdir_cache; /* lock-free */
 		if (vdir_cache)
 			au_vdir_free(vdir_cache);
diff --git a/fs/aufs/f_op.c b/fs/aufs/f_op.c
index 400a0cd3a1d6..573a53809e20 100644
--- a/fs/aufs/f_op.c
+++ b/fs/aufs/f_op.c
@@ -83,6 +83,8 @@ int aufs_release_nondir(struct inode *inode __maybe_unused, struct file *file)
 	aufs_bindex_t bindex;
 
 	finfo = au_fi(file);
+	au_sphl_del(&finfo->fi_hlist, &au_sbi(file->f_dentry->d_sb)->si_files);
+
 	bindex = finfo->fi_btop;
 	if (bindex >= 0)
 		au_set_h_fptr(file, bindex, NULL);
diff --git a/fs/aufs/file.c b/fs/aufs/file.c
index 32b735d356fe..f0d7e99c9d35 100644
--- a/fs/aufs/file.c
+++ b/fs/aufs/file.c
@@ -114,6 +114,7 @@ int au_do_open(struct file *file, int (*open)(struct file *file, int flags),
 {
 	int err;
 	struct dentry *dentry;
+	struct au_finfo *finfo;
 
 	err = au_finfo_init(file, fidir);
 	if (unlikely(err))
@@ -124,6 +125,13 @@ int au_do_open(struct file *file, int (*open)(struct file *file, int flags),
 	err = open(file, vfsub_file_flags(file));
 	di_read_unlock(dentry, AuLock_IR);
 
+	finfo = au_fi(file);
+	if (!err) {
+		finfo->fi_file = file;
+		au_sphl_add(&finfo->fi_hlist,
+			    &au_sbi(file->f_dentry->d_sb)->si_files);
+	}
+
 	fi_write_unlock(file);
 	if (unlikely(err)) {
 		au_fi(file)->fi_hdir = NULL;
diff --git a/fs/aufs/file.h b/fs/aufs/file.h
index 28ff3f3c0c48..02d5e864da04 100644
--- a/fs/aufs/file.h
+++ b/fs/aufs/file.h
@@ -62,6 +62,8 @@ struct au_finfo {
 		atomic_t			fi_mmapped;
 	};
 	struct au_fidir		*fi_hdir;	/* for dir only */
+	struct hlist_node	fi_hlist;
+	struct file		*fi_file;	/* very ugly */
 } ____cacheline_aligned_in_smp;
 
 /* ---------------------------------------------------------------------- */
diff --git a/fs/aufs/sbinfo.c b/fs/aufs/sbinfo.c
index e07fc30a92ed..33d4bdddf810 100644
--- a/fs/aufs/sbinfo.c
+++ b/fs/aufs/sbinfo.c
@@ -113,6 +113,8 @@ int au_si_alloc(struct super_block *sb)
 	init_waitqueue_head(&sbinfo->si_plink_wq);
 	spin_lock_init(&sbinfo->si_plink_maint_lock);
 
+	au_sphl_init(&sbinfo->si_files);
+
 	/* leave other members for sysaufs and si_mnt. */
 	sbinfo->si_sb = sb;
 	sb->s_fs_info = sbinfo;
diff --git a/fs/aufs/super.h b/fs/aufs/super.h
index 5d9cfb3ee6a6..993141001529 100644
--- a/fs/aufs/super.h
+++ b/fs/aufs/super.h
@@ -164,6 +164,9 @@ struct au_sbinfo {
 	spinlock_t		si_plink_maint_lock;
 	pid_t			si_plink_maint_pid;
 
+	/* file list */
+	struct au_sphlhead	si_files;
+
 	/*
 	 * sysfs and lifetime management.
 	 * this is not a small structure and it may be a waste of memory in case
diff --git a/fs/aufs/sysrq.c b/fs/aufs/sysrq.c
index 4d770ad1bbc7..17d5709ed2e9 100644
--- a/fs/aufs/sysrq.c
+++ b/fs/aufs/sysrq.c
@@ -86,14 +86,17 @@ static void sysrq_sb(struct super_block *sb)
 	}
 #endif
 	pr("files\n");
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, file) {
+	files = &au_sbi(sb)->si_files;
+	spin_lock(&files->spin);
+	hlist_for_each_entry(finfo, &files->head, fi_hlist) {
 		umode_t mode;
+
+		file = finfo->fi_file;
 		mode = file_inode(file)->i_mode;
-		if (!special_file(mode) || au_special_file(mode))
+		if (!special_file(mode))
 			au_dpri_file(file);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
+	}
+	spin_unlock(&files->spin);
 	pr("done\n");
 
 #undef pr
diff --git a/fs/aufs/vfsub.h b/fs/aufs/vfsub.h
index 5a50a62da96f..183e872faf34 100644
--- a/fs/aufs/vfsub.h
+++ b/fs/aufs/vfsub.h
@@ -36,37 +36,6 @@ extern struct lglock vfsmount_lock;
 extern void __mnt_drop_write(struct vfsmount *);
 extern spinlock_t inode_sb_list_lock;
 
-/* copied from linux/fs/file_table.c */
-extern struct lglock files_lglock;
-#ifdef CONFIG_SMP
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-#endif
-
 /* ---------------------------------------------------------------------- */
 
 /* lock subclass for lower inode */
-- 
2.1.0

