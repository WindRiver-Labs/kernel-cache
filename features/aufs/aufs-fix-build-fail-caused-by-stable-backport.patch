From 0fb6c1c3161f181d2a2d2b2f16a95935756a7d73 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Wed, 29 Apr 2015 15:20:49 -0400
Subject: [PATCH] aufs: fix build fail caused by stable backport.

Stable 3.14.40 brings in this:

commit 5c48ea64a86415fde0859267a194442d26d2e70c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 26 19:19:16 2014 -0400

    move d_rcu from overlapping d_child to overlapping d_alias

    commit 946e51f2bf37f1656916eb75bd0742ba33983c28 upstream.

..but since aufs is out of tree, it didn't get updated accordingly, and
hence compile fails on invalid references to d_child etc.

Update it in the manner that all the rest of the filesystem types were.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/fs/aufs/dcsub.c b/fs/aufs/dcsub.c
index 9fbc218ff113..04663e50b627 100644
--- a/fs/aufs/dcsub.c
+++ b/fs/aufs/dcsub.c
@@ -134,7 +134,7 @@ resume:
 	while (next != &this_parent->d_subdirs) {
 		struct list_head *tmp = next;
 		struct dentry *dentry = list_entry(tmp, struct dentry,
-						   d_u.d_child);
+						   d_child);
 
 		next = tmp->next;
 		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
@@ -170,7 +170,7 @@ resume:
 		this_parent = tmp;
 		spin_lock(&this_parent->d_lock);
 		rcu_read_unlock();
-		next = child->d_u.d_child.next;
+		next = child->d_child.next;
 		goto resume;
 	}
 
diff --git a/fs/aufs/debug.c b/fs/aufs/debug.c
index e3ee24d7fcbd..563bac0fa56f 100644
--- a/fs/aufs/debug.c
+++ b/fs/aufs/debug.c
@@ -169,7 +169,7 @@ void au_dpri_dalias(struct inode *inode)
 	struct dentry *d;
 
 	spin_lock(&inode->i_lock);
-	hlist_for_each_entry(d, &inode->i_dentry, d_alias)
+	hlist_for_each_entry(d, &inode->i_dentry, d_u.d_alias)
 		au_dpri_dentry(d);
 	spin_unlock(&inode->i_lock);
 }
diff --git a/fs/aufs/export.c b/fs/aufs/export.c
index 32df1ede980f..864ec30a3583 100644
--- a/fs/aufs/export.c
+++ b/fs/aufs/export.c
@@ -243,7 +243,7 @@ static struct dentry *decode_by_ino(struct super_block *sb, ino_t ino,
 		dentry = d_find_alias(inode);
 	else {
 		spin_lock(&inode->i_lock);
-		hlist_for_each_entry(d, &inode->i_dentry, d_alias) {
+		hlist_for_each_entry(d, &inode->i_dentry, d_u.d_alias) {
 			spin_lock(&d->d_lock);
 			if (!au_test_anon(d)
 			    && d->d_parent->d_inode->i_ino == dir_ino) {
diff --git a/fs/aufs/hnotify.c b/fs/aufs/hnotify.c
index 40d601d15925..81c9ef7e6081 100644
--- a/fs/aufs/hnotify.c
+++ b/fs/aufs/hnotify.c
@@ -211,7 +211,7 @@ static int hn_gen_by_inode(char *name, unsigned int nlen, struct inode *inode,
 		AuDebugOn(!name);
 		au_iigen_dec(inode);
 		spin_lock(&inode->i_lock);
-		hlist_for_each_entry(d, &inode->i_dentry, d_alias) {
+		hlist_for_each_entry(d, &inode->i_dentry, d_u.d_alias) {
 			spin_lock(&d->d_lock);
 			dname = &d->d_name;
 			if (dname->len != nlen
@@ -378,7 +378,7 @@ static struct dentry *lookup_wlock_by_name(char *name, unsigned int nlen,
 
 	dentry = NULL;
 	spin_lock(&parent->d_lock);
-	list_for_each_entry(d, &parent->d_subdirs, d_u.d_child) {
+	list_for_each_entry(d, &parent->d_subdirs, d_child) {
 		/* AuDbg("%pd\n", d); */
 		spin_lock_nested(&d->d_lock, DENTRY_D_LOCK_NESTED);
 		dname = &d->d_name;
-- 
2.3.4

