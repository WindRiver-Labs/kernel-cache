From f5417694ba8acfc2da0f1537bc142b07f8f77020 Mon Sep 17 00:00:00 2001
From: Zhixiong Chi <Zhixiong.Chi@windriver.com>
Date: Thu, 16 Jun 2016 14:26:26 +0800
Subject: [PATCH 2/2] aufs: convert inode_sb_list_lock to per-sb

kernel commit 'inode: convert inode_sb_list_lock to per-sb' modified
inode locking, so we update aufs to this new format.

Signed-off-by: Zhixiong Chi <Zhixiong.Chi@windriver.com>
---
 fs/aufs/branch.c |    4 ++--
 fs/aufs/super.c  |   13 +++++++------
 fs/aufs/super.h  |    7 ++++---
 fs/aufs/sysrq.c  |    4 ++--
 fs/aufs/vfsub.h  |    1 -
 fs/inode.c       |    3 ---
 6 files changed, 15 insertions(+), 17 deletions(-)

diff --git a/fs/aufs/branch.c b/fs/aufs/branch.c
index 2ec4964..92701dd 100644
--- a/fs/aufs/branch.c
+++ b/fs/aufs/branch.c
@@ -587,7 +587,7 @@ static struct file **au_farray_alloc(struct super_block *sb,
 				     unsigned long long *max)
 {
 	*max = atomic_long_read(&au_sbi(sb)->si_nfiles);
-	return au_array_alloc(max, au_farray_cb, sb);
+	return au_array_alloc(max, au_farray_cb, sb, /*arg*/NULL);
 }
 
 static void au_farray_free(struct file **a, unsigned long long max)
@@ -1031,7 +1031,7 @@ int au_br_del(struct super_block *sb, struct au_opt_del *del, int remount)
 	br_id = br->br_id;
 	opened = atomic_read(&br->br_count);
 	if (unlikely(opened)) {
-		to_free = au_array_alloc(&opened, empty_cb, NULL);
+		to_free = au_array_alloc(&opened, empty_cb, sb, NULL);
 		err = PTR_ERR(to_free);
 		if (IS_ERR(to_free))
 			goto out;
diff --git a/fs/aufs/super.c b/fs/aufs/super.c
index 6b7f38e..6b89c84 100644
--- a/fs/aufs/super.c
+++ b/fs/aufs/super.c
@@ -479,7 +479,8 @@ void au_array_free(void *array)
 	}
 }
 
-void *au_array_alloc(unsigned long long *hint, au_arraycb_t cb, void *arg)
+void *au_array_alloc(unsigned long long *hint, au_arraycb_t cb,
+		     struct super_block *sb, void *arg)
 {
 	void *array;
 	unsigned long long n, sz;
@@ -504,7 +505,7 @@ void *au_array_alloc(unsigned long long *hint, au_arraycb_t cb, void *arg)
 		goto out;
 	}
 
-	n = cb(array, *hint, arg);
+	n = cb(sb, array, *hint, arg);
 	AuDebugOn(n > *hint);
 
 out:
@@ -512,7 +513,7 @@ out:
 	return array;
 }
 
-static unsigned long long au_iarray_cb(void *a,
+static unsigned long long au_iarray_cb(struct super_block *sb, void *a,
 				       unsigned long long max __maybe_unused,
 				       void *arg)
 {
@@ -523,7 +524,7 @@ static unsigned long long au_iarray_cb(void *a,
 	n = 0;
 	p = a;
 	head = arg;
-	spin_lock(&inode_sb_list_lock);
+	spin_lock(&sb->s_inode_list_lock);
 	list_for_each_entry(inode, head, i_sb_list) {
 		if (!is_bad_inode(inode)
 		    && au_ii(inode)->ii_bstart >= 0) {
@@ -537,7 +538,7 @@ static unsigned long long au_iarray_cb(void *a,
 			spin_unlock(&inode->i_lock);
 		}
 	}
-	spin_unlock(&inode_sb_list_lock);
+	spin_unlock(&sb->s_inode_list_lock);
 
 	return n;
 }
@@ -545,7 +546,7 @@ static unsigned long long au_iarray_cb(void *a,
 struct inode **au_iarray_alloc(struct super_block *sb, unsigned long long *max)
 {
 	*max = atomic_long_read(&au_sbi(sb)->si_ninodes);
-	return au_array_alloc(max, au_iarray_cb, &sb->s_inodes);
+	return au_array_alloc(max, au_iarray_cb, sb, &sb->s_inodes);
 }
 
 void au_iarray_free(struct inode **a, unsigned long long max)
diff --git a/fs/aufs/super.h b/fs/aufs/super.h
index 95ffbbb..72b3313 100644
--- a/fs/aufs/super.h
+++ b/fs/aufs/super.h
@@ -271,10 +271,11 @@ static inline unsigned char au_do_ftest_si(struct au_sbinfo *sbi,
 /* super.c */
 extern struct file_system_type aufs_fs_type;
 struct inode *au_iget_locked(struct super_block *sb, ino_t ino);
-typedef unsigned long long (*au_arraycb_t)(void *array, unsigned long long max,
-					   void *arg);
+typedef unsigned long long (*au_arraycb_t)(struct super_block *sb, void *array,
+					   unsigned long long max, void *arg);
 void au_array_free(void *array);
-void *au_array_alloc(unsigned long long *hint, au_arraycb_t cb, void *arg);
+void *au_array_alloc(unsigned long long *hint, au_arraycb_t cb,
+		     struct super_block *sb, void *arg);
 struct inode **au_iarray_alloc(struct super_block *sb, unsigned long long *max);
 void au_iarray_free(struct inode **a, unsigned long long max);
 
diff --git a/fs/aufs/sysrq.c b/fs/aufs/sysrq.c
index a3e95bc..67ac9ba 100644
--- a/fs/aufs/sysrq.c
+++ b/fs/aufs/sysrq.c
@@ -77,14 +77,14 @@ static void sysrq_sb(struct super_block *sb)
 		struct inode *i;
 
 		pr("isolated inode\n");
-		spin_lock(&inode_sb_list_lock);
+		spin_lock(&sb->s_inode_list_lock);
 		list_for_each_entry(i, &sb->s_inodes, i_sb_list) {
 			spin_lock(&i->i_lock);
 			if (1 || hlist_empty(&i->i_dentry))
 				au_dpri_inode(i);
 			spin_unlock(&i->i_lock);
 		}
-		spin_unlock(&inode_sb_list_lock);
+		spin_unlock(&sb->s_inode_list_lock);
 	}
 #endif
 	pr("files\n");
diff --git a/fs/aufs/vfsub.h b/fs/aufs/vfsub.h
index 5c89f8e..ca86c3d 100644
--- a/fs/aufs/vfsub.h
+++ b/fs/aufs/vfsub.h
@@ -32,7 +32,6 @@
 /* copied from linux/fs/internal.h */
 /* todo: BAD approach!! */
 extern void __mnt_drop_write(struct vfsmount *);
-extern spinlock_t inode_sb_list_lock;
 extern int open_check_o_direct(struct file *f);
 
 /* ---------------------------------------------------------------------- */
diff --git a/fs/inode.c b/fs/inode.c
index b0f7612..9367e11 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -57,9 +57,6 @@ static unsigned int i_hash_shift __read_mostly;
 static struct hlist_head *inode_hashtable __read_mostly;
 static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);
 
-__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);
-EXPORT_SYMBOL(inode_sb_list_lock);
-
 /*
  * Empty aops. Can be used for the cases where the user does not
  * define any of the address_space operations.
-- 
1.7.5.4

