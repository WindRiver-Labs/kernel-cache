From 920f8321ac242ba2fd38293fc4a499a5a9c570f5 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Fri, 11 Jul 2014 15:40:41 -0400
Subject: [PATCH] aufs: Adapt debugging code for RT_FULL and no wait_list
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Per the comment in the -rt patches:

 * Note that the semantics are different from the usual
 * Linux rw-sems, in PREEMPT_RT mode we do not allow
 * multiple readers to hold the lock at once, we only allow
 * a read-lock owner to read-lock recursively. This is
 * better for latency, makes the implementation inherently
 * fair and makes it simpler as well.

Hence there is no wait list, and we get build fails like:

fs/aufs/super.c: In function ‘au_remount_refresh’:
fs/aufs/rwsem.h:58:65: error: ‘struct rw_semaphore’ has no member named ‘wait_list’
 #define AuRwMustNoWaiters(rw) AuDebugOn(!list_empty(&(rw)->rwsem.wait_list))
                                                                 ^
Adapt the debug function to be a no-op when RT means there is
no wait lists.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/fs/aufs/rwsem.h b/fs/aufs/rwsem.h
index 0704b079d17b..e7994c52242c 100644
--- a/fs/aufs/rwsem.h
+++ b/fs/aufs/rwsem.h
@@ -54,7 +54,11 @@ struct au_rwsem {
 #endif /* CONFIG_AUFS_DEBUG */
 
 /* to debug easier, do not make them inlined functions */
+#ifndef CONFIG_PREEMPT_RT_FULL
 #define AuRwMustNoWaiters(rw)	AuDebugOn(!list_empty(&(rw)->rwsem.wait_list))
+#else
+#define AuRwMustNoWaiters(rw)	do {} while (0)
+#endif
 /* rwsem_is_locked() is unusable */
 #define AuRwMustReadLock(rw)	AuDebugOn(atomic_read(&(rw)->rcnt) <= 0)
 #define AuRwMustWriteLock(rw)	AuDebugOn(atomic_read(&(rw)->wcnt) <= 0)
-- 
2.1.2

