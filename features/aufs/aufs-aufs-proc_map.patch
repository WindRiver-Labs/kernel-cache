From b1da74c5f2447471422a1a34ba748d0236990a05 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 10 Mar 2014 11:11:41 -0700
Subject: [PATCH 3/5] aufs: aufs proc_map

Integrating aufs-kbuild patch from:

    git://git.code.sf.net/p/aufs/aufs3-standalone aufs3.10

Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
[Fix context conflict with grsec]
Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 fs/buffer.c              |    2 ++
 fs/proc/nommu.c          |    4 ++++
 fs/proc/task_mmu.c       |    6 ++++++
 fs/proc/task_nommu.c     |    4 ++++
 include/linux/mm_types.h |    2 ++
 kernel/fork.c            |    2 ++
 mm/memory.c              |    2 ++
 mm/mmap.c                |   10 ++++++++++
 mm/nommu.c               |   10 ++++++++++
 9 files changed, 42 insertions(+)

diff --git a/fs/buffer.c b/fs/buffer.c
index df798ca..64657c7 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2388,6 +2388,8 @@ int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
 	 * fault so this update may be superfluous but who really cares...
 	 */
 	file_update_time(vma->vm_file);
+	if (vma->vm_prfile)
+		file_update_time(vma->vm_prfile);
 
 	ret = __block_page_mkwrite(vma, vmf, get_block);
 	sb_end_pagefault(sb);
diff --git a/fs/proc/nommu.c b/fs/proc/nommu.c
index 1b7e255..6a7021e 100644
--- a/fs/proc/nommu.c
+++ b/fs/proc/nommu.c
@@ -46,6 +46,10 @@ static int nommu_region_show(struct seq_file *m, struct vm_region *region)
 
 	if (file) {
 		struct inode *inode = file_inode(region->vm_file);
+		if (region->vm_prfile) {
+			file = region->vm_prfile;
+			inode = file_inode(file);
+		}
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 	}
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 350cc48..ee0efdb 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -296,6 +296,10 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
+		if (vma->vm_prfile) {
+			file = vma->vm_prfile;
+			inode = file_inode(file);
+		}
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
@@ -1347,6 +1351,8 @@ static int show_numa_map(struct seq_file *m, void *v, int is_pid)
 
 	if (file) {
 		seq_printf(m, " file=");
+		if (vma->vm_prfile)
+			file = vma->vm_prfile;
 		seq_path(m, &file->f_path, "\n\t\\= ");
 	} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {
 		seq_printf(m, " heap");
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index 5a2f6ec..f29deaf 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -150,6 +150,10 @@ static int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,
 
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
+		if (vma->vm_prfile) {
+			file = vma->vm_prfile;
+			inode = file_inode(file);
+		}
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 22ec569..92c4148 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -213,6 +213,7 @@ struct vm_region {
 	unsigned long	vm_top;		/* region allocated to here */
 	unsigned long	vm_pgoff;	/* the offset in vm_file corresponding to vm_start */
 	struct file	*vm_file;	/* the backing file or NULL */
+	struct file	*vm_prfile;	/* the virtual backing file or NULL */
 
 	int		vm_usage;	/* region usage count (access under nommu_region_sem) */
 	bool		vm_icache_flushed : 1; /* true if the icache has been flushed for
@@ -281,6 +282,7 @@ struct vm_area_struct {
 	unsigned long vm_pgoff;		/* Offset (within vm_file) in PAGE_SIZE
 					   units, *not* PAGE_CACHE_SIZE */
 	struct file * vm_file;		/* File we map to (can be NULL). */
+	struct file *vm_prfile;		/* shadow of vm_file */
 	void * vm_private_data;		/* was vm_pte (shared mem) */
 
 #ifndef CONFIG_MMU
diff --git a/kernel/fork.c b/kernel/fork.c
index c27d611..4907191 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -381,6 +381,8 @@ static struct vm_area_struct *dup_vma(struct mm_struct *mm, struct mm_struct *ol
 		struct address_space *mapping = file->f_mapping;
 
 		get_file(file);
+		if (tmp->vm_prfile)
+			get_file(tmp->vm_prfile);
 		if (tmp->vm_flags & VM_DENYWRITE)
 			atomic_dec(&inode->i_writecount);
 		mutex_lock(&mapping->i_mmap_mutex);
diff --git a/mm/memory.c b/mm/memory.c
index 80b1cba..c661554 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -3664,6 +3664,8 @@ static int __do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 		/* file_update_time outside page_lock */
 		if (vma->vm_file && !page_mkwrite)
 			file_update_time(vma->vm_file);
+		if (vma->vm_prfile && !page_mkwrite)
+			file_update_time(vma->vm_prfile);
 	} else {
 		unlock_page(vmf.page);
 		if (anon)
diff --git a/mm/mmap.c b/mm/mmap.c
index fa87333..e2332c5 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -273,6 +273,8 @@ static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file)
 		fput(vma->vm_file);
+	if (vma->vm_prfile)
+		fput(vma->vm_prfile);
 	mpol_put(vma_policy(vma));
 	kmem_cache_free(vm_area_cachep, vma);
 	return next;
@@ -884,6 +886,8 @@ again:			remove_next = 1 + (end > next->vm_end);
 		if (file) {
 			uprobe_munmap(next, next->vm_start, next->vm_end);
 			fput(file);
+			if (vma->vm_prfile)
+				fput(vma->vm_prfile);
 		}
 		if (next->anon_vma)
 			anon_vma_merge(vma, next);
@@ -2859,6 +2863,8 @@ static int __split_vma(struct mm_struct * mm, struct vm_area_struct * vma,
 
 	if (new->vm_file)
 		get_file(new->vm_file);
+	if (new->vm_prfile)
+		get_file(new->vm_prfile);
 
 	if (new->vm_ops && new->vm_ops->open)
 		new->vm_ops->open(new);
@@ -2908,6 +2914,8 @@ static int __split_vma(struct mm_struct * mm, struct vm_area_struct * vma,
 		new->vm_ops->close(new);
 	if (new->vm_file)
 		fput(new->vm_file);
+	if (new->vm_prfile)
+		fput(new->vm_prfile);
  out_free_mpol:
 	mpol_put(pol);
  out_free_vma:
@@ -3381,6 +3389,8 @@ struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,
 				goto out_free_mempol;
 			if (new_vma->vm_file)
 				get_file(new_vma->vm_file);
+			if (new_vma->vm_prfile)
+				get_file(new_vma->vm_prfile);
 			if (new_vma->vm_ops && new_vma->vm_ops->open)
 				new_vma->vm_ops->open(new_vma);
 			vma_link(mm, new_vma, prev, rb_link, rb_parent);
diff --git a/mm/nommu.c b/mm/nommu.c
index 5f74980..0b67f38 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -650,6 +650,8 @@ static void __put_nommu_region(struct vm_region *region)
 
 		if (region->vm_file)
 			fput(region->vm_file);
+		if (region->vm_prfile)
+			fput(region->vm_prfile);
 
 		/* IO memory and memory shared directly out of the pagecache
 		 * from ramfs/tmpfs mustn't be released here */
@@ -808,6 +810,8 @@ static void delete_vma(struct mm_struct *mm, struct vm_area_struct *vma)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file)
 		fput(vma->vm_file);
+	if (vma->vm_prfile)
+		fput(vma->vm_prfile);
 	put_nommu_region(vma->vm_region);
 	kmem_cache_free(vm_area_cachep, vma);
 }
@@ -1365,6 +1369,8 @@ unsigned long do_mmap_pgoff(struct file *file,
 				}
 			}
 			fput(region->vm_file);
+			if (region->vm_prfile)
+				fput(region->vm_prfile);
 			kmem_cache_free(vm_region_jar, region);
 			region = pregion;
 			result = start;
@@ -1441,9 +1447,13 @@ error_just_free:
 error:
 	if (region->vm_file)
 		fput(region->vm_file);
+	if (region->vm_prfile)
+		fput(region->vm_prfile);
 	kmem_cache_free(vm_region_jar, region);
 	if (vma->vm_file)
 		fput(vma->vm_file);
+	if (vma->vm_prfile)
+		fput(vma->vm_prfile);
 	kmem_cache_free(vm_area_cachep, vma);
 	kleave(" = %d", ret);
 	return ret;
-- 
1.7.9.5

