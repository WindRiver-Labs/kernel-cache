From e4b7dc2d990d2e4883ab6a9e35e9964a3e333605 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 24 Sep 2009 13:11:06 -0400
Subject: [PATCH] rt: make softirq threads lower priority than hardirq

The release of the 2.6.29.5-rt21 broken out patch series
(i.e.  patch-2.6.29.5-rt21-broken-out.tar.bz2) had a new
patch called softirq-lower-priority.patch.  While that
patch doesn't have any description attached to it, its
function is best described by a portion of the release
announcement ( http://lwn.net/Articles/338002/ )

 -- begin text from Thomas Gleixner <tglx@linutronix.de> --

This fixes a long standing default priority configuration problem of
the -rt series. On UP machines this can result in net_tx softirq
running in an endless loop and starving the irq threads and the other
softirq threads and of course everything with lower priority. It might
be possible to happen on a SMP machine when the hardirq thread
affinities are tweaked in the right way.

What happens is:

     tx interrupt
        lock(card->tx_lock);
        dev_kfree_skb_any(skb);
          blocks on a contended lock

     net_tx softirq runs
        unlocks contended lock but does not schedule away due to equal prio
	repeat:
         calls xmit
	 try_lock(card->tx_lock) fails
	   -> reschedule skb which keeps net_tx running
         goto repeat;

The scheduler does not schedule away net_tx, so this goes on forever.

This has been there forever, but it seems to be easier to trigger in
the 29 -rt series which is probably due to the slab cache lock breaks
we did.

The problem is restricted to a dozen of wireless adapters and network
cards where e1000e is the most popular one. We could patch the
affected drivers for -rt, but we need to have a closer look at the
general assumptions of drivers vs. hardirq/softirq. Note, this is not
a mainline problem as the semantics are entirely correct there.

Lowering the priorities of the softirq threads below the hardirq
threads priorities is a safe workaround for now. It prevents the
runaway scenario under all circumstances as it resembles the mainline
semantics closely.

For all existing -rt systems the problem can be solved w/o patching
the kernel by adjusting the priority of the softirq threads from the
init scripts with chrt.

It's extremly hard to trigger this, we never had a report of that
before, and I want to say thanks to Bernd Oelker who meticulously
worked on reproducing the problem and debugging it with all evil
methods and patches I could come up with. And no, I'm not going to
tell you which nasty hacks made it possible to decode this :)

  -- end text from 2.6.29.5-rt21 announcement by Thomas Gleixner --

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/softirq.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/kernel/softirq.c b/kernel/softirq.c
index 4048316..c6d2056 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -723,7 +723,8 @@ EXPORT_SYMBOL(tasklet_unlock_wait);
 
 static int ksoftirqd(void * __data)
 {
-	struct sched_param param = { .sched_priority = MAX_USER_RT_PRIO/2 };
+	/* Priority needs to be below hardirqs */
+	struct sched_param param = { .sched_priority = MAX_USER_RT_PRIO/2 - 1};
 	struct softirqdata *data = __data;
 	u32 softirq_mask = (1 << data->nr);
 	struct softirq_action *h;
-- 
1.6.5.rc1

