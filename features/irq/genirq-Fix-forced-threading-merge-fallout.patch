From 7dda0273e812902579a199a134ebe73203d57204 Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Mon, 22 Feb 2010 16:55:03 +0100
Subject: [PATCH 21/22] genirq: Fix forced threading merge fallout

commit ddb34cf8cb1cc24764b72b608cd6d148d116a9f3 from linux-2.6-tip

The mainline changes for oneshot interrupts conflicted with the forced
threaded interrupts on RT, which reuse the IRQF_ONESHOT
mechanism. Shared interrupt need to keep the interrupt line disabled
until all handler threads finished.

Make finalize_oneshot_irq() aware of that.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
[use CONFIG_PREEMPT_HARDIRQS for ifndeffery as this is finer
grained control and correct]
Integrated-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 kernel/irq/manage.c |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 3565ac2..0d82f8d 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -568,10 +568,12 @@ irq_wait_for_interrupt(struct irq_desc *desc, struct irqaction *action)
  * handler finished. unmask if the interrupt has not been disabled and
  * is marked MASKED.
  */
-static void irq_finalize_oneshot(unsigned int irq, struct irq_desc *desc)
+static void irq_finalize_oneshot(unsigned int irq, struct irq_desc *desc,
+				struct irqaction *action)
 {
 again:
 	chip_bus_lock(irq, desc);
+#ifndef CONFIG_PREEMPT_HARDIRQS
 	raw_spin_lock_irq(&desc->lock);
 
 	/*
@@ -595,6 +597,9 @@ again:
 		desc->chip->unmask(irq);
 	}
 	raw_spin_unlock_irq(&desc->lock);
+#else
+	preempt_hardirq_thread_done(desc, action);
+#endif
 	chip_bus_sync_unlock(irq, desc);
 }
 
@@ -668,7 +673,7 @@ static int irq_thread(void *data)
 			action->thread_fn(action->irq, action->dev_id);
 
 			if (desc->status & IRQ_ONESHOT)
-				irq_finalize_oneshot(action->irq, desc);
+				irq_finalize_oneshot(action->irq, desc, action);
 		}
 
 		wake = atomic_dec_and_test(&desc->threads_active);
-- 
1.7.0

