From c91fb60684f7cb89d38770ed3dac2a9ffdefe795 Mon Sep 17 00:00:00 2001
From: yadi.hu@windriver.com <yadi.hu@windriver.com>
Date: Mon, 15 Dec 2014 15:38:37 +0800
Subject: [PATCH] genirq: Remove pending status on threaded handler
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

A test module fashioned to register a timer interrupt which then
repeatedly disables and enables the interrupt shows that irq
remains disabled even after being enabled.

if I modify the kernel/irq/manage.c, remove the following line:

void __enable_irq(struct irq_desc *desc, unsigned int irq, bool resume)
{
...
desc->status = status | IRQ_NOPROBE;
// if (!desc->forced_threads_active) /*I remove this line, it works fine*/
check_irq_resend(desc, irq);
...
Or if use the IRQF_NODELAY to request_irq, this problem don't happen.

A normal process for threaded interrupt is below:
handle_fasteoi_irq()
	handle_IRQ_event()
		handle_irq_action()
			wake_up_precess()

root cause is that if this interrupt happens to be disabled followed by
wake_up_process() and before threaded handler start to run, when irq_thread
starts to execute,it would flag the irq as pending, and the threaded handler
will not run. So that desc->forced_threads_active will not be cleared.

 	if (unlikely(desc->status & IRQ_DISABLED)) {
                 desc->status |= IRQ_PENDING;
                 raw_spin_unlock_irq(&desc->lock);
         }

Refering to mainline, I found this part has been remove in commit
7140ea1980f2fae9c7aaeac5f6b35317e1389ee6 (“genirq: Flush the irq thread on
synchronization”).But the patch is a bit of complicated for wrlinux4.3,
so I just delete above code lines and seems it is should be enough.

Signed-off-by: Hu <yadi.hu@windriver.com>
---
 kernel/irq/manage.c |   24 +++++-------------------
 1 files changed, 5 insertions(+), 19 deletions(-)

diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index fee91d2..d1d94fd 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -670,26 +670,12 @@ static int irq_thread(void *data)
 
 		atomic_inc(&desc->threads_active);
 
-		raw_spin_lock_irq(&desc->lock);
-		if (unlikely(desc->status & IRQ_DISABLED)) {
-			/*
-			 * CHECKME: We might need a dedicated
-			 * IRQ_THREAD_PENDING flag here, which
-			 * retriggers the thread in check_irq_resend()
-			 * but AFAICT IRQ_PENDING should be fine as it
-			 * retriggers the interrupt itself --- tglx
-			 */
-			desc->status |= IRQ_PENDING;
-			raw_spin_unlock_irq(&desc->lock);
-		} else {
-			raw_spin_unlock_irq(&desc->lock);
-
-			action->thread_fn(action->irq, action->dev_id);
-
-			if (desc->status & IRQ_ONESHOT)
-				irq_finalize_oneshot(action->irq, desc, action);
-		}
 
+		action->thread_fn(action->irq, action->dev_id);
+
+		if (desc->status & IRQ_ONESHOT)
+			irq_finalize_oneshot(action->irq, desc, action);
+		
 		wake = atomic_dec_and_test(&desc->threads_active);
 
 		if (wake && waitqueue_active(&desc->wait_for_threads))
-- 
1.7.0

