From ab677bc2e62c329e47bcd77a4b61b8ca04074495 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Sun, 21 Jun 2009 17:29:50 -0400
Subject: [PATCH] softirq: wait for online CPU before starting thread

The softirq threads are started at boot from when a CPU is tagged as
UP_PREPARE, but not necessarily online.  The softirq thread has a check
for cpu_offline, which is meant for thread exit on a CPU removal event.
However on slower hardware, it is possible to make it all the way to
this check before the CPU is marked as online at boot (during the
bogomips calculation).  When this happens, the softirq thread silently
sits in a corner and does nothing, waiting for the kthread_should_stop
that never comes.

Waiting on the CPU to come online before entering the main ksoftird
loop is the fix. The printk on death, while not strictly necessary,
sure would have saved a lot of debugging effort.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/softirq.c |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/kernel/softirq.c b/kernel/softirq.c
index 322f99a..8efe1b1 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -639,6 +639,12 @@ static int ksoftirqd(void * __data)
 	current->flags |= PF_SOFTIRQ;
 	set_current_state(TASK_INTERRUPTIBLE);
 
+	/* Called from CPU_UP_PREPARE, CPU might not be online yet */
+	while (cpu_is_offline(cpu)) {
+		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+
 	while (!kthread_should_stop()) {
 		preempt_disable();
 		if (!(local_softirq_pending() & softirq_mask)) {
@@ -658,8 +664,11 @@ sleep_more:
 			/* Preempt disable stops cpu going offline.
 			   If already offline, we'll be on wrong CPU:
 			   don't process */
-			if (cpu_is_offline(cpu))
+			if (cpu_is_offline(cpu)) {
+				printk("cpu%d offline, %s awaiting death\n",
+					cpu, current->comm);
 				goto wait_to_die;
+			}
 
 			local_irq_disable();
 			/*
-- 
1.6.3.2

