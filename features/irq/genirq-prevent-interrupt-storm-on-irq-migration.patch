From 1a9121e85a8c3ff2781abd38dba8f7d8075eec19 Mon Sep 17 00:00:00 2001
From: Ingo Molnar <mingo@elte.hu>
Date: Fri, 3 Jul 2009 08:29:27 -0500
Subject: [PATCH 03/22] genirq: prevent interrupt storm on irq migration

commit b87daa2884f9b0196621013731b2be2f736c962e from linux-2.6-tip

Migration maks/unmaks interrupts unconditionally. With forced irq
threading thats going to result in an interrupt storm when the
threaded handler has not finished yet.

Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 kernel/irq/migration.c |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/kernel/irq/migration.c b/kernel/irq/migration.c
index 2419622..4817563 100644
--- a/kernel/irq/migration.c
+++ b/kernel/irq/migration.c
@@ -54,6 +54,7 @@ void move_masked_irq(int irq)
 void move_native_irq(int irq)
 {
 	struct irq_desc *desc = irq_to_desc(irq);
+	int mask = 1;
 
 	if (likely(!(desc->status & IRQ_MOVE_PENDING)))
 		return;
@@ -61,8 +62,17 @@ void move_native_irq(int irq)
 	if (unlikely(desc->status & IRQ_DISABLED))
 		return;
 
-	desc->chip->mask(irq);
+	/*
+	 * If the irq is already in progress, it should be masked.
+	 * If we unmask it, we might cause an interrupt storm on RT.
+	 */
+	if (unlikely(desc->status & IRQ_INPROGRESS))
+		mask = 0;
+
+	if (mask)
+		desc->chip->mask(irq);
 	move_masked_irq(irq);
-	desc->chip->unmask(irq);
+	if (mask)
+		desc->chip->unmask(irq);
 }
 
-- 
1.7.0

