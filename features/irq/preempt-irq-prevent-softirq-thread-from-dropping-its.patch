From 338799a047ea6db87190d5895c010844c7543013 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Tue, 6 Jul 2010 13:13:06 -0700
Subject: [PATCH 4/4] preempt-irq: prevent softirq thread from dropping its binding

When softirq threads are created they are each bound to a
specific CPU on SMP systems. Thread creation takes place before
CPU may become online and it is also possible for softirqs to
be raised prior to a CPU becoming online. If we allow
a thread to be woken before the CPU it is bound to is online it
will drop this binding and bind to CPU0. This will lead to a mismatch
situation with softirqdata and cause all sort of issues at boot.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 kernel/softirq.c |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/kernel/softirq.c b/kernel/softirq.c
index 893aa04..14ddb01 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -107,6 +107,14 @@ void wakeup_softirqd(int softirq)
 	/* Interrupts are disabled: no need to stop preemption */
 	struct task_struct *tsk = __get_cpu_var(ksoftirqd)[softirq].tsk;
 
+#ifdef CONFIG_SMP
+	/* we can't wake the process until the CPU is available
+	 * otherwise it will be bound to CPU0 and the mismatch
+	 * will cause many issues at boot.
+	 */
+	if (cpu_is_offline(__get_cpu_var(ksoftirqd)[softirq].cpu))
+		return;
+#endif
 	if (tsk && tsk->state != TASK_RUNNING)
 		wake_up_process(tsk);
 }
-- 
1.6.5.2

