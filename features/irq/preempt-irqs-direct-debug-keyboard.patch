---
 include/linux/sched.h |    6 ++++++
 init/main.c           |    2 ++
 kernel/irq/handle.c   |   31 +++++++++++++++++++++++++++++++
 3 files changed, 39 insertions(+), 0 deletions(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index e7ba101..33058c4 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -303,6 +303,12 @@ extern void hrtick_resched(void);
 
 extern void sched_show_task(struct task_struct *p);
 
+#ifdef CONFIG_GENERIC_HARDIRQS
+extern int debug_direct_keyboard;
+#else
+# define debug_direct_keyboard 0
+#endif
+
 #ifdef CONFIG_DETECT_SOFTLOCKUP
 extern void softlockup_tick(void);
 extern void touch_softlockup_watchdog(void);
diff --git a/init/main.c b/init/main.c
index 4589159..64b267c 100644
--- a/init/main.c
+++ b/init/main.c
@@ -887,5 +887,7 @@ static int __init kernel_init(void * unused)
 	 * initmem segments and start the user-mode stuff..
 	 */
 	init_post();
+	WARN_ON(debug_direct_keyboard);
+
 	return 0;
 }
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index d55bc9f..706efe7 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -132,6 +132,11 @@ irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action)
 	irqreturn_t ret, retval = IRQ_NONE;
 	unsigned int status = 0;
 
+#ifdef __i386__
+	if (debug_direct_keyboard && irq == 1)
+		lockdep_off();
+#endif
+
 	handle_dynamic_tick(action);
 
 	/*
@@ -163,9 +168,30 @@ irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action)
 	}
 	local_irq_disable();
 
+#ifdef __i386__
+	if (debug_direct_keyboard && irq == 1)
+		lockdep_on();
+#endif
 	return retval;
 }
 
+/*
+ * Hack - used for development only.
+ */
+int __read_mostly debug_direct_keyboard = 0;
+
+int __init debug_direct_keyboard_setup(char *str)
+{
+	debug_direct_keyboard = 1;
+	printk(KERN_INFO "Switching IRQ 1 (keyboard) to to direct!\n");
+#ifdef CONFIG_PREEMPT_RT
+	printk(KERN_INFO "WARNING: kernel may easily crash this way!\n");
+#endif
+	return 1;
+}
+
+__setup("debug_direct_keyboard", debug_direct_keyboard_setup);
+
 int redirect_hardirq(struct irq_desc *desc)
 {
 	/*
@@ -175,6 +201,11 @@ int redirect_hardirq(struct irq_desc *desc)
 							!desc->thread)
 		return 0;
 
+#ifdef __i386__
+	if (debug_direct_keyboard && (desc - irq_desc == 1))
+		return 0;
+#endif
+
 	BUG_ON(!irqs_disabled());
 	if (desc->thread && desc->thread->state != TASK_RUNNING)
 		wake_up_process(desc->thread);
