From af1ef435d92fed318a11a5bc0f37aaaf552e67b2 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Wed, 19 May 2010 13:44:16 -0400
Subject: [PATCH 20/22] Switch to using the IRQF_ONESHOT mechanism

Move handle_irq_action() to handle.c where it should be. Remove
redudant preempt_hardirq_handler() function. Move to using the
IRQF_ONESHOT mechanism for forced interrupt threading since relying
on the thread handler function pointer was a bit of a kludge.

Based on d94ddace23997c2899e8137f088488773b35eadb from linux-2.6-tip

[
commit d94ddace23997c2899e8137f088488773b35eadb
Merge: a66b9c2... 4eec1a1...
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Aug 17 20:14:14 2009 +0200

    Merge branch 'rt/base' into rt/head

    Conflicts:
        kernel/irq/chip.c
        kernel/irq/internals.h
        kernel/irq/manage.c

    Convert forced irq threading to the new ONESHOT infrastructure

    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
]

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 kernel/irq/chip.c   |    6 +++-
 kernel/irq/handle.c |   21 ++++++++++++++++
 kernel/irq/manage.c |   67 ++++++++++----------------------------------------
 3 files changed, 39 insertions(+), 55 deletions(-)

diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index 0154bd0..77403e9 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -502,8 +502,7 @@ handle_level_irq(unsigned int irq, struct irq_desc *desc)
 	raw_spin_lock(&desc->lock);
 	desc->status &= ~IRQ_INPROGRESS;
 
-	if (!(desc->status & (IRQ_DISABLED | IRQ_ONESHOT)) &&
-	    !desc->forced_threads_active)
+	if (!(desc->status & (IRQ_DISABLED | IRQ_ONESHOT)))
 		unmask_irq(desc, irq);
 out_unlock:
 	raw_spin_unlock(&desc->lock);
@@ -545,6 +544,9 @@ handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc)
 		goto out;
 	}
 
+	if ((desc->status & IRQ_ONESHOT) && desc->chip->mask)
+		desc->chip->mask(irq);
+
 	desc->status |= IRQ_INPROGRESS;
 	desc->status &= ~IRQ_PENDING;
 	raw_spin_unlock(&desc->lock);
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index 9b3bb92..ee42fd8 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -358,6 +358,27 @@ static void warn_no_thread(unsigned int irq, struct irqaction *action)
 	       "but no thread function available.", irq, action->name);
 }
 
+#ifdef CONFIG_PREEMPT_HARDIRQS
+/*
+ * Momentary workaround until I have a brighter idea how to handle the
+ * accounting of forced thread handlers.
+ */
+irqreturn_t handle_irq_action(unsigned int irq, struct irqaction *action)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+
+	if (desc->status & IRQ_ONESHOT) {
+		unsigned long flags;
+
+		raw_spin_lock_irqsave(&desc->lock, flags);
+		desc->forced_threads_active |= action->thread_mask;
+		raw_spin_unlock_irqrestore(&desc->lock, flags);
+		return IRQ_WAKE_THREAD;
+	}
+	return action->handler(irq, action->dev_id);
+}
+#endif
+
 /**
  * handle_IRQ_event - irq action chain handler
  * @irq:	the interrupt number
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 7c280ff..3565ac2 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -468,38 +468,24 @@ static irqreturn_t irq_nested_primary_handler(int irq, void *dev_id)
 
 #ifdef CONFIG_PREEMPT_HARDIRQS
 /*
- * handler function for forced irq threading. Dummy code. See
- * handle_irq_action() below.
- */
-static irqreturn_t preempt_hardirq_handler(int irq, void *dev_id)
-{
-	return IRQ_WAKE_THREAD;
-}
-
-/*
- * Momentary workaround until I have a brighter idea how to handle the
- * accounting of forced thread handlers.
+ * If the caller does not request irq threading then the handler
+ * becomes the thread function and we use the above handler as the
+ * primary hardirq context handler.
  */
-irqreturn_t handle_irq_action(unsigned int irq, struct irqaction *action)
+static void preempt_hardirq_setup(struct irqaction *new)
 {
-	if (action->handler == preempt_hardirq_handler) {
-		struct irq_desc *desc = irq_to_desc(irq);
-		unsigned long flags;
-
-		raw_spin_lock_irqsave(&desc->lock, flags);
+	if (new->thread_fn || (new->flags & (IRQF_NODELAY | IRQF_PERCPU)))
+		return;
 
-		/* FIXME: use some flag to do that */
-		if (desc->handle_irq == handle_fasteoi_irq) {
-			if (desc->chip->mask)
-				desc->chip->mask(irq);
-		}
-		desc->forced_threads_active |= action->thread_mask;
-		raw_spin_unlock_irqrestore(&desc->lock, flags);
-		return IRQ_WAKE_THREAD;
-	}
-	return action->handler(irq, action->dev_id);
+	new->flags |= IRQF_ONESHOT;
+	new->thread_fn = new->handler;
+	new->handler = irq_default_primary_handler;
 }
 
+#else
+static inline void preempt_hardirq_setup(struct irqaction *new) { }
+#endif
+
 /*
  * forced threaded interrupts need to unmask the interrupt line
  */
@@ -508,7 +494,7 @@ static int preempt_hardirq_thread_done(struct irq_desc *desc,
 {
 	unsigned long masked;
 
-	if (action->handler != preempt_hardirq_handler)
+	if (!(desc->status & IRQ_ONESHOT))
 		return 0;
 again:
 	raw_spin_lock_irq(&desc->lock);
@@ -553,20 +539,6 @@ again:
 	return 0;
 }
 
-/*
- * If the caller does not request irq threading then the handler
- * becomes the thread function and we use the above handler as the
- * primary hardirq context handler.
- */
-static void preempt_hardirq_setup(struct irqaction *new)
-{
-	if (new->thread_fn || (new->flags & (IRQF_NODELAY | IRQF_PERCPU)))
-		return;
-
-	new->thread_fn = new->handler;
-	new->handler = preempt_hardirq_handler;
-}
-
 static inline void
 preempt_hardirq_cleanup(struct irq_desc *desc, struct irqaction *action)
 {
@@ -574,17 +546,6 @@ preempt_hardirq_cleanup(struct irq_desc *desc, struct irqaction *action)
 	preempt_hardirq_thread_done(desc, action);
 }
 
-#else
-static inline void preempt_hardirq_setup(struct irqaction *new) { }
-static inline int
-preempt_hardirq_thread_done(struct irq_desc *d, struct irqaction *a)
-{
-	return 0;
-}
-static inline void
-preempt_hardirq_cleanup(struct irq_desc *d, struct irqaction *a) { }
-#endif
-
 static int
 irq_wait_for_interrupt(struct irq_desc *desc, struct irqaction *action)
 {
-- 
1.7.0

