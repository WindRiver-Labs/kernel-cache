From 53012a26cedb02d18ccb69eae0b3f2aa5f528fa5 Mon Sep 17 00:00:00 2001
From: Jupyung Lee <jupyung@gmail.com>
Date: Tue, 10 Nov 2009 17:31:54 +0900
Subject: [PATCH 15/22] softirqs: Add missing preemption point in ksoftirqd

commit ca0b4bfa5994856bbcf4227e29f9c73722efaef2 from linux-2.6-tip

In its current implementation, ksoftirq() includes a series of primitives
related with kernel preemption and irq on/off, in the following order:

preempt_disable()		... (1)
local_irq_disable()		... (2)
__preempt_enable_no_resched()	... (3)
local_irq_enable()		... (4)

A problem arises if a task is woken up between (1) and (2) because it
is not given a chance to preempt the currently running process until
interrupts are enabled at (4). At this point the the kernel is
preemptible, but there is no explicit reschedule point.

This is only true for a preempt-rt enabled kernel as !preempt-rt has
preemption disabled at that point via local_bh_disable().

A simple suggestion to resolve the problem is to add a reschedule point,
preempt_check_resched(), just after (4).

[ tglx: Modified: delete __preempt_enable_no_resched() and add
  	preempt_enable() after local_irq_enable() ]

Signed-off-by: Jupyung Lee <jupyung@gmail.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
[minor context updates for 2.6.34]
Integrated-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 kernel/softirq.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/kernel/softirq.c b/kernel/softirq.c
index 3d8304f..ce0cb85 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -763,10 +763,10 @@ static int run_ksoftirqd(void * __data)
 				goto wait_to_die;
 
 			local_irq_disable();
-			__preempt_enable_no_resched();
 			set_softirq_pending(local_softirq_pending() & ~mask);
 			local_bh_disable();
 			local_irq_enable();
+			preempt_enable();
 
 			h = &softirq_vec[data->nr];
 			if (h)
-- 
1.7.0

