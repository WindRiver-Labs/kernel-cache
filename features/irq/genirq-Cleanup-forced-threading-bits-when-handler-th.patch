From c23f21a4d2283c9660d67bc269463b22df7549ac Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Wed, 12 Aug 2009 18:32:08 +0200
Subject: [PATCH 08/22] genirq: Cleanup forced threading bits when handler thread terminates

commit b46fe5710dee18042a0f333e3709cd7af79acd97 from linux-2.6-tip

When a handler thread terminates then the forced_thread_active bit
might be still set. Cleanup and unmask the interrupt if this is the
last thread which blocked the unmask.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 kernel/irq/manage.c |   12 ++++++++++++
 1 files changed, 12 insertions(+), 0 deletions(-)

diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 262dab5..973f3af 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -566,6 +566,14 @@ static void preempt_hardirq_setup(struct irqaction *new)
 	new->thread_fn = new->handler;
 	new->handler = preempt_hardirq_handler;
 }
+
+static inline void
+preempt_hardirq_cleanup(struct irq_desc *desc, struct irqaction *action)
+{
+	clear_bit(IRQTF_RUNTHREAD, &action->thread_flags);
+	preempt_hardirq_thread_done(desc, action);
+}
+
 #else
 static inline void preempt_hardirq_setup(struct irqaction *new) { }
 static inline int
@@ -573,6 +581,8 @@ preempt_hardirq_thread_done(struct irq_desc *d, struct irqaction *a)
 {
 	return 0;
 }
+static inline void
+preempt_hardirq_cleanup(struct irq_desc *d, struct irqaction *a) { }
 #endif
 
 static int
@@ -706,6 +716,8 @@ static int irq_thread(void *data)
 			wake_up(&desc->wait_for_threads);
 	}
 
+	preempt_hardirq_cleanup(desc, action);
+
 	/*
 	 * Clear irqaction. Otherwise exit_irq_thread() would make
 	 * fuzz about an active irq thread going into nirvana.
-- 
1.7.0

