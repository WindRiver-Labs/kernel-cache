From 9fea4f0fe4011a5b76f460c34d9cadd9599e2e15 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Wed, 19 May 2010 14:09:17 -0400
Subject: [PATCH 22/22] Revert preempt-irq changes which manipulate mailine

Based on commit a66b9c21 from linux-2.6-tip

Several changes made by the preempt-irq patches modify mainline
behaviour for no need, this commit reverts these changes such
that the mainline behaviour is restored.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 kernel/irq/handle.c |    2 +-
 kernel/irq/manage.c |   18 ++----------------
 2 files changed, 3 insertions(+), 17 deletions(-)

diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index ee42fd8..660c964 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -361,7 +361,7 @@ static void warn_no_thread(unsigned int irq, struct irqaction *action)
 #ifdef CONFIG_PREEMPT_HARDIRQS
 /*
  * Momentary workaround until I have a brighter idea how to handle the
- * accounting of forced thread handlers.
+ * accounting of forced threaded (shared) handlers.
  */
 irqreturn_t handle_irq_action(unsigned int irq, struct irqaction *action)
 {
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 0d82f8d..53dce83 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -570,10 +570,8 @@ irq_wait_for_interrupt(struct irq_desc *desc, struct irqaction *action)
 			__set_current_state(TASK_RUNNING);
 			return 0;
 		}
-		if (!preempt_hardirq_thread_done(desc, action)) {
-			schedule();
-			set_current_state(TASK_INTERRUPTIBLE);
-		}
+		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
 	}
 	__set_current_state(TASK_RUNNING);
 	return -1;
@@ -922,9 +921,6 @@ __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 	new->dir = NULL;
 	register_handler_proc(irq, new);
 
-	if (new->thread)
-		wake_up_process(new->thread);
-
 	return 0;
 
 mismatch:
@@ -1021,11 +1017,6 @@ static struct irqaction *__free_irq(unsigned int irq, void *dev_id)
 			desc->chip->disable(irq);
 	}
 
-	/*
-	 * Clear the forced_threaded bit of the removed action
-	 */
-	desc->forced_threads_active &= ~action->thread_mask;
-
 	raw_spin_unlock_irqrestore(&desc->lock, flags);
 
 	unregister_handler_proc(irq, action);
@@ -1217,18 +1208,13 @@ int request_threaded_irq(unsigned int irq, irq_handler_t handler,
 		 * run in parallel with our fake.
 		 */
 		unsigned long flags;
-		irqreturn_t ret;
 
 		disable_irq(irq);
 		local_irq_save(flags);
 
-		ret = action->handler(irq, dev_id);
+		handler(irq, dev_id);
 
 		local_irq_restore(flags);
-
-		if (ret == IRQ_WAKE_THREAD)
-			action->thread_fn(irq, dev_id);
-
 		enable_irq(irq);
 	}
 #endif
-- 
1.7.0

