From fc7f836005b6f692649b3119d0032ea667387147 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos <nmav@gnutls.org>
Date: Sun, 4 Dec 2011 12:47:13 +0100
Subject: [PATCH 158/291] cryptodev: Added

---
 drivers/staging/crypto/cryptodev/examples/Makefile |  26 -
 drivers/staging/crypto/cryptodev/examples/aes.c    | 237 +++++++++
 drivers/staging/crypto/cryptodev/examples/aes.h    |  19 +
 .../crypto/cryptodev/examples/async_cipher.c       | 326 ------------
 .../staging/crypto/cryptodev/examples/async_hmac.c | 292 ----------
 .../crypto/cryptodev/examples/async_speed.c        | 215 --------
 .../crypto/cryptodev/examples/cipher-aead-srtp.c   | 591 ---------------------
 .../crypto/cryptodev/examples/cipher-aead.c        | 588 --------------------
 .../staging/crypto/cryptodev/examples/cipher-gcm.c | 528 ------------------
 drivers/staging/crypto/cryptodev/examples/cipher.c | 319 -----------
 .../staging/crypto/cryptodev/examples/fullspeed.c  | 184 -------
 .../crypto/cryptodev/examples/hashcrypt_speed.c    | 206 -------
 drivers/staging/crypto/cryptodev/examples/hmac.c   | 333 ------------
 drivers/staging/crypto/cryptodev/examples/sha.c    | 137 +++++
 drivers/staging/crypto/cryptodev/examples/sha.h    |  16 +
 .../staging/crypto/cryptodev/examples/sha_speed.c  | 198 -------
 drivers/staging/crypto/cryptodev/examples/speed.c  | 212 --------
 .../staging/crypto/cryptodev/examples/testhelper.h |  57 --
 drivers/staging/crypto/cryptodev/tests/Makefile    |  26 +
 .../staging/crypto/cryptodev/tests/async_cipher.c  | 326 ++++++++++++
 .../staging/crypto/cryptodev/tests/async_hmac.c    | 292 ++++++++++
 .../staging/crypto/cryptodev/tests/async_speed.c   | 215 ++++++++
 .../crypto/cryptodev/tests/cipher-aead-srtp.c      | 591 +++++++++++++++++++++
 .../staging/crypto/cryptodev/tests/cipher-aead.c   | 588 ++++++++++++++++++++
 .../staging/crypto/cryptodev/tests/cipher-gcm.c    | 528 ++++++++++++++++++
 drivers/staging/crypto/cryptodev/tests/cipher.c    | 319 +++++++++++
 drivers/staging/crypto/cryptodev/tests/fullspeed.c | 184 +++++++
 .../crypto/cryptodev/tests/hashcrypt_speed.c       | 206 +++++++
 drivers/staging/crypto/cryptodev/tests/hmac.c      | 333 ++++++++++++
 drivers/staging/crypto/cryptodev/tests/sha_speed.c | 198 +++++++
 drivers/staging/crypto/cryptodev/tests/speed.c     | 212 ++++++++
 .../staging/crypto/cryptodev/tests/testhelper.h    |  57 ++
 32 files changed, 4484 insertions(+), 4075 deletions(-)
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/Makefile
 create mode 100644 drivers/staging/crypto/cryptodev/examples/aes.c
 create mode 100644 drivers/staging/crypto/cryptodev/examples/aes.h
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/async_cipher.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/async_hmac.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/async_speed.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/cipher-aead-srtp.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/cipher-aead.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/cipher-gcm.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/cipher.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/fullspeed.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/hashcrypt_speed.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/hmac.c
 create mode 100644 drivers/staging/crypto/cryptodev/examples/sha.c
 create mode 100644 drivers/staging/crypto/cryptodev/examples/sha.h
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/sha_speed.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/speed.c
 delete mode 100644 drivers/staging/crypto/cryptodev/examples/testhelper.h
 create mode 100644 drivers/staging/crypto/cryptodev/tests/Makefile
 create mode 100644 drivers/staging/crypto/cryptodev/tests/async_cipher.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/async_hmac.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/async_speed.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/cipher-aead-srtp.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/cipher-aead.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/cipher-gcm.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/cipher.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/fullspeed.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/hashcrypt_speed.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/hmac.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/sha_speed.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/speed.c
 create mode 100644 drivers/staging/crypto/cryptodev/tests/testhelper.h

diff --git a/drivers/staging/crypto/cryptodev/examples/Makefile b/drivers/staging/crypto/cryptodev/examples/Makefile
deleted file mode 100644
index 9a367d3043d3..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/Makefile
+++ /dev/null
@@ -1,26 +0,0 @@
-KERNEL_DIR ?= /lib/modules/$(shell uname -r)/build
-KBUILD_CFLAGS += -I..
-
-hostprogs := cipher cipher-aead hmac speed async_cipher async_hmac \
-	async_speed sha_speed hashcrypt_speed fullspeed cipher-gcm \
-	cipher-aead-srtp
-
-example-cipher-objs := cipher.o
-example-cipher-aead-objs := cipher-aead.o
-example-hmac-objs := hmac.o
-example-speed-objs := speed.c
-example-fullspeed-objs := fullspeed.c
-example-sha-speed-objs := sha_speed.c
-example-async-cipher-objs := async_cipher.o
-example-async-hmac-objs := async_hmac.o
-example-async-speed-objs := async_speed.o
-example-hashcrypt-speed-objs := hashcrypt_speed.c
-
-check: $(hostprogs)
-	./cipher
-	./hmac
-	./async_cipher
-	./async_hmac
-
-clean:
-	rm -f *.o *~ $(hostprogs)
diff --git a/drivers/staging/crypto/cryptodev/examples/aes.c b/drivers/staging/crypto/cryptodev/examples/aes.c
new file mode 100644
index 000000000000..0f154d8fc97f
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/examples/aes.c
@@ -0,0 +1,237 @@
+/*
+ * Demo on how to use /dev/crypto device for ciphering.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+#include "aes.h"
+
+#define	KEY_SIZE	16
+
+
+int aes_ctx_init(struct cryptodev_ctx* ctx, int cfd, const uint8_t *key, unsigned int key_size)
+{
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	memset(ctx, 0, sizeof(*ctx));
+	ctx->cfd = cfd;
+
+	ctx->sess.cipher = CRYPTO_AES_CBC;
+	ctx->sess.keylen = key_size;
+	ctx->sess.key = (void*)key;
+	if (ioctl(ctx->cfd, CIOCGSESSION, &ctx->sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return -1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = ctx->sess.ses;
+	if (ioctl(ctx->cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return -1;
+	}
+	printf("requested cipher CRYPTO_AES_CBC, got %s with driver %s\n",
+			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+	/*printf("Alignmask is %x\n", (unsigned int)siop.alignmask); */
+	ctx->alignmask = siop.alignmask;
+#endif
+	return 0;
+}
+
+void aes_ctx_deinit(struct cryptodev_ctx* ctx) 
+{
+	if (ioctl(ctx->cfd, CIOCFSESSION, &ctx->sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+	}
+}
+
+int
+aes_encrypt(struct cryptodev_ctx* ctx, const void* iv, const void* plaintext, void* ciphertext, size_t size)
+{
+	struct crypt_op cryp;
+	void* p;
+	
+	/* check plaintext and ciphertext alignment */
+	if (ctx->alignmask) {
+		p = (void*)(((unsigned long)plaintext + ctx->alignmask) & ~ctx->alignmask);
+		if (plaintext != p) {
+			fprintf(stderr, "plaintext is not aligned\n");
+			return -1;
+		}
+
+		p = (void*)(((unsigned long)ciphertext + ctx->alignmask) & ~ctx->alignmask);
+		if (ciphertext != p) {
+			fprintf(stderr, "ciphertext is not aligned\n");
+			return -1;
+		}
+	}
+
+	memset(&cryp, 0, sizeof(cryp));
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = ctx->sess.ses;
+	cryp.len = size;
+	cryp.src = (void*)plaintext;
+	cryp.dst = ciphertext;
+	cryp.iv = (void*)iv;
+	cryp.op = COP_ENCRYPT;
+	if (ioctl(ctx->cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+aes_decrypt(struct cryptodev_ctx* ctx, const void* iv, const void* ciphertext, void* plaintext, size_t size)
+{
+	struct crypt_op cryp;
+	void* p;
+	
+	/* check plaintext and ciphertext alignment */
+	if (ctx->alignmask) {
+		p = (void*)(((unsigned long)plaintext + ctx->alignmask) & ~ctx->alignmask);
+		if (plaintext != p) {
+			fprintf(stderr, "plaintext is not aligned\n");
+			return -1;
+		}
+
+		p = (void*)(((unsigned long)ciphertext + ctx->alignmask) & ~ctx->alignmask);
+		if (ciphertext != p) {
+			fprintf(stderr, "ciphertext is not aligned\n");
+			return -1;
+		}
+	}
+
+	memset(&cryp, 0, sizeof(cryp));
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = ctx->sess.ses;
+	cryp.len = size;
+	cryp.src = (void*)ciphertext;
+	cryp.dst = plaintext;
+	cryp.iv = (void*)iv;
+	cryp.op = COP_DECRYPT;
+	if (ioctl(ctx->cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int test_aes(int cfd)
+{
+	char plaintext1_raw[AES_BLOCK_SIZE + 63], *plaintext1;
+	char ciphertext1[AES_BLOCK_SIZE] = { 0xdf, 0x55, 0x6a, 0x33, 0x43, 0x8d, 0xb8, 0x7b, 0xc4, 0x1b, 0x17, 0x52, 0xc5, 0x5e, 0x5e, 0x49 };
+	char iv1[AES_BLOCK_SIZE];
+	uint8_t key1[KEY_SIZE] = { 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	char plaintext2_data[AES_BLOCK_SIZE] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00 };
+	char plaintext2_raw[AES_BLOCK_SIZE + 63], *plaintext2;
+	char ciphertext2[AES_BLOCK_SIZE] = { 0xb7, 0x97, 0x2b, 0x39, 0x41, 0xc4, 0x4b, 0x90, 0xaf, 0xa7, 0xb2, 0x64, 0xbf, 0xba, 0x73, 0x87 };
+	char iv2[AES_BLOCK_SIZE];
+	uint8_t key2[KEY_SIZE];
+	struct cryptodev_ctx ctx;
+
+	aes_ctx_init(&ctx, cfd, key1, sizeof(key1));
+
+	if (ctx.alignmask)
+		plaintext1 = (char *)(((unsigned long)plaintext1_raw + ctx.alignmask) & ~ctx.alignmask);
+	else
+		plaintext1 = plaintext1_raw;
+
+	memset(plaintext1, 0x0, AES_BLOCK_SIZE);
+	memset(iv1, 0x0, sizeof(iv1));
+
+	aes_encrypt(&ctx, iv1, plaintext1, plaintext1, AES_BLOCK_SIZE);
+
+	/* Verify the result */
+	if (memcmp(plaintext1, ciphertext1, AES_BLOCK_SIZE) != 0) {
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		return -1;
+	}
+	
+	aes_ctx_deinit(&ctx);
+
+	/* Test 2 */
+
+	memset(key2, 0x0, sizeof(key2));
+	memset(iv2, 0x0, sizeof(iv2));
+
+	aes_ctx_init(&ctx, cfd, key2, sizeof(key2));
+
+	if (ctx.alignmask) {
+		plaintext2 = (char *)(((unsigned long)plaintext2_raw + ctx.alignmask) & ~ctx.alignmask);
+	} else {
+		plaintext2 = plaintext2_raw;
+	}
+	memcpy(plaintext2, plaintext2_data, AES_BLOCK_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	aes_encrypt(&ctx, iv2, plaintext2, plaintext2, AES_BLOCK_SIZE);
+
+	/* Verify the result */
+	if (memcmp(plaintext2, ciphertext2, AES_BLOCK_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < AES_BLOCK_SIZE; i++) {
+			printf("%02x ", plaintext2[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < AES_BLOCK_SIZE; i++) {
+			printf("%02x ", ciphertext2[i]);
+		}
+		printf("\n");
+		return 1;
+	}
+	
+	aes_ctx_deinit(&ctx);
+
+	printf("AES Test passed\n");
+
+	return 0;
+}
+
+int
+main()
+{
+	int cfd = -1;
+
+	/* Open the crypto device */
+	cfd = open("/dev/crypto", O_RDWR, 0);
+	if (cfd < 0) {
+		perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	/* Run the test itself */
+	if (test_aes(cfd))
+		return 1;
+
+	/* Close the original descriptor */
+	if (close(cfd)) {
+		perror("close(cfd)");
+		return 1;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/staging/crypto/cryptodev/examples/aes.h b/drivers/staging/crypto/cryptodev/examples/aes.h
new file mode 100644
index 000000000000..ade90c92b58c
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/examples/aes.h
@@ -0,0 +1,19 @@
+#ifndef AES_H
+# define AES_H
+
+#include <stdint.h>
+
+struct cryptodev_ctx {
+	int cfd;
+	struct session_op sess;
+	uint16_t alignmask;
+};
+
+#define	AES_BLOCK_SIZE	16
+
+int aes_ctx_init(struct cryptodev_ctx* ctx, int cfd, const uint8_t *key, unsigned int key_size);
+void aes_ctx_deinit();
+int aes_encrypt(struct cryptodev_ctx* ctx, const void* iv, const void* plaintext, void* ciphertext, size_t size);
+int aes_decrypt(struct cryptodev_ctx* ctx, const void* iv, const void* ciphertext, void* plaintext, size_t size);
+
+#endif
diff --git a/drivers/staging/crypto/cryptodev/examples/async_cipher.c b/drivers/staging/crypto/cryptodev/examples/async_cipher.c
deleted file mode 100644
index e89c7f2137f5..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/async_cipher.c
+++ /dev/null
@@ -1,326 +0,0 @@
-/*
- * Demo on how to use /dev/crypto device for ciphering.
- *
- * Placed under public domain.
- *
- */
-#include <poll.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-
-#include <sys/ioctl.h>
-#include <crypto/cryptodev.h>
-
-#include "testhelper.h"
-
-#define	DATA_SIZE	8*1024
-#define	BLOCK_SIZE	16
-#define	KEY_SIZE	16
-
-static int
-test_crypto(int cfd)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-
-	struct session_op sess;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-	struct crypt_op cryp;
-
-	printf("running %s\n", __func__);
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	memset(key, 0x33,  sizeof(key));
-	memset(iv, 0x03,  sizeof(iv));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	printf("%s: got the session\n", __func__);
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
-	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, DATA_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cryp.ses = sess.ses;
-	cryp.len = DATA_SIZE;
-	cryp.src = plaintext;
-	cryp.dst = ciphertext;
-	cryp.iv = iv;
-	cryp.op = COP_ENCRYPT;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
-
-	printf("%s: data encrypted\n", __func__);
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-	printf("%s: session finished\n", __func__);
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-	printf("%s: got new session\n", __func__);
-
-	/* Decrypt data.encrypted to data.decrypted */
-	cryp.ses = sess.ses;
-	cryp.len = DATA_SIZE;
-	cryp.src = ciphertext;
-	cryp.dst = ciphertext;
-	cryp.iv = iv;
-	cryp.op = COP_DECRYPT;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
-
-	printf("%s: data encrypted\n", __func__);
-
-	/* Verify the result */
-	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		return 1;
-	} else
-		printf("Test passed\n");
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int test_aes(int cfd)
-{
-	char plaintext1_raw[BLOCK_SIZE + 63], *plaintext1;
-	char ciphertext1[BLOCK_SIZE] = { 0xdf, 0x55, 0x6a, 0x33, 0x43, 0x8d, 0xb8, 0x7b, 0xc4, 0x1b, 0x17, 0x52, 0xc5, 0x5e, 0x5e, 0x49 };
-	char iv1[BLOCK_SIZE];
-	char key1[KEY_SIZE] = { 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-	char plaintext2_data[BLOCK_SIZE] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00 };
-	char plaintext2_raw[BLOCK_SIZE + 63], *plaintext2;
-	char ciphertext2[BLOCK_SIZE] = { 0xb7, 0x97, 0x2b, 0x39, 0x41, 0xc4, 0x4b, 0x90, 0xaf, 0xa7, 0xb2, 0x64, 0xbf, 0xba, 0x73, 0x87 };
-	char iv2[BLOCK_SIZE];
-	char key2[KEY_SIZE];
-
-	struct session_op sess1, sess2;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop1, siop2;
-#endif
-	struct crypt_op cryp1, cryp2;
-
-	memset(&sess1, 0, sizeof(sess1));
-	memset(&sess2, 0, sizeof(sess2));
-	memset(&cryp1, 0, sizeof(cryp1));
-	memset(&cryp2, 0, sizeof(cryp2));
-
-	/* Get crypto session for AES128 */
-	sess1.cipher = CRYPTO_AES_CBC;
-	sess1.keylen = KEY_SIZE;
-	sess1.key = key1;
-	if (ioctl(cfd, CIOCGSESSION, &sess1)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop1.ses = sess1.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop1)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	plaintext1 = (char *)(((unsigned long)plaintext1_raw + siop1.alignmask) & ~siop1.alignmask);
-#else
-	plaintext1 = plaintext1_raw;
-#endif
-	memset(plaintext1, 0x0, BLOCK_SIZE);
-
-	memset(iv1, 0x0, sizeof(iv1));
-	memset(key2, 0x0, sizeof(key2));
-
-	/* Get second crypto session for AES128 */
-	sess2.cipher = CRYPTO_AES_CBC;
-	sess2.keylen = KEY_SIZE;
-	sess2.key = key2;
-	if (ioctl(cfd, CIOCGSESSION, &sess2)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop2.ses = sess2.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop2)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	plaintext2 = (char *)(((unsigned long)plaintext2_raw + siop2.alignmask) & ~siop2.alignmask);
-#else
-	plaintext2 = plaintext2_raw;
-#endif
-	memcpy(plaintext2, plaintext2_data, BLOCK_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cryp1.ses = sess1.ses;
-	cryp1.len = BLOCK_SIZE;
-	cryp1.src = plaintext1;
-	cryp1.dst = plaintext1;
-	cryp1.iv = iv1;
-	cryp1.op = COP_ENCRYPT;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp1), 0);
-	printf("cryp1 written out\n");
-
-	memset(iv2, 0x0, sizeof(iv2));
-
-	/* Encrypt data.in to data.encrypted */
-	cryp2.ses = sess2.ses;
-	cryp2.len = BLOCK_SIZE;
-	cryp2.src = plaintext2;
-	cryp2.dst = plaintext2;
-	cryp2.iv = iv2;
-	cryp2.op = COP_ENCRYPT;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp2), 0);
-	printf("cryp2 written out\n");
-
-	DO_OR_DIE(do_async_fetch(cfd, &cryp1), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp2), 0);
-	printf("cryp1 + cryp2 successfully read\n");
-
-	/* Verify the result */
-	if (memcmp(plaintext1, ciphertext1, BLOCK_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < BLOCK_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", plaintext1[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < BLOCK_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", ciphertext1[i]);
-		}
-		printf("\n");
-		return 1;
-	} else {
-		printf("result 1 passed\n");
-	}
-
-	/* Test 2 */
-
-	/* Verify the result */
-	if (memcmp(plaintext2, ciphertext2, BLOCK_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < BLOCK_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", plaintext2[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < BLOCK_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", ciphertext2[i]);
-		}
-		printf("\n");
-		return 1;
-	} else {
-		printf("result 2 passed\n");
-	}
-
-	printf("AES Test passed\n");
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess1.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-	if (ioctl(cfd, CIOCFSESSION, &sess2.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-int
-main()
-{
-	int fd = -1, cfd = -1;
-
-	/* Open the crypto device */
-	fd = open("/dev/crypto", O_RDWR, 0);
-	if (fd < 0) {
-		perror("open(/dev/crypto)");
-		return 1;
-	}
-
-	/* Clone file descriptor */
-	if (ioctl(fd, CRIOGET, &cfd)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	/* Set close-on-exec (not really neede here) */
-	if (fcntl(cfd, F_SETFD, 1) == -1) {
-		perror("fcntl(F_SETFD)");
-		return 1;
-	}
-
-	/* Run the test itself */
-	if (test_aes(cfd))
-		return 1;
-
-	if (test_crypto(cfd))
-		return 1;
-
-	/* Close cloned descriptor */
-	if (close(cfd)) {
-		perror("close(cfd)");
-		return 1;
-	}
-
-	/* Close the original descriptor */
-	if (close(fd)) {
-		perror("close(fd)");
-		return 1;
-	}
-
-	return 0;
-}
-
diff --git a/drivers/staging/crypto/cryptodev/examples/async_hmac.c b/drivers/staging/crypto/cryptodev/examples/async_hmac.c
deleted file mode 100644
index be0275219246..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/async_hmac.c
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * Demo on how to use /dev/crypto device for HMAC.
- *
- * Placed under public domain.
- *
- */
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <poll.h>
-#include <stdint.h>
-
-#include <sys/ioctl.h>
-#include <crypto/cryptodev.h>
-
-#include "testhelper.h"
-
-#define	DATA_SIZE	4096
-#define	BLOCK_SIZE	16
-#define	KEY_SIZE	16
-#define SHA1_HASH_LEN   20
-
-static int
-test_crypto(int cfd)
-{
-	struct {
-		uint8_t	in[DATA_SIZE],
-			encrypted[DATA_SIZE],
-			decrypted[DATA_SIZE],
-			iv[BLOCK_SIZE],
-			key[KEY_SIZE];
-	} data;
-	struct session_op sess;
-	struct crypt_op cryp;
-	uint8_t mac[AALG_MAX_RESULT_LEN];
-	uint8_t oldmac[AALG_MAX_RESULT_LEN];
-	uint8_t md5_hmac_out[] = "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38";
-	uint8_t sha1_out[] = "\x8f\x82\x03\x94\xf9\x53\x35\x18\x20\x45\xda\x24\xf3\x4d\xe5\x2b\xf8\xbc\x34\x32";
-	int i;
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	/* Use the garbage that is on the stack :-) */
-	/* memset(&data, 0, sizeof(data)); */
-
-	/* SHA1 plain test */
-	memset(mac, 0, sizeof(mac));
-
-	sess.cipher = 0;
-	sess.mac = CRYPTO_SHA1;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	cryp.ses = sess.ses;
-	cryp.len = sizeof("what do ya want for nothing?")-1;
-	cryp.src = "what do ya want for nothing?";
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
-
-	if (memcmp(mac, sha1_out, 20)!=0) {
-		printf("mac: ");
-		for (i=0;i<SHA1_HASH_LEN;i++) {
-			printf("%.2x", (uint8_t)mac[i]);
-		}
-		puts("\n");
-		fprintf(stderr, "HASH test 1: failed\n");
-	} else {
-		fprintf(stderr, "HASH test 1: passed\n");
-	}
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* MD5-HMAC test */
-	memset(mac, 0, sizeof(mac));
-
-	sess.cipher = 0;
-	sess.mackey = (uint8_t*)"Jefe";
-	sess.mackeylen = 4;
-	sess.mac = CRYPTO_MD5_HMAC;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	cryp.ses = sess.ses;
-	cryp.len = sizeof("what do ya want for nothing?")-1;
-	cryp.src = "what do ya want for nothing?";
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
-
-	if (memcmp(mac, md5_hmac_out, 16)!=0) {
-		printf("mac: ");
-		for (i=0;i<SHA1_HASH_LEN;i++) {
-			printf("%.2x", (uint8_t)mac[i]);
-		}
-		puts("\n");
-		fprintf(stderr, "HMAC test 1: failed\n");
-	} else {
-		fprintf(stderr, "HMAC test 1: passed\n");
-	}
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Hash and encryption in one step test */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.keylen = KEY_SIZE;
-	sess.key = data.key;
-	sess.mackeylen = 16;
-	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	/* Encrypt data.in to data.encrypted */
-	cryp.ses = sess.ses;
-	cryp.len = sizeof(data.in);
-	cryp.src = data.in;
-	cryp.dst = data.encrypted;
-	cryp.iv = data.iv;
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
-
-	memcpy(oldmac, mac, sizeof(mac));
-
-	/* Decrypt data.encrypted to data.decrypted */
-	cryp.src = data.encrypted;
-	cryp.dst = data.decrypted;
-	cryp.op = COP_DECRYPT;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
-
-	/* Verify the result */
-	if (memcmp(data.in, data.decrypted, sizeof(data.in)) != 0) {
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		return 1;
-	} else
-		printf("Crypt Test: passed\n");
-
-	if (memcmp(mac, oldmac, 20) != 0) {
-		fprintf(stderr,
-			"FAIL: Hash in decrypted data different than in encrypted.\n");
-		return 1;
-	} else
-		printf("HMAC Test 2: passed\n");
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int
-test_extras(int cfd)
-{
-	struct session_op sess;
-	struct crypt_op cryp;
-	uint8_t mac[AALG_MAX_RESULT_LEN];
-	uint8_t oldmac[AALG_MAX_RESULT_LEN];
-	uint8_t md5_hmac_out[] = "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38";
-	uint8_t sha1_out[] = "\x8f\x82\x03\x94\xf9\x53\x35\x18\x20\x45\xda\x24\xf3\x4d\xe5\x2b\xf8\xbc\x34\x32";
-	int i;
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	/* Use the garbage that is on the stack :-) */
-	/* memset(&data, 0, sizeof(data)); */
-
-	/* SHA1 plain test */
-	memset(mac, 0, sizeof(mac));
-
-	sess.cipher = 0;
-	sess.mac = CRYPTO_SHA1;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	cryp.ses = sess.ses;
-	cryp.len = sizeof("what do")-1;
-	cryp.src = "what do";
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	cryp.flags = COP_FLAG_UPDATE;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
-
-	cryp.ses = sess.ses;
-	cryp.len = sizeof(" ya want for nothing?")-1;
-	cryp.src = " ya want for nothing?";
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	cryp.flags = COP_FLAG_FINAL;
-
-	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
-	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
-
-	if (memcmp(mac, sha1_out, 20)!=0) {
-		printf("mac: ");
-		for (i=0;i<SHA1_HASH_LEN;i++) {
-			printf("%.2x", (uint8_t)mac[i]);
-		}
-		puts("\n");
-		fprintf(stderr, "HASH test [update]: failed\n");
-	} else {
-		fprintf(stderr, "HASH test [update]: passed\n");
-	}
-
-	memset(mac, 0, sizeof(mac));
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-
-int
-main()
-{
-	int fd = -1, cfd = -1;
-
-	/* Open the crypto device */
-	fd = open("/dev/crypto", O_RDWR, 0);
-	if (fd < 0) {
-		perror("open(/dev/crypto)");
-		return 1;
-	}
-
-	/* Clone file descriptor */
-	if (ioctl(fd, CRIOGET, &cfd)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	/* Set close-on-exec (not really neede here) */
-	if (fcntl(cfd, F_SETFD, 1) == -1) {
-		perror("fcntl(F_SETFD)");
-		return 1;
-	}
-
-	/* Run the test itself */
-	if (test_crypto(cfd))
-		return 1;
-
-	if (test_extras(cfd))
-		return 1;
-
-	/* Close cloned descriptor */
-	if (close(cfd)) {
-		perror("close(cfd)");
-		return 1;
-	}
-
-	/* Close the original descriptor */
-	if (close(fd)) {
-		perror("close(fd)");
-		return 1;
-	}
-
-	return 0;
-}
diff --git a/drivers/staging/crypto/cryptodev/examples/async_speed.c b/drivers/staging/crypto/cryptodev/examples/async_speed.c
deleted file mode 100644
index 4aea5e386533..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/async_speed.c
+++ /dev/null
@@ -1,215 +0,0 @@
-/*  cryptodev_test - simple benchmark tool for cryptodev
- *
- *    Copyright (C) 2010 by Phil Sutter <phil.sutter@viprinet.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <poll.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <signal.h>
-#include <crypto/cryptodev.h>
-
-static double udifftimeval(struct timeval start, struct timeval end)
-{
-	return (double)(end.tv_usec - start.tv_usec) +
-	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
-}
-
-static int must_finish = 0;
-static struct pollfd pfd;
-
-static void alarm_handler(int signo)
-{
-        must_finish = 1;
-	pfd.events = POLLIN;
-}
-
-static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
-
-static void value2human(double bytes, double time, double* data, double* speed,char* metric)
-{
-	int unit = 0;
-
-	*data = bytes;
-	while (*data > 1024 && units[unit + 1]) {
-		*data /= 1024;
-		unit++;
-	}
-	*speed = *data / time;
-	sprintf(metric, "%sB", units[unit]);
-}
-
-
-int encrypt_data(struct session_op *sess, int fdc, int chunksize, int alignmask)
-{
-	struct crypt_op cop;
-	char *buffer[64], iv[32];
-	static int val = 23;
-	struct timeval start, end;
-	double total = 0;
-	double secs, ddata, dspeed;
-	char metric[16];
-	int rc, wqueue = 0, bufidx = 0;
-
-	memset(iv, 0x23, 32);
-
-	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
-	fflush(stdout);
-
-	for (rc = 0; rc < 64; rc++) {
-		if (alignmask) {
-			if (posix_memalign((void **)(buffer + rc), alignmask + 1, chunksize)) {
-				printf("posix_memalign() failed!\n");
-				return 1;
-			}
-		} else {
-			if (!(buffer[rc] = malloc(chunksize))) {
-				perror("malloc()");
-				return 1;
-			}
-		}
-		memset(buffer[rc], val++, chunksize);
-	}
-	pfd.fd = fdc;
-	pfd.events = POLLOUT | POLLIN;
-
-	must_finish = 0;
-	alarm(5);
-
-	gettimeofday(&start, NULL);
-	do {
-		if ((rc = poll(&pfd, 1, 100)) < 0) {
-			if (errno & (ERESTART | EINTR))
-				continue;
-			fprintf(stderr, "errno = %d ", errno);
-			perror("poll()");
-			return 1;
-		}
-
-		if (pfd.revents & POLLOUT) {
-			memset(&cop, 0, sizeof(cop));
-			cop.ses = sess->ses;
-			cop.len = chunksize;
-			cop.iv = (unsigned char *)iv;
-			cop.op = COP_ENCRYPT;
-			cop.src = cop.dst = (unsigned char *)buffer[bufidx];
-			bufidx = (bufidx + 1) % 64;
-
-			if (ioctl(fdc, CIOCASYNCCRYPT, &cop)) {
-				perror("ioctl(CIOCASYNCCRYPT)");
-				return 1;
-			}
-			wqueue++;
-		}
-		if (pfd.revents & POLLIN) {
-			if (ioctl(fdc, CIOCASYNCFETCH, &cop)) {
-				perror("ioctl(CIOCASYNCFETCH)");
-				return 1;
-			}
-			wqueue--;
-			total += cop.len;
-		}
-	} while(!must_finish || wqueue);
-	gettimeofday(&end, NULL);
-
-	secs = udifftimeval(start, end)/ 1000000.0;
-
-	value2human(total, secs, &ddata, &dspeed, metric);
-	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
-	printf ("%.2f %s/sec\n", dspeed, metric);
-
-	for (rc = 0; rc < 64; rc++)
-		free(buffer[rc]);
-	return 0;
-}
-
-int main(void)
-{
-	int fd, i, fdc = -1, alignmask = 0;
-	struct session_op sess;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-	char keybuf[32];
-
-	signal(SIGALRM, alarm_handler);
-
-	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
-		perror("open()");
-		return 1;
-	}
-	if (ioctl(fd, CRIOGET, &fdc)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	fprintf(stderr, "Testing NULL cipher: \n");
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_NULL;
-	sess.keylen = 0;
-	sess.key = (unsigned char *)keybuf;
-	if (ioctl(fdc, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	alignmask = siop.alignmask;
-#endif
-
-	for (i = 256; i <= (64 * 4096); i *= 2) {
-		if (encrypt_data(&sess, fdc, i, alignmask))
-			break;
-	}
-
-	fprintf(stderr, "\nTesting AES-128-CBC cipher: \n");
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = 16;
-	memset(keybuf, 0x42, 16);
-	sess.key = (unsigned char *)keybuf;
-	if (ioctl(fdc, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	alignmask = siop.alignmask;
-#endif
-
-	for (i = 256; i <= (64 * 1024); i *= 2) {
-		if (encrypt_data(&sess, fdc, i, alignmask))
-			break;
-	}
-
-	close(fdc);
-	close(fd);
-	return 0;
-}
diff --git a/drivers/staging/crypto/cryptodev/examples/cipher-aead-srtp.c b/drivers/staging/crypto/cryptodev/examples/cipher-aead-srtp.c
deleted file mode 100644
index d15fc3ee4cd8..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/cipher-aead-srtp.c
+++ /dev/null
@@ -1,591 +0,0 @@
-/*
- * Demo on how to use /dev/crypto device for ciphering.
- *
- * Placed under public domain.
- *
- */
-#include <stdio.h>
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-
-#include <sys/ioctl.h>
-#include <crypto/cryptodev.h>
-
-#define	DATA_SIZE	(8*1024)
-#define HEADER_SIZE 193
-#define PLAINTEXT_SIZE 1021
-#define FOOTER_SIZE 15
-#define	BLOCK_SIZE	16
-#define	KEY_SIZE	16
-
-#define MAC_SIZE 20 /* SHA1 */
-
-static int
-get_sha1_hmac(int cfd, void* key, int key_size, void* data, int data_size, void* mac)
-{
-	struct session_op sess;
-	struct crypt_op cryp;
-	int i;
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	sess.cipher = 0;
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = key_size;
-	sess.mackey = key;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	/* Encrypt data.in to data.encrypted */
-	cryp.ses = sess.ses;
-	cryp.len = data_size;
-	cryp.src = data;
-	cryp.dst = NULL;
-	cryp.iv = NULL;
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static void print_buf(char* desc, unsigned char* buf, int size)
-{
-int i;
-	fputs(desc, stdout);
-	for (i=0;i<size;i++) {
-		printf("%.2x", (uint8_t)buf[i]);
-	}
-	fputs("\n", stdout);
-}
-
-static int
-test_crypto(int cfd)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-	unsigned char sha1mac[20];
-	unsigned char tag[20];
-	unsigned char mackey[] = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-	int mackey_len = 16;
-	int pad, i;
-
-	struct session_op sess;
-	struct crypt_op co;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cao, 0, sizeof(cao));
-	memset(&co, 0, sizeof(co));
-
-	memset(key,0x33,  sizeof(key));
-	memset(iv, 0x03,  sizeof(iv));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CTR;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = mackey_len;
-	sess.mackey = mackey;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
-			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
-	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, HEADER_SIZE); /* header */
-	memset(&plaintext[HEADER_SIZE], 0x17, PLAINTEXT_SIZE); /* payload */
-	memset(&plaintext[HEADER_SIZE+PLAINTEXT_SIZE], 0x22, FOOTER_SIZE);
-
-	memcpy(ciphertext, plaintext, DATA_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.len = PLAINTEXT_SIZE;
-	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
-	cao.auth_src = ciphertext;
-	cao.src = ciphertext+HEADER_SIZE;
-	cao.dst = cao.src;
-	cao.iv = iv;
-	cao.op = COP_ENCRYPT;
-	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
-	cao.tag = tag;
-	cao.tag_len = 20;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Get crypto session for AES128 */
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CTR;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	if (get_sha1_hmac(cfd, mackey, mackey_len, ciphertext, HEADER_SIZE + PLAINTEXT_SIZE + FOOTER_SIZE, sha1mac) != 0) {
-		fprintf(stderr, "SHA1 MAC failed\n");
-		return 1;
-	}
-
-	if (memcmp(tag, sha1mac, 20) != 0) {
-		fprintf(stderr, "AEAD SHA1 MAC does not match plain MAC\n");
-		print_buf("SHA1: ", sha1mac, 20);
-		print_buf("SHA1-SRTP: ", tag, 20);
-		return 1;
-	}
-
-	/* Decrypt data.encrypted to data.decrypted */
-	co.ses = sess.ses;
-	co.len = PLAINTEXT_SIZE;
-	co.src = ciphertext+HEADER_SIZE;
-	co.dst = ciphertext+HEADER_SIZE;
-	co.iv = iv;
-	co.op = COP_DECRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &co)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext+HEADER_SIZE, ciphertext+HEADER_SIZE, PLAINTEXT_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", (unsigned int)plaintext[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", (unsigned int)ciphertext[i]);
-		}
-		printf("\n");
-		return 1;
-	}
-
-	printf("Test passed\n");
-
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int
-test_encrypt_decrypt(int cfd)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-	unsigned char sha1mac[20];
-	unsigned char tag[20];
-	unsigned char mackey[] = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-	int mackey_len = 16;
-	int pad, i;
-
-	struct session_op sess;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cao, 0, sizeof(cao));
-
-	memset(key,0x33,  sizeof(key));
-	memset(iv, 0x03,  sizeof(iv));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CTR;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = mackey_len;
-	sess.mackey = mackey;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-//	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
-//			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
-	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, HEADER_SIZE); /* header */
-	memset(&plaintext[HEADER_SIZE], 0x17, PLAINTEXT_SIZE); /* payload */
-	memset(&plaintext[HEADER_SIZE+PLAINTEXT_SIZE], 0x22, FOOTER_SIZE);
-
-	memcpy(ciphertext, plaintext, DATA_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.len = PLAINTEXT_SIZE;
-	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
-	cao.auth_src = ciphertext;
-	cao.src = ciphertext+HEADER_SIZE;
-	cao.dst = cao.src;
-	cao.iv = iv;
-	cao.op = COP_ENCRYPT;
-	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
-	cao.tag = tag;
-	cao.tag_len = 20;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Get crypto session for AES128 */
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CTR;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = mackey_len;
-	sess.mackey = mackey;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	/* Decrypt data.encrypted to data.decrypted */
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.len = PLAINTEXT_SIZE;
-	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
-	cao.auth_src = ciphertext;
-	cao.src = ciphertext+HEADER_SIZE;
-	cao.dst = cao.src;
-	cao.iv = iv;
-	cao.op = COP_DECRYPT;
-	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
-	cao.tag = tag;
-	cao.tag_len = 20;
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext+HEADER_SIZE, ciphertext+HEADER_SIZE, PLAINTEXT_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", (unsigned int)plaintext[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", (unsigned int)ciphertext[i]);
-		}
-		printf("\n");
-		return 1;
-	}
-
-	printf("Test passed\n");
-
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int
-test_encrypt_decrypt_error(int cfd, int err)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-	unsigned char sha1mac[20];
-	unsigned char tag[20];
-	unsigned char mackey[] = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-	int mackey_len = 16;
-	int pad, i;
-
-	struct session_op sess;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cao, 0, sizeof(cao));
-
-	memset(key,0x33,  sizeof(key));
-	memset(iv, 0x03,  sizeof(iv));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CTR;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = mackey_len;
-	sess.mackey = mackey;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-//	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
-//			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
-	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, HEADER_SIZE); /* header */
-	memset(&plaintext[HEADER_SIZE], 0x17, PLAINTEXT_SIZE); /* payload */
-	memset(&plaintext[HEADER_SIZE+PLAINTEXT_SIZE], 0x22, FOOTER_SIZE);
-
-	memcpy(ciphertext, plaintext, DATA_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.len = PLAINTEXT_SIZE;
-	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
-	cao.auth_src = ciphertext;
-	cao.src = ciphertext+HEADER_SIZE;
-	cao.dst = cao.src;
-	cao.iv = iv;
-	cao.op = COP_ENCRYPT;
-	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
-	cao.tag = tag;
-	cao.tag_len = 20;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Get crypto session for AES128 */
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CTR;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = mackey_len;
-	sess.mackey = mackey;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	/* Decrypt data.encrypted to data.decrypted */
-	/* Encrypt data.in to data.encrypted */
-	if (err == 0)
-		ciphertext[1]++;
-	else
-		ciphertext[HEADER_SIZE+3]++;
-	cao.ses = sess.ses;
-	cao.len = PLAINTEXT_SIZE;
-	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
-	cao.auth_src = ciphertext;
-	cao.src = ciphertext+HEADER_SIZE;
-	cao.dst = cao.src;
-	cao.iv = iv;
-	cao.op = COP_DECRYPT;
-	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
-	cao.tag = tag;
-	cao.tag_len = 20;
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-			perror("ioctl(CIOCFSESSION)");
-			return 1;
-		}
-
-		printf("Test passed\n");
-		return 0;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext+HEADER_SIZE, ciphertext+HEADER_SIZE, PLAINTEXT_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", (unsigned int)plaintext[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", (unsigned int)ciphertext[i]);
-		}
-		printf("\n");
-		return 1;
-	}
-
-	printf("Test failed\n");
-
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 1;
-}
-
-int
-main()
-{
-	int fd = -1, cfd = -1;
-
-	/* Open the crypto device */
-	fd = open("/dev/crypto", O_RDWR, 0);
-	if (fd < 0) {
-		perror("open(/dev/crypto)");
-		return 1;
-	}
-
-	/* Clone file descriptor */
-	if (ioctl(fd, CRIOGET, &cfd)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	/* Set close-on-exec (not really neede here) */
-	if (fcntl(cfd, F_SETFD, 1) == -1) {
-		perror("fcntl(F_SETFD)");
-		return 1;
-	}
-
-	/* Run the test itself */
-
-	if (test_crypto(cfd))
-		return 1;
-
-	if (test_encrypt_decrypt(cfd))
-		return 1;
-
-	if (test_encrypt_decrypt_error(cfd,0))
-		return 1;
-
-	if (test_encrypt_decrypt_error(cfd,1))
-		return 1;
-
-	/* Close cloned descriptor */
-	if (close(cfd)) {
-		perror("close(cfd)");
-		return 1;
-	}
-
-	/* Close the original descriptor */
-	if (close(fd)) {
-		perror("close(fd)");
-		return 1;
-	}
-
-	return 0;
-}
-
diff --git a/drivers/staging/crypto/cryptodev/examples/cipher-aead.c b/drivers/staging/crypto/cryptodev/examples/cipher-aead.c
deleted file mode 100644
index ab29aeca8109..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/cipher-aead.c
+++ /dev/null
@@ -1,588 +0,0 @@
-/*
- * Demo on how to use /dev/crypto device for ciphering.
- *
- * Placed under public domain.
- *
- */
-#include <stdio.h>
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-
-#include <sys/ioctl.h>
-#include <crypto/cryptodev.h>
-
-#define	DATA_SIZE	(8*1024)
-#define AUTH_SIZE       31
-#define	BLOCK_SIZE	16
-#define	KEY_SIZE	16
-
-#define MAC_SIZE 20 /* SHA1 */
-
-static int
-get_sha1_hmac(int cfd, void* key, int key_size, void* data1, int data1_size, void* data2, int data2_size, void* mac)
-{
-	struct session_op sess;
-	struct crypt_op cryp;
-	int i;
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	sess.cipher = 0;
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = key_size;
-	sess.mackey = key;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	/* Encrypt data.in to data.encrypted */
-	cryp.ses = sess.ses;
-	cryp.len = data1_size;
-	cryp.src = data1;
-	cryp.dst = NULL;
-	cryp.iv = NULL;
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	cryp.flags = COP_FLAG_UPDATE;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	cryp.ses = sess.ses;
-	cryp.len = data2_size;
-	cryp.src = data2;
-	cryp.dst = NULL;
-	cryp.iv = NULL;
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	cryp.flags = COP_FLAG_FINAL;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static void print_buf(char* desc, unsigned char* buf, int size)
-{
-int i;
-	fputs(desc, stdout);
-	for (i=0;i<size;i++) {
-		printf("%.2x", (uint8_t)buf[i]);
-	}
-	fputs("\n", stdout);
-}
-
-static int
-test_crypto(int cfd)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-	char auth[AUTH_SIZE];
-	unsigned char sha1mac[20];
-	int pad, i;
-
-	struct session_op sess;
-	struct crypt_op co;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cao, 0, sizeof(cao));
-	memset(&co, 0, sizeof(co));
-
-	memset(key,0x33,  sizeof(key));
-	memset(iv, 0x03,  sizeof(iv));
-	memset(auth, 0xf1,  sizeof(auth));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = 16;
-	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
-			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
-	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, DATA_SIZE);
-
-	if (get_sha1_hmac(cfd, sess.mackey, sess.mackeylen, auth, sizeof(auth), plaintext, DATA_SIZE, sha1mac) != 0) {
-		fprintf(stderr, "SHA1 MAC failed\n");
-		return 1;
-	}
-
-	//memcpy(ciphertext, plaintext, DATA_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = DATA_SIZE;
-	cao.src = plaintext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.op = COP_ENCRYPT;
-	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, cao.len);
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Get crypto session for AES128 */
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	/* Decrypt data.encrypted to data.decrypted */
-	co.ses = sess.ses;
-	co.len = cao.len;
-	co.src = ciphertext;
-	co.dst = ciphertext;
-	co.iv = iv;
-	co.op = COP_DECRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &co)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", plaintext[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", ciphertext[i]);
-		}
-		printf("\n");
-		return 1;
-	}
-
-	pad = ciphertext[cao.len-1];
-	if (memcmp(&ciphertext[cao.len-MAC_SIZE-pad-1], sha1mac, 20) != 0) {
-		fprintf(stderr, "AEAD SHA1 MAC does not match plain MAC\n");
-		print_buf("SHA1: ", sha1mac, 20);
-		print_buf("SHA1-TLS: ", &ciphertext[cao.len-MAC_SIZE-pad-1], 20);
-		return 1;
-	}
-
-
-	for (i=0;i<pad;i++)
-		if (ciphertext[cao.len-1-i] != pad) {
-			fprintf(stderr, "Pad does not match (expected %d)\n", pad);
-			print_buf("PAD: ", &ciphertext[cao.len-1-pad], pad);
-			return 1;
-		}
-
-	printf("Test passed\n");
-
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int
-test_encrypt_decrypt(int cfd)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-	char auth[AUTH_SIZE];
-	unsigned char sha1mac[20];
-	int pad, i, enc_len;
-
-	struct session_op sess;
-	struct crypt_op co;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cao, 0, sizeof(cao));
-	memset(&co, 0, sizeof(co));
-
-	memset(key,0x33,  sizeof(key));
-	memset(iv, 0x03,  sizeof(iv));
-	memset(auth, 0xf1,  sizeof(auth));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = 16;
-	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-//	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
-//			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
-	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, DATA_SIZE);
-
-	if (get_sha1_hmac(cfd, sess.mackey, sess.mackeylen, auth, sizeof(auth), plaintext, DATA_SIZE, sha1mac) != 0) {
-		fprintf(stderr, "SHA1 MAC failed\n");
-		return 1;
-	}
-
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = DATA_SIZE;
-	cao.src = plaintext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.op = COP_ENCRYPT;
-	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-	enc_len = cao.len;
-	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, enc_len);
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Get crypto session for AES128 */
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = 16;
-	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	/* Decrypt data.encrypted to data.decrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = enc_len;
-	cao.src = ciphertext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.op = COP_DECRYPT;
-	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-	if (cao.len != DATA_SIZE) {
-		fprintf(stderr, "decrypted data size incorrect!\n");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", plaintext[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", ciphertext[i]);
-		}
-		printf("\n");
-		return 1;
-	}
-
-	printf("Test passed\n");
-
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int
-test_encrypt_decrypt_error(int cfd, int err)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-	char auth[AUTH_SIZE];
-	unsigned char sha1mac[20];
-	int pad, i, enc_len;
-
-	struct session_op sess;
-	struct crypt_op co;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cao, 0, sizeof(cao));
-	memset(&co, 0, sizeof(co));
-
-	memset(key,0x33,  sizeof(key));
-	memset(iv, 0x03,  sizeof(iv));
-	memset(auth, 0xf1,  sizeof(auth));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = 16;
-	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-//	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
-//			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
-	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, DATA_SIZE);
-
-	if (get_sha1_hmac(cfd, sess.mackey, sess.mackeylen, auth, sizeof(auth), plaintext, DATA_SIZE, sha1mac) != 0) {
-		fprintf(stderr, "SHA1 MAC failed\n");
-		return 1;
-	}
-
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = DATA_SIZE;
-	cao.src = plaintext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.op = COP_ENCRYPT;
-	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-	enc_len = cao.len;
-	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, enc_len);
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Get crypto session for AES128 */
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = 16;
-	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	if (err == 0)
-		auth[2]++;
-	else
-		ciphertext[4]++;
-
-	/* Decrypt data.encrypted to data.decrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = enc_len;
-	cao.src = ciphertext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.op = COP_DECRYPT;
-	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-			perror("ioctl(CIOCFSESSION)");
-			return 1;
-		}
-
-		printf("Test passed\n");
-		return 0;
-	}
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-
-	fprintf(stderr, "Modification to ciphertext was not detected\n");
-	return 1;
-}
-
-int
-main()
-{
-	int fd = -1, cfd = -1;
-
-	/* Open the crypto device */
-	fd = open("/dev/crypto", O_RDWR, 0);
-	if (fd < 0) {
-		perror("open(/dev/crypto)");
-		return 1;
-	}
-
-	/* Clone file descriptor */
-	if (ioctl(fd, CRIOGET, &cfd)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	/* Set close-on-exec (not really neede here) */
-	if (fcntl(cfd, F_SETFD, 1) == -1) {
-		perror("fcntl(F_SETFD)");
-		return 1;
-	}
-
-	/* Run the test itself */
-
-	if (test_crypto(cfd))
-		return 1;
-
-	if (test_encrypt_decrypt(cfd))
-		return 1;
-
-	if (test_encrypt_decrypt_error(cfd, 0))
-		return 1;
-
-	if (test_encrypt_decrypt_error(cfd, 1))
-		return 1;
-
-	/* Close cloned descriptor */
-	if (close(cfd)) {
-		perror("close(cfd)");
-		return 1;
-	}
-
-	/* Close the original descriptor */
-	if (close(fd)) {
-		perror("close(fd)");
-		return 1;
-	}
-
-	return 0;
-}
-
diff --git a/drivers/staging/crypto/cryptodev/examples/cipher-gcm.c b/drivers/staging/crypto/cryptodev/examples/cipher-gcm.c
deleted file mode 100644
index 9b5f4f947075..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/cipher-gcm.c
+++ /dev/null
@@ -1,528 +0,0 @@
-/*
- * Demo on how to use /dev/crypto device for ciphering.
- *
- * Placed under public domain.
- *
- */
-#include <stdio.h>
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-
-#include <sys/ioctl.h>
-#include <crypto/cryptodev.h>
-
-#define	DATA_SIZE	(8*1024)
-#define AUTH_SIZE       31
-#define	BLOCK_SIZE	16
-#define	KEY_SIZE	16
-
-#define my_perror(x) {fprintf(stderr, "%s: %d\n", __func__, __LINE__); perror(x); }
-
-static void print_buf(char *desc, const unsigned char *buf, int size)
-{
-	int i;
-	fputs(desc, stdout);
-	for (i = 0; i < size; i++) {
-		printf("%.2x", (uint8_t) buf[i]);
-	}
-	fputs("\n", stdout);
-}
-
-struct aes_gcm_vectors_st {
-	const uint8_t *key;
-	const uint8_t *auth;
-	int auth_size;
-	const uint8_t *plaintext;
-	int plaintext_size;
-	const uint8_t *iv;
-	const uint8_t *ciphertext;
-	const uint8_t *tag;
-};
-
-struct aes_gcm_vectors_st aes_gcm_vectors[] = {
-	{
-	 .key =
-	 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-	 .auth = NULL,
-	 .auth_size = 0,
-	 .plaintext =
-	 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-	 .plaintext_size = 16,
-	 .ciphertext =
-	 "\x03\x88\xda\xce\x60\xb6\xa3\x92\xf3\x28\xc2\xb9\x71\xb2\xfe\x78",
-	 .iv = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
-	 .tag =
-	 "\xab\x6e\x47\xd4\x2c\xec\x13\xbd\xf5\x3a\x67\xb2\x12\x57\xbd\xdf"
-	},
-	{
-	 .key =
-	 "\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08",
-	 .auth = NULL,
-	 .auth_size = 0,
-	 .plaintext =
-	 "\xd9\x31\x32\x25\xf8\x84\x06\xe5\xa5\x59\x09\xc5\xaf\xf5\x26\x9a\x86\xa7\xa9\x53\x15\x34\xf7\xda\x2e\x4c\x30\x3d\x8a\x31\x8a\x72\x1c\x3c\x0c\x95\x95\x68\x09\x53\x2f\xcf\x0e\x24\x49\xa6\xb5\x25\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57\xba\x63\x7b\x39\x1a\xaf\xd2\x55",
-	 .plaintext_size = 64,
-	 .ciphertext =
-	 "\x42\x83\x1e\xc2\x21\x77\x74\x24\x4b\x72\x21\xb7\x84\xd0\xd4\x9c\xe3\xaa\x21\x2f\x2c\x02\xa4\xe0\x35\xc1\x7e\x23\x29\xac\xa1\x2e\x21\xd5\x14\xb2\x54\x66\x93\x1c\x7d\x8f\x6a\x5a\xac\x84\xaa\x05\x1b\xa3\x0b\x39\x6a\x0a\xac\x97\x3d\x58\xe0\x91\x47\x3f\x59\x85",
-	 .iv = "\xca\xfe\xba\xbe\xfa\xce\xdb\xad\xde\xca\xf8\x88",
-	 .tag = "\x4d\x5c\x2a\xf3\x27\xcd\x64\xa6\x2c\xf3\x5a\xbd\x2b\xa6\xfa\xb4"
-	},
-	{
-	 .key =
-	 "\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08",
-	 .auth =
-	 "\xfe\xed\xfa\xce\xde\xad\xbe\xef\xfe\xed\xfa\xce\xde\xad\xbe\xef\xab\xad\xda\xd2",
-	 .auth_size = 20,
-	 .plaintext =
-	 "\xd9\x31\x32\x25\xf8\x84\x06\xe5\xa5\x59\x09\xc5\xaf\xf5\x26\x9a\x86\xa7\xa9\x53\x15\x34\xf7\xda\x2e\x4c\x30\x3d\x8a\x31\x8a\x72\x1c\x3c\x0c\x95\x95\x68\x09\x53\x2f\xcf\x0e\x24\x49\xa6\xb5\x25\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57\xba\x63\x7b\x39",
-	 .plaintext_size = 60,
-	 .ciphertext =
-	 "\x42\x83\x1e\xc2\x21\x77\x74\x24\x4b\x72\x21\xb7\x84\xd0\xd4\x9c\xe3\xaa\x21\x2f\x2c\x02\xa4\xe0\x35\xc1\x7e\x23\x29\xac\xa1\x2e\x21\xd5\x14\xb2\x54\x66\x93\x1c\x7d\x8f\x6a\x5a\xac\x84\xaa\x05\x1b\xa3\x0b\x39\x6a\x0a\xac\x97\x3d\x58\xe0\x91",
-	 .iv = "\xca\xfe\xba\xbe\xfa\xce\xdb\xad\xde\xca\xf8\x88",
-	 .tag =
-	 "\x5b\xc9\x4f\xbc\x32\x21\xa5\xdb\x94\xfa\xe9\x5a\xe7\x12\x1a\x47"
-	}
-};
-
-
-/* Test against AES-GCM test vectors.
- */
-static int test_crypto(int cfd)
-{
-	char iv[BLOCK_SIZE];
-	unsigned char tag[16];
-	int pad, i;
-	int8_t tmp[128];
-
-	struct session_op sess;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	/* Get crypto session for AES128 */
-
-	fprintf(stdout, "Tests on AES-GCM vectors: ");
-	fflush(stdout);
-	for (i = 0;
-	     i < sizeof(aes_gcm_vectors) / sizeof(aes_gcm_vectors[0]);
-	     i++) {
-		memset(&sess, 0, sizeof(sess));
-		memset(tmp, 0, sizeof(tmp));
-
-		sess.cipher = CRYPTO_AES_GCM;
-		sess.keylen = 16;
-		sess.key = (void *) aes_gcm_vectors[i].key;
-
-		if (ioctl(cfd, CIOCGSESSION, &sess)) {
-			my_perror("ioctl(CIOCGSESSION)");
-			return 1;
-		}
-
-		memset(&cao, 0, sizeof(cao));
-
-		cao.ses = sess.ses;
-		cao.dst = tmp;
-		cao.iv = (void *) aes_gcm_vectors[i].iv;
-		cao.iv_len = 12;
-		cao.op = COP_ENCRYPT;
-		cao.flags = 0;
-
-		if (aes_gcm_vectors[i].auth_size > 0) {
-			cao.auth_src = (void *) aes_gcm_vectors[i].auth;
-			cao.auth_len = aes_gcm_vectors[i].auth_size;
-		}
-
-		if (aes_gcm_vectors[i].plaintext_size > 0) {
-			cao.src = (void *) aes_gcm_vectors[i].plaintext;
-			cao.len = aes_gcm_vectors[i].plaintext_size;
-		}
-
-		if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-			my_perror("ioctl(CIOCAUTHCRYPT)");
-			return 1;
-		}
-
-		if (aes_gcm_vectors[i].plaintext_size > 0)
-			if (memcmp
-			    (tmp, aes_gcm_vectors[i].ciphertext,
-			     aes_gcm_vectors[i].plaintext_size) != 0) {
-				fprintf(stderr,
-					"AES-GCM test vector %d failed!\n",
-					i);
-
-				print_buf("Cipher: ", tmp, aes_gcm_vectors[i].plaintext_size);
-				print_buf("Expected: ", aes_gcm_vectors[i].ciphertext, aes_gcm_vectors[i].plaintext_size);
-				return 1;
-			}
-
-		if (memcmp
-		    (&tmp[cao.len - cao.tag_len], aes_gcm_vectors[i].tag,
-		     16) != 0) {
-			fprintf(stderr,
-				"AES-GCM test vector %d failed (tag)!\n",
-				i);
-
-			print_buf("Tag: ", tmp, cao.tag_len);
-			print_buf("Expected tag: ",
-				  aes_gcm_vectors[i].tag, 16);
-			return 1;
-		}
-
-	}
-	fprintf(stdout, "ok\n");
-	fprintf(stdout, "\n");
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		my_perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-/* Checks if encryption and subsequent decryption 
- * produces the same data.
- */
-static int test_encrypt_decrypt(int cfd)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-	char auth[AUTH_SIZE];
-	unsigned char sha1mac[20];
-	int pad, i, enc_len;
-
-	struct session_op sess;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	fprintf(stdout, "Tests on AES-GCM encryption/decryption: ");
-	fflush(stdout);
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cao, 0, sizeof(cao));
-
-	memset(key, 0x33, sizeof(key));
-	memset(iv, 0x03, sizeof(iv));
-	memset(auth, 0xf1, sizeof(auth));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_GCM;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		my_perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		my_perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-//      printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
-//                      siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext =
-	    (char *) (((unsigned long) plaintext_raw + siop.alignmask) &
-		      ~siop.alignmask);
-	ciphertext =
-	    (char *) (((unsigned long) ciphertext_raw + siop.alignmask) &
-		      ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, DATA_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = DATA_SIZE;
-	cao.src = plaintext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.iv_len = 12;
-	cao.op = COP_ENCRYPT;
-	cao.flags = 0;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		my_perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-	enc_len = cao.len;
-	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, enc_len);
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		my_perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Get crypto session for AES128 */
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_GCM;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		my_perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	/* Decrypt data.encrypted to data.decrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = enc_len;
-	cao.src = ciphertext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.iv_len = 12;
-	cao.op = COP_DECRYPT;
-	cao.flags = 0;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		my_perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-	if (cao.len != DATA_SIZE) {
-		fprintf(stderr, "decrypted data size incorrect!\n");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", plaintext[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", ciphertext[i]);
-		}
-		printf("\n");
-		return 1;
-	}
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		my_perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	fprintf(stdout, "ok\n");
-	fprintf(stdout, "\n");
-
-	return 0;
-}
-
-static int test_encrypt_decrypt_error(int cfd, int err)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-	char auth[AUTH_SIZE];
-	int pad, i, enc_len;
-
-	struct session_op sess;
-	struct crypt_op co;
-	struct crypt_auth_op cao;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	fprintf(stdout, "Tests on AES-GCM tag verification: ");
-	fflush(stdout);
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cao, 0, sizeof(cao));
-	memset(&co, 0, sizeof(co));
-
-	memset(key, 0x33, sizeof(key));
-	memset(iv, 0x03, sizeof(iv));
-	memset(auth, 0xf1, sizeof(auth));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = 16;
-	sess.mackey =
-	    (uint8_t *)
-	    "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		my_perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		my_perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-//      printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
-//                      siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext =
-	    (char *) (((unsigned long) plaintext_raw + siop.alignmask) &
-		      ~siop.alignmask);
-	ciphertext =
-	    (char *) (((unsigned long) ciphertext_raw + siop.alignmask) &
-		      ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, DATA_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = DATA_SIZE;
-	cao.src = plaintext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.op = COP_ENCRYPT;
-	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
-
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		my_perror("ioctl(CIOCAUTHCRYPT)");
-		return 1;
-	}
-
-	enc_len = cao.len;
-	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, enc_len);
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		my_perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	/* Get crypto session for AES128 */
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.mackeylen = 16;
-	sess.mackey =
-	    (uint8_t *)
-	    "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		my_perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-	if (err == 0)
-		auth[2]++;
-	else
-		ciphertext[4]++;
-
-	/* Decrypt data.encrypted to data.decrypted */
-	cao.ses = sess.ses;
-	cao.auth_src = auth;
-	cao.auth_len = sizeof(auth);
-	cao.len = enc_len;
-	cao.src = ciphertext;
-	cao.dst = ciphertext;
-	cao.iv = iv;
-	cao.op = COP_DECRYPT;
-	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
-	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
-		if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-			my_perror("ioctl(CIOCFSESSION)");
-			return 1;
-		}
-
-		fprintf(stdout, "ok\n");
-		fprintf(stdout, "\n");
-		return 0;
-	}
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		my_perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-
-	fprintf(stderr, "Modification to ciphertext was not detected\n");
-	return 1;
-}
-
-int main()
-{
-	int fd = -1, cfd = -1;
-
-	/* Open the crypto device */
-	fd = open("/dev/crypto", O_RDWR, 0);
-	if (fd < 0) {
-		my_perror("open(/dev/crypto)");
-		return 1;
-	}
-
-	/* Clone file descriptor */
-	if (ioctl(fd, CRIOGET, &cfd)) {
-		my_perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	/* Set close-on-exec (not really neede here) */
-	if (fcntl(cfd, F_SETFD, 1) == -1) {
-		my_perror("fcntl(F_SETFD)");
-		return 1;
-	}
-
-	/* Run the test itself */
-
-	if (test_crypto(cfd))
-		return 1;
-
-	if (test_encrypt_decrypt(cfd))
-		return 1;
-
-	if (test_encrypt_decrypt_error(cfd, 0))
-		return 1;
-
-	if (test_encrypt_decrypt_error(cfd, 1))
-		return 1;
-
-	/* Close cloned descriptor */
-	if (close(cfd)) {
-		my_perror("close(cfd)");
-		return 1;
-	}
-
-	/* Close the original descriptor */
-	if (close(fd)) {
-		my_perror("close(fd)");
-		return 1;
-	}
-
-	return 0;
-}
diff --git a/drivers/staging/crypto/cryptodev/examples/cipher.c b/drivers/staging/crypto/cryptodev/examples/cipher.c
deleted file mode 100644
index 007d3fefa020..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/cipher.c
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Demo on how to use /dev/crypto device for ciphering.
- *
- * Placed under public domain.
- *
- */
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-
-#include <sys/ioctl.h>
-#include <crypto/cryptodev.h>
-
-#define	DATA_SIZE	8*1024
-#define	BLOCK_SIZE	16
-#define	KEY_SIZE	16
-
-static int
-test_crypto(int cfd)
-{
-	char plaintext_raw[DATA_SIZE + 63], *plaintext;
-	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
-	char iv[BLOCK_SIZE];
-	char key[KEY_SIZE];
-
-	struct session_op sess;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-	struct crypt_op cryp;
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	memset(key, 0x33,  sizeof(key));
-	memset(iv, 0x03,  sizeof(iv));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested cipher CRYPTO_AES_CBC, got %s with driver %s\n",
-			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
-	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext = plaintext_raw;
-	ciphertext = ciphertext_raw;
-#endif
-	memset(plaintext, 0x15, DATA_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cryp.ses = sess.ses;
-	cryp.len = DATA_SIZE;
-	cryp.src = plaintext;
-	cryp.dst = ciphertext;
-	cryp.iv = iv;
-	cryp.op = COP_ENCRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested cipher CRYPTO_AES_CBC, got %s with driver %s\n",
-			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-#endif
-
-	/* Decrypt data.encrypted to data.decrypted */
-	cryp.ses = sess.ses;
-	cryp.len = DATA_SIZE;
-	cryp.src = ciphertext;
-	cryp.dst = ciphertext;
-	cryp.iv = iv;
-	cryp.op = COP_DECRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", plaintext[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < DATA_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", ciphertext[i]);
-		}
-		printf("\n");
-		return 1;
-	} else
-		printf("Test passed\n");
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int test_aes(int cfd)
-{
-	char plaintext1_raw[BLOCK_SIZE + 63], *plaintext1;
-	char ciphertext1[BLOCK_SIZE] = { 0xdf, 0x55, 0x6a, 0x33, 0x43, 0x8d, 0xb8, 0x7b, 0xc4, 0x1b, 0x17, 0x52, 0xc5, 0x5e, 0x5e, 0x49 };
-	char iv1[BLOCK_SIZE];
-	char key1[KEY_SIZE] = { 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-	char plaintext2_data[BLOCK_SIZE] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00 };
-	char plaintext2_raw[BLOCK_SIZE + 63], *plaintext2;
-	char ciphertext2[BLOCK_SIZE] = { 0xb7, 0x97, 0x2b, 0x39, 0x41, 0xc4, 0x4b, 0x90, 0xaf, 0xa7, 0xb2, 0x64, 0xbf, 0xba, 0x73, 0x87 };
-	char iv2[BLOCK_SIZE];
-	char key2[KEY_SIZE];
-
-	struct session_op sess;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-	struct crypt_op cryp;
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key1;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	plaintext1 = (char *)(((unsigned long)plaintext1_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext1 = plaintext1_raw;
-#endif
-	memset(plaintext1, 0x0, BLOCK_SIZE);
-	memset(iv1, 0x0, sizeof(iv1));
-
-	/* Encrypt data.in to data.encrypted */
-	cryp.ses = sess.ses;
-	cryp.len = BLOCK_SIZE;
-	cryp.src = plaintext1;
-	cryp.dst = plaintext1;
-	cryp.iv = iv1;
-	cryp.op = COP_ENCRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext1, ciphertext1, BLOCK_SIZE) != 0) {
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		return 1;
-	}
-
-	/* Test 2 */
-
-	memset(key2, 0x0, sizeof(key2));
-	memset(iv2, 0x0, sizeof(iv2));
-
-	/* Get crypto session for AES128 */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = KEY_SIZE;
-	sess.key = key2;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested cipher CRYPTO_AES_CBC, got %s with driver %s\n",
-			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
-
-	plaintext2 = (char *)(((unsigned long)plaintext2_raw + siop.alignmask) & ~siop.alignmask);
-#else
-	plaintext2 = plaintext2_raw;
-#endif
-	memcpy(plaintext2, plaintext2_data, BLOCK_SIZE);
-
-	/* Encrypt data.in to data.encrypted */
-	cryp.ses = sess.ses;
-	cryp.len = BLOCK_SIZE;
-	cryp.src = plaintext2;
-	cryp.dst = plaintext2;
-	cryp.iv = iv2;
-	cryp.op = COP_ENCRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(plaintext2, ciphertext2, BLOCK_SIZE) != 0) {
-		int i;
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		printf("plaintext:");
-		for (i = 0; i < BLOCK_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", plaintext2[i]);
-		}
-		printf("ciphertext:");
-		for (i = 0; i < BLOCK_SIZE; i++) {
-			if ((i % 30) == 0)
-				printf("\n");
-			printf("%02x ", ciphertext2[i]);
-		}
-		printf("\n");
-		return 1;
-	}
-
-	printf("AES Test passed\n");
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-int
-main()
-{
-	int fd = -1, cfd = -1;
-
-	/* Open the crypto device */
-	fd = open("/dev/crypto", O_RDWR, 0);
-	if (fd < 0) {
-		perror("open(/dev/crypto)");
-		return 1;
-	}
-
-	/* Clone file descriptor */
-	if (ioctl(fd, CRIOGET, &cfd)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	/* Set close-on-exec (not really neede here) */
-	if (fcntl(cfd, F_SETFD, 1) == -1) {
-		perror("fcntl(F_SETFD)");
-		return 1;
-	}
-
-	/* Run the test itself */
-	if (test_aes(cfd))
-		return 1;
-
-	if (test_crypto(cfd))
-		return 1;
-
-	/* Close cloned descriptor */
-	if (close(cfd)) {
-		perror("close(cfd)");
-		return 1;
-	}
-
-	/* Close the original descriptor */
-	if (close(fd)) {
-		perror("close(fd)");
-		return 1;
-	}
-
-	return 0;
-}
-
diff --git a/drivers/staging/crypto/cryptodev/examples/fullspeed.c b/drivers/staging/crypto/cryptodev/examples/fullspeed.c
deleted file mode 100644
index 611859d32ded..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/fullspeed.c
+++ /dev/null
@@ -1,184 +0,0 @@
-/*  cryptodev_test - simple benchmark tool for cryptodev
- *
- *    Copyright (C) 2010 by Phil Sutter <phil.sutter@viprinet.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <signal.h>
-#include <unistd.h>
-
-#include <crypto/cryptodev.h>
-
-static int si = 1; /* SI by default */
-
-static double udifftimeval(struct timeval start, struct timeval end)
-{
-	return (double)(end.tv_usec - start.tv_usec) +
-	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
-}
-
-static int must_finish = 0;
-
-static void alarm_handler(int signo)
-{
-        must_finish = 1;
-}
-
-static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
-static char *si_units[] = { "", "K", "M", "G", "T", 0};
-
-static void value2human(int si, double bytes, double time, double* data, double* speed,char* metric)
-{
-	int unit = 0;
-
-	*data = bytes;
-	
-	if (si) {
-		while (*data > 1000 && si_units[unit + 1]) {
-			*data /= 1000;
-			unit++;
-		}
-		*speed = *data / time;
-		sprintf(metric, "%sB", si_units[unit]);
-	} else {
-		while (*data > 1024 && units[unit + 1]) {
-			*data /= 1024;
-			unit++;
-		}
-		*speed = *data / time;
-		sprintf(metric, "%sB", units[unit]);
-	}
-}
-
-#define MAX(x,y) ((x)>(y)?(x):(y))
-
-int encrypt_data(int algo, void* keybuf, int key_size, int fdc, int chunksize)
-{
-	struct crypt_op cop;
-	char *buffer, iv[32];
-	static int val = 23;
-	struct timeval start, end;
-	double total = 0;
-	double secs, ddata, dspeed;
-	char metric[16];
-	struct session_op sess;
-
-	if (posix_memalign((void **)&buffer, 16, chunksize)) {
-		printf("posix_memalign() failed! (mask %x, size: %d)\n", 16, chunksize);
-		return 1;
-	}
-
-	memset(iv, 0x23, 32);
-
-	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
-	fflush(stdout);
-
-	memset(buffer, val++, chunksize);
-
-	must_finish = 0;
-	alarm(5);
-
-	gettimeofday(&start, NULL);
-	do {
-		memset(&sess, 0, sizeof(sess));
-		sess.cipher = algo;
-		sess.keylen = key_size;
-		sess.key = keybuf;
-		if (ioctl(fdc, CIOCGSESSION, &sess)) {
-			perror("ioctl(CIOCGSESSION)");
-			return 1;
-		}
-
-		memset(&cop, 0, sizeof(cop));
-		cop.ses = sess.ses;
-		cop.len = chunksize;
-		cop.iv = (unsigned char *)iv;
-		cop.op = COP_ENCRYPT;
-		cop.src = (unsigned char *)buffer;
-		cop.dst = buffer;
-
-		if (ioctl(fdc, CIOCCRYPT, &cop)) {
-			perror("ioctl(CIOCCRYPT)");
-			return 1;
-		}
-		
-		ioctl(fdc, CIOCFSESSION, &sess.ses);
-
-		total+=chunksize;
-	} while(must_finish==0);
-	gettimeofday(&end, NULL);
-
-	secs = udifftimeval(start, end)/ 1000000.0;
-
-	value2human(si, total, secs, &ddata, &dspeed, metric);
-	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
-	printf ("%.2f %s/sec\n", dspeed, metric);
-
-	free(buffer);
-	return 0;
-}
-
-int main(int argc, char** argv)
-{
-	int fd, i, fdc = -1;
-	char keybuf[32];
-
-	signal(SIGALRM, alarm_handler);
-	
-	if (argc > 1) {
-		if (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0) {
-			printf("Usage: speed [--kib]\n");
-			exit(0);
-		}
-		if (strcmp(argv[1], "--kib") == 0) {
-			si = 0;
-		}
-	}
-
-	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
-		perror("open()");
-		return 1;
-	}
-	if (ioctl(fd, CRIOGET, &fdc)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	fprintf(stderr, "Testing NULL cipher: \n");
-
-	for (i = 512; i <= (64 * 1024); i *= 2) {
-		if (encrypt_data(CRYPTO_NULL, keybuf, 0, fdc, i))
-			break;
-	}
-
-	fprintf(stderr, "\nTesting AES-128-CBC cipher: \n");
-	memset(keybuf, 0x42, 16);
-
-	for (i = 512; i <= (64 * 1024); i *= 2) {
-		if (encrypt_data(CRYPTO_AES_CBC, keybuf, 16, fdc, i))
-			break;
-	}
-
-	close(fdc);
-	close(fd);
-	return 0;
-}
diff --git a/drivers/staging/crypto/cryptodev/examples/hashcrypt_speed.c b/drivers/staging/crypto/cryptodev/examples/hashcrypt_speed.c
deleted file mode 100644
index e60b73d8b274..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/hashcrypt_speed.c
+++ /dev/null
@@ -1,206 +0,0 @@
-/*  hashcrypt_speed - simple SHA+AES benchmark tool for cryptodev
- *
- *    Copyright (C) 2011 by Phil Sutter <phil.sutter@viprinet.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <signal.h>
-#include <crypto/cryptodev.h>
-
-#define MAX(x,y) ((x)>(y)?(x):(y))
-
-static double udifftimeval(struct timeval start, struct timeval end)
-{
-	return (double)(end.tv_usec - start.tv_usec) +
-	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
-}
-
-static int must_finish = 0;
-
-static void alarm_handler(int signo)
-{
-        must_finish = 1;
-}
-
-static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
-static char *si_units[] = { "", "K", "M", "G", "T", 0};
-
-static void value2human(int si, double bytes, double time, double* data, double* speed,char* metric)
-{
-	int unit = 0;
-
-	*data = bytes;
-
-	if (si) {
-		while (*data > 1000 && si_units[unit + 1]) {
-			*data /= 1000;
-			unit++;
-		}
-		*speed = *data / time;
-		sprintf(metric, "%sB", si_units[unit]);
-	} else {
-		while (*data > 1024 && units[unit + 1]) {
-			*data /= 1024;
-			unit++;
-		}
-		*speed = *data / time;
-		sprintf(metric, "%sB", units[unit]);
-	}
-}
-
-
-int hash_data(struct session_op *sess, int fdc, int chunksize, int align)
-{
-	struct crypt_op cop;
-	char *buffer;
-	static int val = 23;
-	struct timeval start, end;
-	double total = 0;
-	double secs, ddata, dspeed;
-	char metric[16];
-	uint8_t mac[AALG_MAX_RESULT_LEN];
-
-	if (align) {
-		if (posix_memalign((void **)&buffer, align, chunksize)) {
-			printf("posix_memalign() failed, align: %d, size: %d!\n", align, chunksize);
-			return 1;
-		}
-	} else {
-		if (!(buffer = malloc(chunksize))) {
-			perror("malloc()");
-			return 1;
-		}
-	}
-
-	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
-	fflush(stdout);
-
-	memset(buffer, val++, chunksize);
-
-	must_finish = 0;
-	alarm(5);
-
-	gettimeofday(&start, NULL);
-	do {
-		memset(&cop, 0, sizeof(cop));
-		cop.ses = sess->ses;
-		cop.len = chunksize;
-		cop.op = COP_ENCRYPT;
-		cop.src = cop.dst = (unsigned char *)buffer;
-		cop.mac = mac;
-
-		if (ioctl(fdc, CIOCCRYPT, &cop)) {
-			perror("ioctl(CIOCCRYPT)");
-			return 1;
-		}
-		total+=chunksize;
-	} while(must_finish==0);
-	gettimeofday(&end, NULL);
-
-	secs = udifftimeval(start, end)/ 1000000.0;
-
-	value2human(1, total, secs, &ddata, &dspeed, metric);
-	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
-	printf ("%.2f %s/sec\n", dspeed, metric);
-
-	free(buffer);
-	return 0;
-}
-
-int main(void)
-{
-	int fd, i, fdc = -1, align = 0;
-	struct session_op sess;
-	char keybuf[32];
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	signal(SIGALRM, alarm_handler);
-
-	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
-		perror("open()");
-		return 1;
-	}
-	if (ioctl(fd, CRIOGET, &fdc)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	fprintf(stderr, "Testing AES128 with SHA1 Hash: \n");
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = 16;
-	memset(keybuf, 0x42, 32);
-	sess.key = (unsigned char *)keybuf;
-	sess.mac = CRYPTO_SHA1;
-	if (ioctl(fdc, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested hash CRYPTO_SHA1, got %s with driver %s\n",
-			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
-	align = MAX(sizeof(void*), siop.alignmask+1);
-#endif
-
-	for (i = 256; i <= (64 * 1024); i *= 4) {
-		if (hash_data(&sess, fdc, i, align))
-			break;
-	}
-
-	fprintf(stderr, "\nTesting AES256 with SHA256 Hash: \n");
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = 32;
-	sess.key = (unsigned char *)keybuf;
-	sess.mac = CRYPTO_SHA2_256;
-	if (ioctl(fdc, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested hash CRYPTO_SHA2_256, got %s with driver %s\n",
-			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
-	align = MAX(sizeof(void*), siop.alignmask+1);
-#endif
-
-	for (i = 256; i <= (64 * 1024); i *= 4) {
-		if (hash_data(&sess, fdc, i, align))
-			break;
-	}
-
-	close(fdc);
-	close(fd);
-	return 0;
-}
diff --git a/drivers/staging/crypto/cryptodev/examples/hmac.c b/drivers/staging/crypto/cryptodev/examples/hmac.c
deleted file mode 100644
index 549e9462e483..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/hmac.c
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
- * Demo on how to use /dev/crypto device for HMAC.
- *
- * Placed under public domain.
- *
- */
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <stdint.h>
-
-#include <sys/ioctl.h>
-#include <crypto/cryptodev.h>
-
-#define	DATA_SIZE	4096
-#define	BLOCK_SIZE	16
-#define	KEY_SIZE	16
-#define SHA1_HASH_LEN   20
-
-static int
-test_crypto(int cfd)
-{
-	struct {
-		uint8_t	in[DATA_SIZE],
-			encrypted[DATA_SIZE],
-			decrypted[DATA_SIZE],
-			iv[BLOCK_SIZE],
-			key[KEY_SIZE];
-	} data;
-	struct session_op sess;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-	struct crypt_op cryp;
-	uint8_t mac[AALG_MAX_RESULT_LEN];
-	uint8_t oldmac[AALG_MAX_RESULT_LEN];
-	uint8_t md5_hmac_out[] = "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38";
-	uint8_t sha1_out[] = "\x8f\x82\x03\x94\xf9\x53\x35\x18\x20\x45\xda\x24\xf3\x4d\xe5\x2b\xf8\xbc\x34\x32";
-	int i;
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	/* Use the garbage that is on the stack :-) */
-	/* memset(&data, 0, sizeof(data)); */
-
-	/* SHA1 plain test */
-	memset(mac, 0, sizeof(mac));
-
-	sess.cipher = 0;
-	sess.mac = CRYPTO_SHA1;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested mac CRYPTO_SHA1, got %s with driver %s\n",
-			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
-#endif
-
-	cryp.ses = sess.ses;
-	cryp.len = sizeof("what do ya want for nothing?")-1;
-	cryp.src = "what do ya want for nothing?";
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	if (memcmp(mac, sha1_out, 20)!=0) {
-		printf("mac: ");
-		for (i=0;i<SHA1_HASH_LEN;i++) {
-			printf("%.2x", (uint8_t)mac[i]);
-		}
-		puts("\n");
-		fprintf(stderr, "HASH test 1: failed\n");
-	} else {
-		fprintf(stderr, "HASH test 1: passed\n");
-	}
-
-	/* MD5-HMAC test */
-	memset(mac, 0, sizeof(mac));
-
-	sess.cipher = 0;
-	sess.mackey = (uint8_t*)"Jefe";
-	sess.mackeylen = 4;
-	sess.mac = CRYPTO_MD5_HMAC;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested mac CRYPTO_MD5_HMAC, got %s with driver %s\n",
-			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
-#endif
-
-	cryp.ses = sess.ses;
-	cryp.len = sizeof("what do ya want for nothing?")-1;
-	cryp.src = "what do ya want for nothing?";
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	if (memcmp(mac, md5_hmac_out, 16)!=0) {
-		printf("mac: ");
-		for (i=0;i<SHA1_HASH_LEN;i++) {
-			printf("%.2x", (uint8_t)mac[i]);
-		}
-		puts("\n");
-		fprintf(stderr, "HMAC test 1: failed\n");
-	} else {
-		fprintf(stderr, "HMAC test 1: passed\n");
-	}
-
-	/* Hash and encryption in one step test */
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.mac = CRYPTO_SHA1_HMAC;
-	sess.keylen = KEY_SIZE;
-	sess.key = data.key;
-	sess.mackeylen = 16;
-	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested cipher CRYPTO_AES_CBC and mac CRYPTO_SHA1_HMAC,"
-	       " got cipher %s with driver %s and hash %s with driver %s\n",
-			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name,
-			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
-#endif
-
-	/* Encrypt data.in to data.encrypted */
-	cryp.ses = sess.ses;
-	cryp.len = sizeof(data.in);
-	cryp.src = data.in;
-	cryp.dst = data.encrypted;
-	cryp.iv = data.iv;
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	memcpy(oldmac, mac, sizeof(mac));
-
-	/* Decrypt data.encrypted to data.decrypted */
-	cryp.src = data.encrypted;
-	cryp.dst = data.decrypted;
-	cryp.op = COP_DECRYPT;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	/* Verify the result */
-	if (memcmp(data.in, data.decrypted, sizeof(data.in)) != 0) {
-		fprintf(stderr,
-			"FAIL: Decrypted data are different from the input data.\n");
-		return 1;
-	} else
-		printf("Crypt Test: passed\n");
-
-	if (memcmp(mac, oldmac, 20) != 0) {
-		fprintf(stderr,
-			"FAIL: Hash in decrypted data different than in encrypted.\n");
-		return 1;
-	} else
-		printf("HMAC Test 2: passed\n");
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int
-test_extras(int cfd)
-{
-	struct session_op sess;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-	struct crypt_op cryp;
-	uint8_t mac[AALG_MAX_RESULT_LEN];
-	uint8_t oldmac[AALG_MAX_RESULT_LEN];
-	uint8_t md5_hmac_out[] = "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38";
-	uint8_t sha1_out[] = "\x8f\x82\x03\x94\xf9\x53\x35\x18\x20\x45\xda\x24\xf3\x4d\xe5\x2b\xf8\xbc\x34\x32";
-	int i;
-
-	memset(&sess, 0, sizeof(sess));
-	memset(&cryp, 0, sizeof(cryp));
-
-	/* Use the garbage that is on the stack :-) */
-	/* memset(&data, 0, sizeof(data)); */
-
-	/* SHA1 plain test */
-	memset(mac, 0, sizeof(mac));
-
-	sess.cipher = 0;
-	sess.mac = CRYPTO_SHA1;
-	if (ioctl(cfd, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested mac CRYPTO_SHA1, got %s with driver %s\n",
-			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
-#endif
-
-	cryp.ses = sess.ses;
-	cryp.len = sizeof("what do")-1;
-	cryp.src = "what do";
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	cryp.flags = COP_FLAG_UPDATE;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	cryp.ses = sess.ses;
-	cryp.len = sizeof(" ya want for nothing?")-1;
-	cryp.src = " ya want for nothing?";
-	cryp.mac = mac;
-	cryp.op = COP_ENCRYPT;
-	cryp.flags = COP_FLAG_FINAL;
-	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-
-	if (memcmp(mac, sha1_out, 20)!=0) {
-		printf("mac: ");
-		for (i=0;i<SHA1_HASH_LEN;i++) {
-			printf("%.2x", (uint8_t)mac[i]);
-		}
-		puts("\n");
-		fprintf(stderr, "HASH test [update]: failed\n");
-	} else {
-		fprintf(stderr, "HASH test [update]: passed\n");
-	}
-
-	memset(mac, 0, sizeof(mac));
-
-	/* Finish crypto session */
-	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
-		perror("ioctl(CIOCFSESSION)");
-		return 1;
-	}
-
-	return 0;
-}
-
-
-int
-main()
-{
-	int fd = -1, cfd = -1;
-
-	/* Open the crypto device */
-	fd = open("/dev/crypto", O_RDWR, 0);
-	if (fd < 0) {
-		perror("open(/dev/crypto)");
-		return 1;
-	}
-
-	/* Clone file descriptor */
-	if (ioctl(fd, CRIOGET, &cfd)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	/* Set close-on-exec (not really neede here) */
-	if (fcntl(cfd, F_SETFD, 1) == -1) {
-		perror("fcntl(F_SETFD)");
-		return 1;
-	}
-
-	/* Run the test itself */
-	if (test_crypto(cfd))
-		return 1;
-
-	if (test_extras(cfd))
-		return 1;
-
-	/* Close cloned descriptor */
-	if (close(cfd)) {
-		perror("close(cfd)");
-		return 1;
-	}
-
-	/* Close the original descriptor */
-	if (close(fd)) {
-		perror("close(fd)");
-		return 1;
-	}
-
-	return 0;
-}
diff --git a/drivers/staging/crypto/cryptodev/examples/sha.c b/drivers/staging/crypto/cryptodev/examples/sha.c
new file mode 100644
index 000000000000..00c739151ea3
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/examples/sha.c
@@ -0,0 +1,137 @@
+/*
+ * Demo on how to use /dev/crypto device for ciphering.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+#include "aes.h"
+
+#define	KEY_SIZE	16
+
+
+int sha_ctx_init(struct cryptodev_ctx* ctx, int cfd, const uint8_t *key, unsigned int key_size)
+{
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	memset(ctx, 0, sizeof(*ctx));
+	ctx->cfd = cfd;
+
+	if (key == NULL)
+		ctx->sess.mac = CRYPTO_SHA1;
+	else {
+		ctx->sess.mac = CRYPTO_SHA1_HMAC;
+		ctx->sess.mackeylen = key_size;
+		ctx->sess.mackey = (void*)key;
+	}
+	if (ioctl(ctx->cfd, CIOCGSESSION, &ctx->sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return -1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = ctx->sess.ses;
+	if (ioctl(ctx->cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return -1;
+	}
+	printf("requested SHA, got %s with driver %s\n",
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+	/*printf("Alignmask is %x\n", (unsigned int)siop.alignmask);*/
+	ctx->alignmask = siop.alignmask;
+#endif
+	return 0;
+}
+
+void sha_ctx_deinit(struct cryptodev_ctx* ctx) 
+{
+	if (ioctl(ctx->cfd, CIOCFSESSION, &ctx->sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+	}
+}
+
+int
+sha_hash(struct cryptodev_ctx* ctx, const void* text, size_t size, void* digest)
+{
+	struct crypt_op cryp;
+	void* p;
+	
+	/* check text and ciphertext alignment */
+	if (ctx->alignmask) {
+		p = (void*)(((unsigned long)text + ctx->alignmask) & ~ctx->alignmask);
+		if (text != p) {
+			fprintf(stderr, "text is not aligned\n");
+			return -1;
+		}
+	}
+
+	memset(&cryp, 0, sizeof(cryp));
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = ctx->sess.ses;
+	cryp.len = size;
+	cryp.src = (void*)text;
+	cryp.mac = digest;
+	if (ioctl(ctx->cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+main()
+{
+	int cfd = -1, i;
+	struct cryptodev_ctx ctx;
+	uint8_t digest[20];
+	char text[] = "The quick brown fox jumps over the lazy dog";
+	uint8_t expected[] = "\x2f\xd4\xe1\xc6\x7a\x2d\x28\xfc\xed\x84\x9e\xe1\xbb\x76\xe7\x39\x1b\x93\xeb\x12";
+
+	/* Open the crypto device */
+	cfd = open("/dev/crypto", O_RDWR, 0);
+	if (cfd < 0) {
+		perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	sha_ctx_init(&ctx, cfd, NULL, 0);
+	
+	sha_hash(&ctx, text, strlen(text), digest);
+	
+	sha_ctx_deinit(&ctx);
+
+	printf("digest: ");
+	for (i = 0; i < 20; i++) {
+		printf("%02x:", digest[i]);
+	}
+	printf("\n");
+	
+	if (memcmp(digest, expected, 20) != 0) {
+		fprintf(stderr, "SHA1 hashing failed\n");
+		return 1;
+	}
+
+	/* Close the original descriptor */
+	if (close(cfd)) {
+		perror("close(cfd)");
+		return 1;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/staging/crypto/cryptodev/examples/sha.h b/drivers/staging/crypto/cryptodev/examples/sha.h
new file mode 100644
index 000000000000..ed0b8cee4252
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/examples/sha.h
@@ -0,0 +1,16 @@
+#ifndef SHA_H
+# define SHA_H
+
+#include <stdint.h>
+
+struct cryptodev_ctx {
+	int cfd;
+	struct session_op sess;
+	uint16_t alignmask;
+};
+
+int sha_ctx_init(struct cryptodev_ctx* ctx, int cfd, const uint8_t *key, unsigned int key_size);
+void sha_ctx_deinit();
+int sha_hash(struct cryptodev_ctx* ctx, const void* text, size_t size, void* digest);
+
+#endif
diff --git a/drivers/staging/crypto/cryptodev/examples/sha_speed.c b/drivers/staging/crypto/cryptodev/examples/sha_speed.c
deleted file mode 100644
index e1dc54ba5485..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/sha_speed.c
+++ /dev/null
@@ -1,198 +0,0 @@
-/*  sha_speed - simple SHA benchmark tool for cryptodev
- *
- *    Copyright (C) 2011 by Phil Sutter <phil.sutter@viprinet.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <signal.h>
-
-#include <crypto/cryptodev.h>
-
-static double udifftimeval(struct timeval start, struct timeval end)
-{
-	return (double)(end.tv_usec - start.tv_usec) +
-	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
-}
-
-static int must_finish = 0;
-
-static void alarm_handler(int signo)
-{
-        must_finish = 1;
-}
-
-static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
-static char *si_units[] = { "", "K", "M", "G", "T", 0};
-
-static void value2human(int si, double bytes, double time, double* data, double* speed,char* metric)
-{
-	int unit = 0;
-
-	*data = bytes;
-
-	if (si) {
-		while (*data > 1000 && si_units[unit + 1]) {
-			*data /= 1000;
-			unit++;
-		}
-		*speed = *data / time;
-		sprintf(metric, "%sB", si_units[unit]);
-	} else {
-		while (*data > 1024 && units[unit + 1]) {
-			*data /= 1024;
-			unit++;
-		}
-		*speed = *data / time;
-		sprintf(metric, "%sB", units[unit]);
-	}
-}
-
-
-int hash_data(struct session_op *sess, int fdc, int chunksize, int alignmask)
-{
-	struct crypt_op cop;
-	char *buffer;
-	static int val = 23;
-	struct timeval start, end;
-	double total = 0;
-	double secs, ddata, dspeed;
-	char metric[16];
-	uint8_t mac[AALG_MAX_RESULT_LEN];
-
-	if (alignmask) {
-		if (posix_memalign((void **)&buffer, alignmask + 1, chunksize)) {
-			printf("posix_memalign() failed!\n");
-			return 1;
-		}
-	} else {
-		if (!(buffer = malloc(chunksize))) {
-			perror("malloc()");
-			return 1;
-		}
-	}
-
-	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
-	fflush(stdout);
-
-	memset(buffer, val++, chunksize);
-
-	must_finish = 0;
-	alarm(5);
-
-	gettimeofday(&start, NULL);
-	do {
-		memset(&cop, 0, sizeof(cop));
-		cop.ses = sess->ses;
-		cop.len = chunksize;
-		cop.op = COP_ENCRYPT;
-		cop.src = (unsigned char *)buffer;
-		cop.mac = mac;
-
-		if (ioctl(fdc, CIOCCRYPT, &cop)) {
-			perror("ioctl(CIOCCRYPT)");
-			return 1;
-		}
-		total+=chunksize;
-	} while(must_finish==0);
-	gettimeofday(&end, NULL);
-
-	secs = udifftimeval(start, end)/ 1000000.0;
-
-	value2human(1, total, secs, &ddata, &dspeed, metric);
-	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
-	printf ("%.2f %s/sec\n", dspeed, metric);
-
-	free(buffer);
-	return 0;
-}
-
-int main(void)
-{
-	int fd, i, fdc = -1, alignmask = 0;
-	struct session_op sess;
-	char keybuf[32];
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-
-	signal(SIGALRM, alarm_handler);
-
-	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
-		perror("open()");
-		return 1;
-	}
-	if (ioctl(fd, CRIOGET, &fdc)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	fprintf(stderr, "Testing SHA1 Hash: \n");
-	memset(&sess, 0, sizeof(sess));
-	sess.mac = CRYPTO_SHA1;
-	if (ioctl(fdc, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested hash CRYPTO_SHA1, got %s with driver %s\n",
-			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
-	alignmask = siop.alignmask;
-#endif
-
-	for (i = 256; i <= (64 * 1024); i *= 4) {
-		if (hash_data(&sess, fdc, i, alignmask))
-			break;
-	}
-
-	fprintf(stderr, "\nTesting SHA256 Hash: \n");
-	memset(&sess, 0, sizeof(sess));
-	sess.mac = CRYPTO_SHA2_256;
-	if (ioctl(fdc, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	printf("requested hash CRYPTO_SHA2_256, got %s with driver %s\n",
-			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
-	alignmask = siop.alignmask;
-#endif
-
-	for (i = 256; i <= (64 * 1024); i *= 4) {
-		if (hash_data(&sess, fdc, i, alignmask))
-			break;
-	}
-
-	close(fdc);
-	close(fd);
-	return 0;
-}
diff --git a/drivers/staging/crypto/cryptodev/examples/speed.c b/drivers/staging/crypto/cryptodev/examples/speed.c
deleted file mode 100644
index 81c5a652b907..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/speed.c
+++ /dev/null
@@ -1,212 +0,0 @@
-/*  cryptodev_test - simple benchmark tool for cryptodev
- *
- *    Copyright (C) 2010 by Phil Sutter <phil.sutter@viprinet.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <signal.h>
-
-#include <crypto/cryptodev.h>
-
-static int si = 1; /* SI by default */
-
-static double udifftimeval(struct timeval start, struct timeval end)
-{
-	return (double)(end.tv_usec - start.tv_usec) +
-	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
-}
-
-static int must_finish = 0;
-
-static void alarm_handler(int signo)
-{
-        must_finish = 1;
-}
-
-static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
-static char *si_units[] = { "", "K", "M", "G", "T", 0};
-
-static void value2human(int si, double bytes, double time, double* data, double* speed,char* metric)
-{
-	int unit = 0;
-
-	*data = bytes;
-	
-	if (si) {
-		while (*data > 1000 && si_units[unit + 1]) {
-			*data /= 1000;
-			unit++;
-		}
-		*speed = *data / time;
-		sprintf(metric, "%sB", si_units[unit]);
-	} else {
-		while (*data > 1024 && units[unit + 1]) {
-			*data /= 1024;
-			unit++;
-		}
-		*speed = *data / time;
-		sprintf(metric, "%sB", units[unit]);
-	}
-}
-
-#define MAX(x,y) ((x)>(y)?(x):(y))
-
-int encrypt_data(struct session_op *sess, int fdc, int chunksize, int alignmask)
-{
-	struct crypt_op cop;
-	char *buffer, iv[32];
-	static int val = 23;
-	struct timeval start, end;
-	double total = 0;
-	double secs, ddata, dspeed;
-	char metric[16];
-
-	if (alignmask) {
-		if (posix_memalign((void **)&buffer, MAX(alignmask + 1, sizeof(void*)), chunksize)) {
-			printf("posix_memalign() failed! (mask %x, size: %d)\n", alignmask+1, chunksize);
-			return 1;
-		}
-	} else {
-		if (!(buffer = malloc(chunksize))) {
-			perror("malloc()");
-			return 1;
-		}
-	}
-
-	memset(iv, 0x23, 32);
-
-	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
-	fflush(stdout);
-
-	memset(buffer, val++, chunksize);
-
-	must_finish = 0;
-	alarm(5);
-
-	gettimeofday(&start, NULL);
-	do {
-		memset(&cop, 0, sizeof(cop));
-		cop.ses = sess->ses;
-		cop.len = chunksize;
-		cop.iv = (unsigned char *)iv;
-		cop.op = COP_ENCRYPT;
-		cop.src = cop.dst = (unsigned char *)buffer;
-
-		if (ioctl(fdc, CIOCCRYPT, &cop)) {
-			perror("ioctl(CIOCCRYPT)");
-			return 1;
-		}
-		total+=chunksize;
-	} while(must_finish==0);
-	gettimeofday(&end, NULL);
-
-	secs = udifftimeval(start, end)/ 1000000.0;
-
-	value2human(si, total, secs, &ddata, &dspeed, metric);
-	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
-	printf ("%.2f %s/sec\n", dspeed, metric);
-
-	free(buffer);
-	return 0;
-}
-
-int main(int argc, char** argv)
-{
-	int fd, i, fdc = -1, alignmask = 0;
-	struct session_op sess;
-#ifdef CIOCGSESSINFO
-	struct session_info_op siop;
-#endif
-	char keybuf[32];
-
-	signal(SIGALRM, alarm_handler);
-	
-	if (argc > 1) {
-		if (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0) {
-			printf("Usage: speed [--kib]\n");
-			exit(0);
-		}
-		if (strcmp(argv[1], "--kib") == 0) {
-			si = 0;
-		}
-	}
-
-	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
-		perror("open()");
-		return 1;
-	}
-	if (ioctl(fd, CRIOGET, &fdc)) {
-		perror("ioctl(CRIOGET)");
-		return 1;
-	}
-
-	fprintf(stderr, "Testing NULL cipher: \n");
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_NULL;
-	sess.keylen = 0;
-	sess.key = (unsigned char *)keybuf;
-	if (ioctl(fdc, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	alignmask = siop.alignmask;
-#endif
-
-	for (i = 512; i <= (64 * 1024); i *= 2) {
-		if (encrypt_data(&sess, fdc, i, alignmask))
-			break;
-	}
-
-	fprintf(stderr, "\nTesting AES-128-CBC cipher: \n");
-	memset(&sess, 0, sizeof(sess));
-	sess.cipher = CRYPTO_AES_CBC;
-	sess.keylen = 16;
-	memset(keybuf, 0x42, 16);
-	sess.key = (unsigned char *)keybuf;
-	if (ioctl(fdc, CIOCGSESSION, &sess)) {
-		perror("ioctl(CIOCGSESSION)");
-		return 1;
-	}
-#ifdef CIOCGSESSINFO
-	siop.ses = sess.ses;
-	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
-		perror("ioctl(CIOCGSESSINFO)");
-		return 1;
-	}
-	alignmask = siop.alignmask;
-#endif
-
-	for (i = 512; i <= (64 * 1024); i *= 2) {
-		if (encrypt_data(&sess, fdc, i, alignmask))
-			break;
-	}
-
-	close(fdc);
-	close(fd);
-	return 0;
-}
diff --git a/drivers/staging/crypto/cryptodev/examples/testhelper.h b/drivers/staging/crypto/cryptodev/examples/testhelper.h
deleted file mode 100644
index ea0b100cc2ac..000000000000
--- a/drivers/staging/crypto/cryptodev/examples/testhelper.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Some helper stuff shared between the sample programs.
- */
-#ifndef _TESTHELPER_H
-#define _TESTHELPER_H
-
-/* poll until POLLOUT, then call CIOCASYNCCRYPT */
-inline int do_async_crypt(int cfd, struct crypt_op *cryp)
-{
-	struct pollfd pfd;
-
-	pfd.fd = cfd;
-	pfd.events = POLLOUT;
-
-	if (poll(&pfd, 1, -1) < 1) {
-		perror("poll()");
-		return 1;
-	}
-
-	if (ioctl(cfd, CIOCASYNCCRYPT, cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-	return 0;
-}
-
-/* poll until POLLIN, then call CIOCASYNCFETCH */
-inline int do_async_fetch(int cfd, struct crypt_op *cryp)
-{
-	struct pollfd pfd;
-
-	pfd.fd = cfd;
-	pfd.events = POLLIN;
-
-	if (poll(&pfd, 1, -1) < 1) {
-		perror("poll()");
-		return 1;
-	}
-
-	if (ioctl(cfd, CIOCASYNCFETCH, cryp)) {
-		perror("ioctl(CIOCCRYPT)");
-		return 1;
-	}
-	return 0;
-}
-
-/* Check return value of stmt for identity with goodval. If they
- * don't match, call return with the value of stmt. */
-#define DO_OR_DIE(stmt, goodval) {                           \
-	int __rc_val;                                        \
-	if ((__rc_val = stmt) != goodval) {                  \
-		perror("DO_OR_DIE(" #stmt "," #goodval ")"); \
-		return __rc_val;                             \
-	}                                                    \
-}
-
-#endif /* _TESTHELPER_H */
diff --git a/drivers/staging/crypto/cryptodev/tests/Makefile b/drivers/staging/crypto/cryptodev/tests/Makefile
new file mode 100644
index 000000000000..9a367d3043d3
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/Makefile
@@ -0,0 +1,26 @@
+KERNEL_DIR ?= /lib/modules/$(shell uname -r)/build
+KBUILD_CFLAGS += -I..
+
+hostprogs := cipher cipher-aead hmac speed async_cipher async_hmac \
+	async_speed sha_speed hashcrypt_speed fullspeed cipher-gcm \
+	cipher-aead-srtp
+
+example-cipher-objs := cipher.o
+example-cipher-aead-objs := cipher-aead.o
+example-hmac-objs := hmac.o
+example-speed-objs := speed.c
+example-fullspeed-objs := fullspeed.c
+example-sha-speed-objs := sha_speed.c
+example-async-cipher-objs := async_cipher.o
+example-async-hmac-objs := async_hmac.o
+example-async-speed-objs := async_speed.o
+example-hashcrypt-speed-objs := hashcrypt_speed.c
+
+check: $(hostprogs)
+	./cipher
+	./hmac
+	./async_cipher
+	./async_hmac
+
+clean:
+	rm -f *.o *~ $(hostprogs)
diff --git a/drivers/staging/crypto/cryptodev/tests/async_cipher.c b/drivers/staging/crypto/cryptodev/tests/async_cipher.c
new file mode 100644
index 000000000000..e89c7f2137f5
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/async_cipher.c
@@ -0,0 +1,326 @@
+/*
+ * Demo on how to use /dev/crypto device for ciphering.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <poll.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+
+#include "testhelper.h"
+
+#define	DATA_SIZE	8*1024
+#define	BLOCK_SIZE	16
+#define	KEY_SIZE	16
+
+static int
+test_crypto(int cfd)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+
+	struct session_op sess;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+	struct crypt_op cryp;
+
+	printf("running %s\n", __func__);
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	memset(key, 0x33,  sizeof(key));
+	memset(iv, 0x03,  sizeof(iv));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	printf("%s: got the session\n", __func__);
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
+	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, DATA_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = sess.ses;
+	cryp.len = DATA_SIZE;
+	cryp.src = plaintext;
+	cryp.dst = ciphertext;
+	cryp.iv = iv;
+	cryp.op = COP_ENCRYPT;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
+
+	printf("%s: data encrypted\n", __func__);
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+	printf("%s: session finished\n", __func__);
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+	printf("%s: got new session\n", __func__);
+
+	/* Decrypt data.encrypted to data.decrypted */
+	cryp.ses = sess.ses;
+	cryp.len = DATA_SIZE;
+	cryp.src = ciphertext;
+	cryp.dst = ciphertext;
+	cryp.iv = iv;
+	cryp.op = COP_DECRYPT;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
+
+	printf("%s: data encrypted\n", __func__);
+
+	/* Verify the result */
+	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		return 1;
+	} else
+		printf("Test passed\n");
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int test_aes(int cfd)
+{
+	char plaintext1_raw[BLOCK_SIZE + 63], *plaintext1;
+	char ciphertext1[BLOCK_SIZE] = { 0xdf, 0x55, 0x6a, 0x33, 0x43, 0x8d, 0xb8, 0x7b, 0xc4, 0x1b, 0x17, 0x52, 0xc5, 0x5e, 0x5e, 0x49 };
+	char iv1[BLOCK_SIZE];
+	char key1[KEY_SIZE] = { 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	char plaintext2_data[BLOCK_SIZE] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00 };
+	char plaintext2_raw[BLOCK_SIZE + 63], *plaintext2;
+	char ciphertext2[BLOCK_SIZE] = { 0xb7, 0x97, 0x2b, 0x39, 0x41, 0xc4, 0x4b, 0x90, 0xaf, 0xa7, 0xb2, 0x64, 0xbf, 0xba, 0x73, 0x87 };
+	char iv2[BLOCK_SIZE];
+	char key2[KEY_SIZE];
+
+	struct session_op sess1, sess2;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop1, siop2;
+#endif
+	struct crypt_op cryp1, cryp2;
+
+	memset(&sess1, 0, sizeof(sess1));
+	memset(&sess2, 0, sizeof(sess2));
+	memset(&cryp1, 0, sizeof(cryp1));
+	memset(&cryp2, 0, sizeof(cryp2));
+
+	/* Get crypto session for AES128 */
+	sess1.cipher = CRYPTO_AES_CBC;
+	sess1.keylen = KEY_SIZE;
+	sess1.key = key1;
+	if (ioctl(cfd, CIOCGSESSION, &sess1)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop1.ses = sess1.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop1)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	plaintext1 = (char *)(((unsigned long)plaintext1_raw + siop1.alignmask) & ~siop1.alignmask);
+#else
+	plaintext1 = plaintext1_raw;
+#endif
+	memset(plaintext1, 0x0, BLOCK_SIZE);
+
+	memset(iv1, 0x0, sizeof(iv1));
+	memset(key2, 0x0, sizeof(key2));
+
+	/* Get second crypto session for AES128 */
+	sess2.cipher = CRYPTO_AES_CBC;
+	sess2.keylen = KEY_SIZE;
+	sess2.key = key2;
+	if (ioctl(cfd, CIOCGSESSION, &sess2)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop2.ses = sess2.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop2)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	plaintext2 = (char *)(((unsigned long)plaintext2_raw + siop2.alignmask) & ~siop2.alignmask);
+#else
+	plaintext2 = plaintext2_raw;
+#endif
+	memcpy(plaintext2, plaintext2_data, BLOCK_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cryp1.ses = sess1.ses;
+	cryp1.len = BLOCK_SIZE;
+	cryp1.src = plaintext1;
+	cryp1.dst = plaintext1;
+	cryp1.iv = iv1;
+	cryp1.op = COP_ENCRYPT;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp1), 0);
+	printf("cryp1 written out\n");
+
+	memset(iv2, 0x0, sizeof(iv2));
+
+	/* Encrypt data.in to data.encrypted */
+	cryp2.ses = sess2.ses;
+	cryp2.len = BLOCK_SIZE;
+	cryp2.src = plaintext2;
+	cryp2.dst = plaintext2;
+	cryp2.iv = iv2;
+	cryp2.op = COP_ENCRYPT;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp2), 0);
+	printf("cryp2 written out\n");
+
+	DO_OR_DIE(do_async_fetch(cfd, &cryp1), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp2), 0);
+	printf("cryp1 + cryp2 successfully read\n");
+
+	/* Verify the result */
+	if (memcmp(plaintext1, ciphertext1, BLOCK_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < BLOCK_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", plaintext1[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < BLOCK_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", ciphertext1[i]);
+		}
+		printf("\n");
+		return 1;
+	} else {
+		printf("result 1 passed\n");
+	}
+
+	/* Test 2 */
+
+	/* Verify the result */
+	if (memcmp(plaintext2, ciphertext2, BLOCK_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < BLOCK_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", plaintext2[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < BLOCK_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", ciphertext2[i]);
+		}
+		printf("\n");
+		return 1;
+	} else {
+		printf("result 2 passed\n");
+	}
+
+	printf("AES Test passed\n");
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess1.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+	if (ioctl(cfd, CIOCFSESSION, &sess2.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+int
+main()
+{
+	int fd = -1, cfd = -1;
+
+	/* Open the crypto device */
+	fd = open("/dev/crypto", O_RDWR, 0);
+	if (fd < 0) {
+		perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Clone file descriptor */
+	if (ioctl(fd, CRIOGET, &cfd)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	/* Run the test itself */
+	if (test_aes(cfd))
+		return 1;
+
+	if (test_crypto(cfd))
+		return 1;
+
+	/* Close cloned descriptor */
+	if (close(cfd)) {
+		perror("close(cfd)");
+		return 1;
+	}
+
+	/* Close the original descriptor */
+	if (close(fd)) {
+		perror("close(fd)");
+		return 1;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/staging/crypto/cryptodev/tests/async_hmac.c b/drivers/staging/crypto/cryptodev/tests/async_hmac.c
new file mode 100644
index 000000000000..be0275219246
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/async_hmac.c
@@ -0,0 +1,292 @@
+/*
+ * Demo on how to use /dev/crypto device for HMAC.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <stdint.h>
+
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+
+#include "testhelper.h"
+
+#define	DATA_SIZE	4096
+#define	BLOCK_SIZE	16
+#define	KEY_SIZE	16
+#define SHA1_HASH_LEN   20
+
+static int
+test_crypto(int cfd)
+{
+	struct {
+		uint8_t	in[DATA_SIZE],
+			encrypted[DATA_SIZE],
+			decrypted[DATA_SIZE],
+			iv[BLOCK_SIZE],
+			key[KEY_SIZE];
+	} data;
+	struct session_op sess;
+	struct crypt_op cryp;
+	uint8_t mac[AALG_MAX_RESULT_LEN];
+	uint8_t oldmac[AALG_MAX_RESULT_LEN];
+	uint8_t md5_hmac_out[] = "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38";
+	uint8_t sha1_out[] = "\x8f\x82\x03\x94\xf9\x53\x35\x18\x20\x45\xda\x24\xf3\x4d\xe5\x2b\xf8\xbc\x34\x32";
+	int i;
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	/* Use the garbage that is on the stack :-) */
+	/* memset(&data, 0, sizeof(data)); */
+
+	/* SHA1 plain test */
+	memset(mac, 0, sizeof(mac));
+
+	sess.cipher = 0;
+	sess.mac = CRYPTO_SHA1;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	cryp.ses = sess.ses;
+	cryp.len = sizeof("what do ya want for nothing?")-1;
+	cryp.src = "what do ya want for nothing?";
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
+
+	if (memcmp(mac, sha1_out, 20)!=0) {
+		printf("mac: ");
+		for (i=0;i<SHA1_HASH_LEN;i++) {
+			printf("%.2x", (uint8_t)mac[i]);
+		}
+		puts("\n");
+		fprintf(stderr, "HASH test 1: failed\n");
+	} else {
+		fprintf(stderr, "HASH test 1: passed\n");
+	}
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* MD5-HMAC test */
+	memset(mac, 0, sizeof(mac));
+
+	sess.cipher = 0;
+	sess.mackey = (uint8_t*)"Jefe";
+	sess.mackeylen = 4;
+	sess.mac = CRYPTO_MD5_HMAC;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	cryp.ses = sess.ses;
+	cryp.len = sizeof("what do ya want for nothing?")-1;
+	cryp.src = "what do ya want for nothing?";
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
+
+	if (memcmp(mac, md5_hmac_out, 16)!=0) {
+		printf("mac: ");
+		for (i=0;i<SHA1_HASH_LEN;i++) {
+			printf("%.2x", (uint8_t)mac[i]);
+		}
+		puts("\n");
+		fprintf(stderr, "HMAC test 1: failed\n");
+	} else {
+		fprintf(stderr, "HMAC test 1: passed\n");
+	}
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Hash and encryption in one step test */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.keylen = KEY_SIZE;
+	sess.key = data.key;
+	sess.mackeylen = 16;
+	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = sess.ses;
+	cryp.len = sizeof(data.in);
+	cryp.src = data.in;
+	cryp.dst = data.encrypted;
+	cryp.iv = data.iv;
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
+
+	memcpy(oldmac, mac, sizeof(mac));
+
+	/* Decrypt data.encrypted to data.decrypted */
+	cryp.src = data.encrypted;
+	cryp.dst = data.decrypted;
+	cryp.op = COP_DECRYPT;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
+
+	/* Verify the result */
+	if (memcmp(data.in, data.decrypted, sizeof(data.in)) != 0) {
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		return 1;
+	} else
+		printf("Crypt Test: passed\n");
+
+	if (memcmp(mac, oldmac, 20) != 0) {
+		fprintf(stderr,
+			"FAIL: Hash in decrypted data different than in encrypted.\n");
+		return 1;
+	} else
+		printf("HMAC Test 2: passed\n");
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+test_extras(int cfd)
+{
+	struct session_op sess;
+	struct crypt_op cryp;
+	uint8_t mac[AALG_MAX_RESULT_LEN];
+	uint8_t oldmac[AALG_MAX_RESULT_LEN];
+	uint8_t md5_hmac_out[] = "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38";
+	uint8_t sha1_out[] = "\x8f\x82\x03\x94\xf9\x53\x35\x18\x20\x45\xda\x24\xf3\x4d\xe5\x2b\xf8\xbc\x34\x32";
+	int i;
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	/* Use the garbage that is on the stack :-) */
+	/* memset(&data, 0, sizeof(data)); */
+
+	/* SHA1 plain test */
+	memset(mac, 0, sizeof(mac));
+
+	sess.cipher = 0;
+	sess.mac = CRYPTO_SHA1;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	cryp.ses = sess.ses;
+	cryp.len = sizeof("what do")-1;
+	cryp.src = "what do";
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	cryp.flags = COP_FLAG_UPDATE;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
+
+	cryp.ses = sess.ses;
+	cryp.len = sizeof(" ya want for nothing?")-1;
+	cryp.src = " ya want for nothing?";
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	cryp.flags = COP_FLAG_FINAL;
+
+	DO_OR_DIE(do_async_crypt(cfd, &cryp), 0);
+	DO_OR_DIE(do_async_fetch(cfd, &cryp), 0);
+
+	if (memcmp(mac, sha1_out, 20)!=0) {
+		printf("mac: ");
+		for (i=0;i<SHA1_HASH_LEN;i++) {
+			printf("%.2x", (uint8_t)mac[i]);
+		}
+		puts("\n");
+		fprintf(stderr, "HASH test [update]: failed\n");
+	} else {
+		fprintf(stderr, "HASH test [update]: passed\n");
+	}
+
+	memset(mac, 0, sizeof(mac));
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+
+int
+main()
+{
+	int fd = -1, cfd = -1;
+
+	/* Open the crypto device */
+	fd = open("/dev/crypto", O_RDWR, 0);
+	if (fd < 0) {
+		perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Clone file descriptor */
+	if (ioctl(fd, CRIOGET, &cfd)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	/* Run the test itself */
+	if (test_crypto(cfd))
+		return 1;
+
+	if (test_extras(cfd))
+		return 1;
+
+	/* Close cloned descriptor */
+	if (close(cfd)) {
+		perror("close(cfd)");
+		return 1;
+	}
+
+	/* Close the original descriptor */
+	if (close(fd)) {
+		perror("close(fd)");
+		return 1;
+	}
+
+	return 0;
+}
diff --git a/drivers/staging/crypto/cryptodev/tests/async_speed.c b/drivers/staging/crypto/cryptodev/tests/async_speed.c
new file mode 100644
index 000000000000..4aea5e386533
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/async_speed.c
@@ -0,0 +1,215 @@
+/*  cryptodev_test - simple benchmark tool for cryptodev
+ *
+ *    Copyright (C) 2010 by Phil Sutter <phil.sutter@viprinet.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <crypto/cryptodev.h>
+
+static double udifftimeval(struct timeval start, struct timeval end)
+{
+	return (double)(end.tv_usec - start.tv_usec) +
+	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
+}
+
+static int must_finish = 0;
+static struct pollfd pfd;
+
+static void alarm_handler(int signo)
+{
+        must_finish = 1;
+	pfd.events = POLLIN;
+}
+
+static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
+
+static void value2human(double bytes, double time, double* data, double* speed,char* metric)
+{
+	int unit = 0;
+
+	*data = bytes;
+	while (*data > 1024 && units[unit + 1]) {
+		*data /= 1024;
+		unit++;
+	}
+	*speed = *data / time;
+	sprintf(metric, "%sB", units[unit]);
+}
+
+
+int encrypt_data(struct session_op *sess, int fdc, int chunksize, int alignmask)
+{
+	struct crypt_op cop;
+	char *buffer[64], iv[32];
+	static int val = 23;
+	struct timeval start, end;
+	double total = 0;
+	double secs, ddata, dspeed;
+	char metric[16];
+	int rc, wqueue = 0, bufidx = 0;
+
+	memset(iv, 0x23, 32);
+
+	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
+	fflush(stdout);
+
+	for (rc = 0; rc < 64; rc++) {
+		if (alignmask) {
+			if (posix_memalign((void **)(buffer + rc), alignmask + 1, chunksize)) {
+				printf("posix_memalign() failed!\n");
+				return 1;
+			}
+		} else {
+			if (!(buffer[rc] = malloc(chunksize))) {
+				perror("malloc()");
+				return 1;
+			}
+		}
+		memset(buffer[rc], val++, chunksize);
+	}
+	pfd.fd = fdc;
+	pfd.events = POLLOUT | POLLIN;
+
+	must_finish = 0;
+	alarm(5);
+
+	gettimeofday(&start, NULL);
+	do {
+		if ((rc = poll(&pfd, 1, 100)) < 0) {
+			if (errno & (ERESTART | EINTR))
+				continue;
+			fprintf(stderr, "errno = %d ", errno);
+			perror("poll()");
+			return 1;
+		}
+
+		if (pfd.revents & POLLOUT) {
+			memset(&cop, 0, sizeof(cop));
+			cop.ses = sess->ses;
+			cop.len = chunksize;
+			cop.iv = (unsigned char *)iv;
+			cop.op = COP_ENCRYPT;
+			cop.src = cop.dst = (unsigned char *)buffer[bufidx];
+			bufidx = (bufidx + 1) % 64;
+
+			if (ioctl(fdc, CIOCASYNCCRYPT, &cop)) {
+				perror("ioctl(CIOCASYNCCRYPT)");
+				return 1;
+			}
+			wqueue++;
+		}
+		if (pfd.revents & POLLIN) {
+			if (ioctl(fdc, CIOCASYNCFETCH, &cop)) {
+				perror("ioctl(CIOCASYNCFETCH)");
+				return 1;
+			}
+			wqueue--;
+			total += cop.len;
+		}
+	} while(!must_finish || wqueue);
+	gettimeofday(&end, NULL);
+
+	secs = udifftimeval(start, end)/ 1000000.0;
+
+	value2human(total, secs, &ddata, &dspeed, metric);
+	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
+	printf ("%.2f %s/sec\n", dspeed, metric);
+
+	for (rc = 0; rc < 64; rc++)
+		free(buffer[rc]);
+	return 0;
+}
+
+int main(void)
+{
+	int fd, i, fdc = -1, alignmask = 0;
+	struct session_op sess;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+	char keybuf[32];
+
+	signal(SIGALRM, alarm_handler);
+
+	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
+		perror("open()");
+		return 1;
+	}
+	if (ioctl(fd, CRIOGET, &fdc)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	fprintf(stderr, "Testing NULL cipher: \n");
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_NULL;
+	sess.keylen = 0;
+	sess.key = (unsigned char *)keybuf;
+	if (ioctl(fdc, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	alignmask = siop.alignmask;
+#endif
+
+	for (i = 256; i <= (64 * 4096); i *= 2) {
+		if (encrypt_data(&sess, fdc, i, alignmask))
+			break;
+	}
+
+	fprintf(stderr, "\nTesting AES-128-CBC cipher: \n");
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = 16;
+	memset(keybuf, 0x42, 16);
+	sess.key = (unsigned char *)keybuf;
+	if (ioctl(fdc, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	alignmask = siop.alignmask;
+#endif
+
+	for (i = 256; i <= (64 * 1024); i *= 2) {
+		if (encrypt_data(&sess, fdc, i, alignmask))
+			break;
+	}
+
+	close(fdc);
+	close(fd);
+	return 0;
+}
diff --git a/drivers/staging/crypto/cryptodev/tests/cipher-aead-srtp.c b/drivers/staging/crypto/cryptodev/tests/cipher-aead-srtp.c
new file mode 100644
index 000000000000..d15fc3ee4cd8
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/cipher-aead-srtp.c
@@ -0,0 +1,591 @@
+/*
+ * Demo on how to use /dev/crypto device for ciphering.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+
+#define	DATA_SIZE	(8*1024)
+#define HEADER_SIZE 193
+#define PLAINTEXT_SIZE 1021
+#define FOOTER_SIZE 15
+#define	BLOCK_SIZE	16
+#define	KEY_SIZE	16
+
+#define MAC_SIZE 20 /* SHA1 */
+
+static int
+get_sha1_hmac(int cfd, void* key, int key_size, void* data, int data_size, void* mac)
+{
+	struct session_op sess;
+	struct crypt_op cryp;
+	int i;
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	sess.cipher = 0;
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = key_size;
+	sess.mackey = key;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = sess.ses;
+	cryp.len = data_size;
+	cryp.src = data;
+	cryp.dst = NULL;
+	cryp.iv = NULL;
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static void print_buf(char* desc, unsigned char* buf, int size)
+{
+int i;
+	fputs(desc, stdout);
+	for (i=0;i<size;i++) {
+		printf("%.2x", (uint8_t)buf[i]);
+	}
+	fputs("\n", stdout);
+}
+
+static int
+test_crypto(int cfd)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+	unsigned char sha1mac[20];
+	unsigned char tag[20];
+	unsigned char mackey[] = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+	int mackey_len = 16;
+	int pad, i;
+
+	struct session_op sess;
+	struct crypt_op co;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cao, 0, sizeof(cao));
+	memset(&co, 0, sizeof(co));
+
+	memset(key,0x33,  sizeof(key));
+	memset(iv, 0x03,  sizeof(iv));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CTR;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = mackey_len;
+	sess.mackey = mackey;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
+			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
+	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, HEADER_SIZE); /* header */
+	memset(&plaintext[HEADER_SIZE], 0x17, PLAINTEXT_SIZE); /* payload */
+	memset(&plaintext[HEADER_SIZE+PLAINTEXT_SIZE], 0x22, FOOTER_SIZE);
+
+	memcpy(ciphertext, plaintext, DATA_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.len = PLAINTEXT_SIZE;
+	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
+	cao.auth_src = ciphertext;
+	cao.src = ciphertext+HEADER_SIZE;
+	cao.dst = cao.src;
+	cao.iv = iv;
+	cao.op = COP_ENCRYPT;
+	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
+	cao.tag = tag;
+	cao.tag_len = 20;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Get crypto session for AES128 */
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CTR;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	if (get_sha1_hmac(cfd, mackey, mackey_len, ciphertext, HEADER_SIZE + PLAINTEXT_SIZE + FOOTER_SIZE, sha1mac) != 0) {
+		fprintf(stderr, "SHA1 MAC failed\n");
+		return 1;
+	}
+
+	if (memcmp(tag, sha1mac, 20) != 0) {
+		fprintf(stderr, "AEAD SHA1 MAC does not match plain MAC\n");
+		print_buf("SHA1: ", sha1mac, 20);
+		print_buf("SHA1-SRTP: ", tag, 20);
+		return 1;
+	}
+
+	/* Decrypt data.encrypted to data.decrypted */
+	co.ses = sess.ses;
+	co.len = PLAINTEXT_SIZE;
+	co.src = ciphertext+HEADER_SIZE;
+	co.dst = ciphertext+HEADER_SIZE;
+	co.iv = iv;
+	co.op = COP_DECRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &co)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext+HEADER_SIZE, ciphertext+HEADER_SIZE, PLAINTEXT_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", (unsigned int)plaintext[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", (unsigned int)ciphertext[i]);
+		}
+		printf("\n");
+		return 1;
+	}
+
+	printf("Test passed\n");
+
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+test_encrypt_decrypt(int cfd)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+	unsigned char sha1mac[20];
+	unsigned char tag[20];
+	unsigned char mackey[] = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+	int mackey_len = 16;
+	int pad, i;
+
+	struct session_op sess;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cao, 0, sizeof(cao));
+
+	memset(key,0x33,  sizeof(key));
+	memset(iv, 0x03,  sizeof(iv));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CTR;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = mackey_len;
+	sess.mackey = mackey;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+//	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
+//			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
+	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, HEADER_SIZE); /* header */
+	memset(&plaintext[HEADER_SIZE], 0x17, PLAINTEXT_SIZE); /* payload */
+	memset(&plaintext[HEADER_SIZE+PLAINTEXT_SIZE], 0x22, FOOTER_SIZE);
+
+	memcpy(ciphertext, plaintext, DATA_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.len = PLAINTEXT_SIZE;
+	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
+	cao.auth_src = ciphertext;
+	cao.src = ciphertext+HEADER_SIZE;
+	cao.dst = cao.src;
+	cao.iv = iv;
+	cao.op = COP_ENCRYPT;
+	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
+	cao.tag = tag;
+	cao.tag_len = 20;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Get crypto session for AES128 */
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CTR;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = mackey_len;
+	sess.mackey = mackey;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	/* Decrypt data.encrypted to data.decrypted */
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.len = PLAINTEXT_SIZE;
+	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
+	cao.auth_src = ciphertext;
+	cao.src = ciphertext+HEADER_SIZE;
+	cao.dst = cao.src;
+	cao.iv = iv;
+	cao.op = COP_DECRYPT;
+	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
+	cao.tag = tag;
+	cao.tag_len = 20;
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext+HEADER_SIZE, ciphertext+HEADER_SIZE, PLAINTEXT_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", (unsigned int)plaintext[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", (unsigned int)ciphertext[i]);
+		}
+		printf("\n");
+		return 1;
+	}
+
+	printf("Test passed\n");
+
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+test_encrypt_decrypt_error(int cfd, int err)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+	unsigned char sha1mac[20];
+	unsigned char tag[20];
+	unsigned char mackey[] = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+	int mackey_len = 16;
+	int pad, i;
+
+	struct session_op sess;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cao, 0, sizeof(cao));
+
+	memset(key,0x33,  sizeof(key));
+	memset(iv, 0x03,  sizeof(iv));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CTR;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = mackey_len;
+	sess.mackey = mackey;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+//	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
+//			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
+	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, HEADER_SIZE); /* header */
+	memset(&plaintext[HEADER_SIZE], 0x17, PLAINTEXT_SIZE); /* payload */
+	memset(&plaintext[HEADER_SIZE+PLAINTEXT_SIZE], 0x22, FOOTER_SIZE);
+
+	memcpy(ciphertext, plaintext, DATA_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.len = PLAINTEXT_SIZE;
+	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
+	cao.auth_src = ciphertext;
+	cao.src = ciphertext+HEADER_SIZE;
+	cao.dst = cao.src;
+	cao.iv = iv;
+	cao.op = COP_ENCRYPT;
+	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
+	cao.tag = tag;
+	cao.tag_len = 20;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Get crypto session for AES128 */
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CTR;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = mackey_len;
+	sess.mackey = mackey;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	/* Decrypt data.encrypted to data.decrypted */
+	/* Encrypt data.in to data.encrypted */
+	if (err == 0)
+		ciphertext[1]++;
+	else
+		ciphertext[HEADER_SIZE+3]++;
+	cao.ses = sess.ses;
+	cao.len = PLAINTEXT_SIZE;
+	cao.auth_len = HEADER_SIZE+PLAINTEXT_SIZE+FOOTER_SIZE;
+	cao.auth_src = ciphertext;
+	cao.src = ciphertext+HEADER_SIZE;
+	cao.dst = cao.src;
+	cao.iv = iv;
+	cao.op = COP_DECRYPT;
+	cao.flags = COP_FLAG_AEAD_SRTP_TYPE;
+	cao.tag = tag;
+	cao.tag_len = 20;
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+			perror("ioctl(CIOCFSESSION)");
+			return 1;
+		}
+
+		printf("Test passed\n");
+		return 0;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext+HEADER_SIZE, ciphertext+HEADER_SIZE, PLAINTEXT_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", (unsigned int)plaintext[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", (unsigned int)ciphertext[i]);
+		}
+		printf("\n");
+		return 1;
+	}
+
+	printf("Test failed\n");
+
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 1;
+}
+
+int
+main()
+{
+	int fd = -1, cfd = -1;
+
+	/* Open the crypto device */
+	fd = open("/dev/crypto", O_RDWR, 0);
+	if (fd < 0) {
+		perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Clone file descriptor */
+	if (ioctl(fd, CRIOGET, &cfd)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	/* Run the test itself */
+
+	if (test_crypto(cfd))
+		return 1;
+
+	if (test_encrypt_decrypt(cfd))
+		return 1;
+
+	if (test_encrypt_decrypt_error(cfd,0))
+		return 1;
+
+	if (test_encrypt_decrypt_error(cfd,1))
+		return 1;
+
+	/* Close cloned descriptor */
+	if (close(cfd)) {
+		perror("close(cfd)");
+		return 1;
+	}
+
+	/* Close the original descriptor */
+	if (close(fd)) {
+		perror("close(fd)");
+		return 1;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/staging/crypto/cryptodev/tests/cipher-aead.c b/drivers/staging/crypto/cryptodev/tests/cipher-aead.c
new file mode 100644
index 000000000000..ab29aeca8109
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/cipher-aead.c
@@ -0,0 +1,588 @@
+/*
+ * Demo on how to use /dev/crypto device for ciphering.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+
+#define	DATA_SIZE	(8*1024)
+#define AUTH_SIZE       31
+#define	BLOCK_SIZE	16
+#define	KEY_SIZE	16
+
+#define MAC_SIZE 20 /* SHA1 */
+
+static int
+get_sha1_hmac(int cfd, void* key, int key_size, void* data1, int data1_size, void* data2, int data2_size, void* mac)
+{
+	struct session_op sess;
+	struct crypt_op cryp;
+	int i;
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	sess.cipher = 0;
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = key_size;
+	sess.mackey = key;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = sess.ses;
+	cryp.len = data1_size;
+	cryp.src = data1;
+	cryp.dst = NULL;
+	cryp.iv = NULL;
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	cryp.flags = COP_FLAG_UPDATE;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	cryp.ses = sess.ses;
+	cryp.len = data2_size;
+	cryp.src = data2;
+	cryp.dst = NULL;
+	cryp.iv = NULL;
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	cryp.flags = COP_FLAG_FINAL;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static void print_buf(char* desc, unsigned char* buf, int size)
+{
+int i;
+	fputs(desc, stdout);
+	for (i=0;i<size;i++) {
+		printf("%.2x", (uint8_t)buf[i]);
+	}
+	fputs("\n", stdout);
+}
+
+static int
+test_crypto(int cfd)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+	char auth[AUTH_SIZE];
+	unsigned char sha1mac[20];
+	int pad, i;
+
+	struct session_op sess;
+	struct crypt_op co;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cao, 0, sizeof(cao));
+	memset(&co, 0, sizeof(co));
+
+	memset(key,0x33,  sizeof(key));
+	memset(iv, 0x03,  sizeof(iv));
+	memset(auth, 0xf1,  sizeof(auth));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = 16;
+	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
+			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
+	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, DATA_SIZE);
+
+	if (get_sha1_hmac(cfd, sess.mackey, sess.mackeylen, auth, sizeof(auth), plaintext, DATA_SIZE, sha1mac) != 0) {
+		fprintf(stderr, "SHA1 MAC failed\n");
+		return 1;
+	}
+
+	//memcpy(ciphertext, plaintext, DATA_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = DATA_SIZE;
+	cao.src = plaintext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.op = COP_ENCRYPT;
+	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, cao.len);
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Get crypto session for AES128 */
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	/* Decrypt data.encrypted to data.decrypted */
+	co.ses = sess.ses;
+	co.len = cao.len;
+	co.src = ciphertext;
+	co.dst = ciphertext;
+	co.iv = iv;
+	co.op = COP_DECRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &co)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", plaintext[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", ciphertext[i]);
+		}
+		printf("\n");
+		return 1;
+	}
+
+	pad = ciphertext[cao.len-1];
+	if (memcmp(&ciphertext[cao.len-MAC_SIZE-pad-1], sha1mac, 20) != 0) {
+		fprintf(stderr, "AEAD SHA1 MAC does not match plain MAC\n");
+		print_buf("SHA1: ", sha1mac, 20);
+		print_buf("SHA1-TLS: ", &ciphertext[cao.len-MAC_SIZE-pad-1], 20);
+		return 1;
+	}
+
+
+	for (i=0;i<pad;i++)
+		if (ciphertext[cao.len-1-i] != pad) {
+			fprintf(stderr, "Pad does not match (expected %d)\n", pad);
+			print_buf("PAD: ", &ciphertext[cao.len-1-pad], pad);
+			return 1;
+		}
+
+	printf("Test passed\n");
+
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+test_encrypt_decrypt(int cfd)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+	char auth[AUTH_SIZE];
+	unsigned char sha1mac[20];
+	int pad, i, enc_len;
+
+	struct session_op sess;
+	struct crypt_op co;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cao, 0, sizeof(cao));
+	memset(&co, 0, sizeof(co));
+
+	memset(key,0x33,  sizeof(key));
+	memset(iv, 0x03,  sizeof(iv));
+	memset(auth, 0xf1,  sizeof(auth));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = 16;
+	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+//	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
+//			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
+	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, DATA_SIZE);
+
+	if (get_sha1_hmac(cfd, sess.mackey, sess.mackeylen, auth, sizeof(auth), plaintext, DATA_SIZE, sha1mac) != 0) {
+		fprintf(stderr, "SHA1 MAC failed\n");
+		return 1;
+	}
+
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = DATA_SIZE;
+	cao.src = plaintext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.op = COP_ENCRYPT;
+	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+	enc_len = cao.len;
+	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, enc_len);
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Get crypto session for AES128 */
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = 16;
+	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	/* Decrypt data.encrypted to data.decrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = enc_len;
+	cao.src = ciphertext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.op = COP_DECRYPT;
+	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+	if (cao.len != DATA_SIZE) {
+		fprintf(stderr, "decrypted data size incorrect!\n");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", plaintext[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", ciphertext[i]);
+		}
+		printf("\n");
+		return 1;
+	}
+
+	printf("Test passed\n");
+
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+test_encrypt_decrypt_error(int cfd, int err)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+	char auth[AUTH_SIZE];
+	unsigned char sha1mac[20];
+	int pad, i, enc_len;
+
+	struct session_op sess;
+	struct crypt_op co;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cao, 0, sizeof(cao));
+	memset(&co, 0, sizeof(co));
+
+	memset(key,0x33,  sizeof(key));
+	memset(iv, 0x03,  sizeof(iv));
+	memset(auth, 0xf1,  sizeof(auth));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = 16;
+	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+//	printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
+//			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
+	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, DATA_SIZE);
+
+	if (get_sha1_hmac(cfd, sess.mackey, sess.mackeylen, auth, sizeof(auth), plaintext, DATA_SIZE, sha1mac) != 0) {
+		fprintf(stderr, "SHA1 MAC failed\n");
+		return 1;
+	}
+
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = DATA_SIZE;
+	cao.src = plaintext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.op = COP_ENCRYPT;
+	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+	enc_len = cao.len;
+	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, enc_len);
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Get crypto session for AES128 */
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = 16;
+	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	if (err == 0)
+		auth[2]++;
+	else
+		ciphertext[4]++;
+
+	/* Decrypt data.encrypted to data.decrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = enc_len;
+	cao.src = ciphertext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.op = COP_DECRYPT;
+	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+			perror("ioctl(CIOCFSESSION)");
+			return 1;
+		}
+
+		printf("Test passed\n");
+		return 0;
+	}
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+
+	fprintf(stderr, "Modification to ciphertext was not detected\n");
+	return 1;
+}
+
+int
+main()
+{
+	int fd = -1, cfd = -1;
+
+	/* Open the crypto device */
+	fd = open("/dev/crypto", O_RDWR, 0);
+	if (fd < 0) {
+		perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Clone file descriptor */
+	if (ioctl(fd, CRIOGET, &cfd)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	/* Run the test itself */
+
+	if (test_crypto(cfd))
+		return 1;
+
+	if (test_encrypt_decrypt(cfd))
+		return 1;
+
+	if (test_encrypt_decrypt_error(cfd, 0))
+		return 1;
+
+	if (test_encrypt_decrypt_error(cfd, 1))
+		return 1;
+
+	/* Close cloned descriptor */
+	if (close(cfd)) {
+		perror("close(cfd)");
+		return 1;
+	}
+
+	/* Close the original descriptor */
+	if (close(fd)) {
+		perror("close(fd)");
+		return 1;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/staging/crypto/cryptodev/tests/cipher-gcm.c b/drivers/staging/crypto/cryptodev/tests/cipher-gcm.c
new file mode 100644
index 000000000000..9b5f4f947075
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/cipher-gcm.c
@@ -0,0 +1,528 @@
+/*
+ * Demo on how to use /dev/crypto device for ciphering.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+
+#define	DATA_SIZE	(8*1024)
+#define AUTH_SIZE       31
+#define	BLOCK_SIZE	16
+#define	KEY_SIZE	16
+
+#define my_perror(x) {fprintf(stderr, "%s: %d\n", __func__, __LINE__); perror(x); }
+
+static void print_buf(char *desc, const unsigned char *buf, int size)
+{
+	int i;
+	fputs(desc, stdout);
+	for (i = 0; i < size; i++) {
+		printf("%.2x", (uint8_t) buf[i]);
+	}
+	fputs("\n", stdout);
+}
+
+struct aes_gcm_vectors_st {
+	const uint8_t *key;
+	const uint8_t *auth;
+	int auth_size;
+	const uint8_t *plaintext;
+	int plaintext_size;
+	const uint8_t *iv;
+	const uint8_t *ciphertext;
+	const uint8_t *tag;
+};
+
+struct aes_gcm_vectors_st aes_gcm_vectors[] = {
+	{
+	 .key =
+	 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
+	 .auth = NULL,
+	 .auth_size = 0,
+	 .plaintext =
+	 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
+	 .plaintext_size = 16,
+	 .ciphertext =
+	 "\x03\x88\xda\xce\x60\xb6\xa3\x92\xf3\x28\xc2\xb9\x71\xb2\xfe\x78",
+	 .iv = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
+	 .tag =
+	 "\xab\x6e\x47\xd4\x2c\xec\x13\xbd\xf5\x3a\x67\xb2\x12\x57\xbd\xdf"
+	},
+	{
+	 .key =
+	 "\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08",
+	 .auth = NULL,
+	 .auth_size = 0,
+	 .plaintext =
+	 "\xd9\x31\x32\x25\xf8\x84\x06\xe5\xa5\x59\x09\xc5\xaf\xf5\x26\x9a\x86\xa7\xa9\x53\x15\x34\xf7\xda\x2e\x4c\x30\x3d\x8a\x31\x8a\x72\x1c\x3c\x0c\x95\x95\x68\x09\x53\x2f\xcf\x0e\x24\x49\xa6\xb5\x25\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57\xba\x63\x7b\x39\x1a\xaf\xd2\x55",
+	 .plaintext_size = 64,
+	 .ciphertext =
+	 "\x42\x83\x1e\xc2\x21\x77\x74\x24\x4b\x72\x21\xb7\x84\xd0\xd4\x9c\xe3\xaa\x21\x2f\x2c\x02\xa4\xe0\x35\xc1\x7e\x23\x29\xac\xa1\x2e\x21\xd5\x14\xb2\x54\x66\x93\x1c\x7d\x8f\x6a\x5a\xac\x84\xaa\x05\x1b\xa3\x0b\x39\x6a\x0a\xac\x97\x3d\x58\xe0\x91\x47\x3f\x59\x85",
+	 .iv = "\xca\xfe\xba\xbe\xfa\xce\xdb\xad\xde\xca\xf8\x88",
+	 .tag = "\x4d\x5c\x2a\xf3\x27\xcd\x64\xa6\x2c\xf3\x5a\xbd\x2b\xa6\xfa\xb4"
+	},
+	{
+	 .key =
+	 "\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08",
+	 .auth =
+	 "\xfe\xed\xfa\xce\xde\xad\xbe\xef\xfe\xed\xfa\xce\xde\xad\xbe\xef\xab\xad\xda\xd2",
+	 .auth_size = 20,
+	 .plaintext =
+	 "\xd9\x31\x32\x25\xf8\x84\x06\xe5\xa5\x59\x09\xc5\xaf\xf5\x26\x9a\x86\xa7\xa9\x53\x15\x34\xf7\xda\x2e\x4c\x30\x3d\x8a\x31\x8a\x72\x1c\x3c\x0c\x95\x95\x68\x09\x53\x2f\xcf\x0e\x24\x49\xa6\xb5\x25\xb1\x6a\xed\xf5\xaa\x0d\xe6\x57\xba\x63\x7b\x39",
+	 .plaintext_size = 60,
+	 .ciphertext =
+	 "\x42\x83\x1e\xc2\x21\x77\x74\x24\x4b\x72\x21\xb7\x84\xd0\xd4\x9c\xe3\xaa\x21\x2f\x2c\x02\xa4\xe0\x35\xc1\x7e\x23\x29\xac\xa1\x2e\x21\xd5\x14\xb2\x54\x66\x93\x1c\x7d\x8f\x6a\x5a\xac\x84\xaa\x05\x1b\xa3\x0b\x39\x6a\x0a\xac\x97\x3d\x58\xe0\x91",
+	 .iv = "\xca\xfe\xba\xbe\xfa\xce\xdb\xad\xde\xca\xf8\x88",
+	 .tag =
+	 "\x5b\xc9\x4f\xbc\x32\x21\xa5\xdb\x94\xfa\xe9\x5a\xe7\x12\x1a\x47"
+	}
+};
+
+
+/* Test against AES-GCM test vectors.
+ */
+static int test_crypto(int cfd)
+{
+	char iv[BLOCK_SIZE];
+	unsigned char tag[16];
+	int pad, i;
+	int8_t tmp[128];
+
+	struct session_op sess;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	/* Get crypto session for AES128 */
+
+	fprintf(stdout, "Tests on AES-GCM vectors: ");
+	fflush(stdout);
+	for (i = 0;
+	     i < sizeof(aes_gcm_vectors) / sizeof(aes_gcm_vectors[0]);
+	     i++) {
+		memset(&sess, 0, sizeof(sess));
+		memset(tmp, 0, sizeof(tmp));
+
+		sess.cipher = CRYPTO_AES_GCM;
+		sess.keylen = 16;
+		sess.key = (void *) aes_gcm_vectors[i].key;
+
+		if (ioctl(cfd, CIOCGSESSION, &sess)) {
+			my_perror("ioctl(CIOCGSESSION)");
+			return 1;
+		}
+
+		memset(&cao, 0, sizeof(cao));
+
+		cao.ses = sess.ses;
+		cao.dst = tmp;
+		cao.iv = (void *) aes_gcm_vectors[i].iv;
+		cao.iv_len = 12;
+		cao.op = COP_ENCRYPT;
+		cao.flags = 0;
+
+		if (aes_gcm_vectors[i].auth_size > 0) {
+			cao.auth_src = (void *) aes_gcm_vectors[i].auth;
+			cao.auth_len = aes_gcm_vectors[i].auth_size;
+		}
+
+		if (aes_gcm_vectors[i].plaintext_size > 0) {
+			cao.src = (void *) aes_gcm_vectors[i].plaintext;
+			cao.len = aes_gcm_vectors[i].plaintext_size;
+		}
+
+		if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+			my_perror("ioctl(CIOCAUTHCRYPT)");
+			return 1;
+		}
+
+		if (aes_gcm_vectors[i].plaintext_size > 0)
+			if (memcmp
+			    (tmp, aes_gcm_vectors[i].ciphertext,
+			     aes_gcm_vectors[i].plaintext_size) != 0) {
+				fprintf(stderr,
+					"AES-GCM test vector %d failed!\n",
+					i);
+
+				print_buf("Cipher: ", tmp, aes_gcm_vectors[i].plaintext_size);
+				print_buf("Expected: ", aes_gcm_vectors[i].ciphertext, aes_gcm_vectors[i].plaintext_size);
+				return 1;
+			}
+
+		if (memcmp
+		    (&tmp[cao.len - cao.tag_len], aes_gcm_vectors[i].tag,
+		     16) != 0) {
+			fprintf(stderr,
+				"AES-GCM test vector %d failed (tag)!\n",
+				i);
+
+			print_buf("Tag: ", tmp, cao.tag_len);
+			print_buf("Expected tag: ",
+				  aes_gcm_vectors[i].tag, 16);
+			return 1;
+		}
+
+	}
+	fprintf(stdout, "ok\n");
+	fprintf(stdout, "\n");
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		my_perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+/* Checks if encryption and subsequent decryption 
+ * produces the same data.
+ */
+static int test_encrypt_decrypt(int cfd)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+	char auth[AUTH_SIZE];
+	unsigned char sha1mac[20];
+	int pad, i, enc_len;
+
+	struct session_op sess;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	fprintf(stdout, "Tests on AES-GCM encryption/decryption: ");
+	fflush(stdout);
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cao, 0, sizeof(cao));
+
+	memset(key, 0x33, sizeof(key));
+	memset(iv, 0x03, sizeof(iv));
+	memset(auth, 0xf1, sizeof(auth));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_GCM;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		my_perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		my_perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+//      printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
+//                      siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext =
+	    (char *) (((unsigned long) plaintext_raw + siop.alignmask) &
+		      ~siop.alignmask);
+	ciphertext =
+	    (char *) (((unsigned long) ciphertext_raw + siop.alignmask) &
+		      ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, DATA_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = DATA_SIZE;
+	cao.src = plaintext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.iv_len = 12;
+	cao.op = COP_ENCRYPT;
+	cao.flags = 0;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		my_perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+	enc_len = cao.len;
+	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, enc_len);
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		my_perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Get crypto session for AES128 */
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_GCM;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		my_perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	/* Decrypt data.encrypted to data.decrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = enc_len;
+	cao.src = ciphertext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.iv_len = 12;
+	cao.op = COP_DECRYPT;
+	cao.flags = 0;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		my_perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+	if (cao.len != DATA_SIZE) {
+		fprintf(stderr, "decrypted data size incorrect!\n");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", plaintext[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", ciphertext[i]);
+		}
+		printf("\n");
+		return 1;
+	}
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		my_perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	fprintf(stdout, "ok\n");
+	fprintf(stdout, "\n");
+
+	return 0;
+}
+
+static int test_encrypt_decrypt_error(int cfd, int err)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+	char auth[AUTH_SIZE];
+	int pad, i, enc_len;
+
+	struct session_op sess;
+	struct crypt_op co;
+	struct crypt_auth_op cao;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	fprintf(stdout, "Tests on AES-GCM tag verification: ");
+	fflush(stdout);
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cao, 0, sizeof(cao));
+	memset(&co, 0, sizeof(co));
+
+	memset(key, 0x33, sizeof(key));
+	memset(iv, 0x03, sizeof(iv));
+	memset(auth, 0xf1, sizeof(auth));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = 16;
+	sess.mackey =
+	    (uint8_t *)
+	    "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		my_perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		my_perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+//      printf("requested cipher CRYPTO_AES_CBC/HMAC-SHA1, got %s with driver %s\n",
+//                      siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext =
+	    (char *) (((unsigned long) plaintext_raw + siop.alignmask) &
+		      ~siop.alignmask);
+	ciphertext =
+	    (char *) (((unsigned long) ciphertext_raw + siop.alignmask) &
+		      ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, DATA_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = DATA_SIZE;
+	cao.src = plaintext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.op = COP_ENCRYPT;
+	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
+
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		my_perror("ioctl(CIOCAUTHCRYPT)");
+		return 1;
+	}
+
+	enc_len = cao.len;
+	//printf("Original plaintext size: %d, ciphertext: %d\n", DATA_SIZE, enc_len);
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		my_perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	/* Get crypto session for AES128 */
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.mackeylen = 16;
+	sess.mackey =
+	    (uint8_t *)
+	    "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		my_perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+	if (err == 0)
+		auth[2]++;
+	else
+		ciphertext[4]++;
+
+	/* Decrypt data.encrypted to data.decrypted */
+	cao.ses = sess.ses;
+	cao.auth_src = auth;
+	cao.auth_len = sizeof(auth);
+	cao.len = enc_len;
+	cao.src = ciphertext;
+	cao.dst = ciphertext;
+	cao.iv = iv;
+	cao.op = COP_DECRYPT;
+	cao.flags = COP_FLAG_AEAD_TLS_TYPE;
+	if (ioctl(cfd, CIOCAUTHCRYPT, &cao)) {
+		if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+			my_perror("ioctl(CIOCFSESSION)");
+			return 1;
+		}
+
+		fprintf(stdout, "ok\n");
+		fprintf(stdout, "\n");
+		return 0;
+	}
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		my_perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+
+	fprintf(stderr, "Modification to ciphertext was not detected\n");
+	return 1;
+}
+
+int main()
+{
+	int fd = -1, cfd = -1;
+
+	/* Open the crypto device */
+	fd = open("/dev/crypto", O_RDWR, 0);
+	if (fd < 0) {
+		my_perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Clone file descriptor */
+	if (ioctl(fd, CRIOGET, &cfd)) {
+		my_perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		my_perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	/* Run the test itself */
+
+	if (test_crypto(cfd))
+		return 1;
+
+	if (test_encrypt_decrypt(cfd))
+		return 1;
+
+	if (test_encrypt_decrypt_error(cfd, 0))
+		return 1;
+
+	if (test_encrypt_decrypt_error(cfd, 1))
+		return 1;
+
+	/* Close cloned descriptor */
+	if (close(cfd)) {
+		my_perror("close(cfd)");
+		return 1;
+	}
+
+	/* Close the original descriptor */
+	if (close(fd)) {
+		my_perror("close(fd)");
+		return 1;
+	}
+
+	return 0;
+}
diff --git a/drivers/staging/crypto/cryptodev/tests/cipher.c b/drivers/staging/crypto/cryptodev/tests/cipher.c
new file mode 100644
index 000000000000..007d3fefa020
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/cipher.c
@@ -0,0 +1,319 @@
+/*
+ * Demo on how to use /dev/crypto device for ciphering.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+
+#define	DATA_SIZE	8*1024
+#define	BLOCK_SIZE	16
+#define	KEY_SIZE	16
+
+static int
+test_crypto(int cfd)
+{
+	char plaintext_raw[DATA_SIZE + 63], *plaintext;
+	char ciphertext_raw[DATA_SIZE + 63], *ciphertext;
+	char iv[BLOCK_SIZE];
+	char key[KEY_SIZE];
+
+	struct session_op sess;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+	struct crypt_op cryp;
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	memset(key, 0x33,  sizeof(key));
+	memset(iv, 0x03,  sizeof(iv));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested cipher CRYPTO_AES_CBC, got %s with driver %s\n",
+			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext = (char *)(((unsigned long)plaintext_raw + siop.alignmask) & ~siop.alignmask);
+	ciphertext = (char *)(((unsigned long)ciphertext_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext = plaintext_raw;
+	ciphertext = ciphertext_raw;
+#endif
+	memset(plaintext, 0x15, DATA_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = sess.ses;
+	cryp.len = DATA_SIZE;
+	cryp.src = plaintext;
+	cryp.dst = ciphertext;
+	cryp.iv = iv;
+	cryp.op = COP_ENCRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested cipher CRYPTO_AES_CBC, got %s with driver %s\n",
+			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+#endif
+
+	/* Decrypt data.encrypted to data.decrypted */
+	cryp.ses = sess.ses;
+	cryp.len = DATA_SIZE;
+	cryp.src = ciphertext;
+	cryp.dst = ciphertext;
+	cryp.iv = iv;
+	cryp.op = COP_DECRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext, ciphertext, DATA_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", plaintext[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < DATA_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", ciphertext[i]);
+		}
+		printf("\n");
+		return 1;
+	} else
+		printf("Test passed\n");
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int test_aes(int cfd)
+{
+	char plaintext1_raw[BLOCK_SIZE + 63], *plaintext1;
+	char ciphertext1[BLOCK_SIZE] = { 0xdf, 0x55, 0x6a, 0x33, 0x43, 0x8d, 0xb8, 0x7b, 0xc4, 0x1b, 0x17, 0x52, 0xc5, 0x5e, 0x5e, 0x49 };
+	char iv1[BLOCK_SIZE];
+	char key1[KEY_SIZE] = { 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	char plaintext2_data[BLOCK_SIZE] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00 };
+	char plaintext2_raw[BLOCK_SIZE + 63], *plaintext2;
+	char ciphertext2[BLOCK_SIZE] = { 0xb7, 0x97, 0x2b, 0x39, 0x41, 0xc4, 0x4b, 0x90, 0xaf, 0xa7, 0xb2, 0x64, 0xbf, 0xba, 0x73, 0x87 };
+	char iv2[BLOCK_SIZE];
+	char key2[KEY_SIZE];
+
+	struct session_op sess;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+	struct crypt_op cryp;
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key1;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	plaintext1 = (char *)(((unsigned long)plaintext1_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext1 = plaintext1_raw;
+#endif
+	memset(plaintext1, 0x0, BLOCK_SIZE);
+	memset(iv1, 0x0, sizeof(iv1));
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = sess.ses;
+	cryp.len = BLOCK_SIZE;
+	cryp.src = plaintext1;
+	cryp.dst = plaintext1;
+	cryp.iv = iv1;
+	cryp.op = COP_ENCRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext1, ciphertext1, BLOCK_SIZE) != 0) {
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		return 1;
+	}
+
+	/* Test 2 */
+
+	memset(key2, 0x0, sizeof(key2));
+	memset(iv2, 0x0, sizeof(iv2));
+
+	/* Get crypto session for AES128 */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = KEY_SIZE;
+	sess.key = key2;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested cipher CRYPTO_AES_CBC, got %s with driver %s\n",
+			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
+
+	plaintext2 = (char *)(((unsigned long)plaintext2_raw + siop.alignmask) & ~siop.alignmask);
+#else
+	plaintext2 = plaintext2_raw;
+#endif
+	memcpy(plaintext2, plaintext2_data, BLOCK_SIZE);
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = sess.ses;
+	cryp.len = BLOCK_SIZE;
+	cryp.src = plaintext2;
+	cryp.dst = plaintext2;
+	cryp.iv = iv2;
+	cryp.op = COP_ENCRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(plaintext2, ciphertext2, BLOCK_SIZE) != 0) {
+		int i;
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		printf("plaintext:");
+		for (i = 0; i < BLOCK_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", plaintext2[i]);
+		}
+		printf("ciphertext:");
+		for (i = 0; i < BLOCK_SIZE; i++) {
+			if ((i % 30) == 0)
+				printf("\n");
+			printf("%02x ", ciphertext2[i]);
+		}
+		printf("\n");
+		return 1;
+	}
+
+	printf("AES Test passed\n");
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+int
+main()
+{
+	int fd = -1, cfd = -1;
+
+	/* Open the crypto device */
+	fd = open("/dev/crypto", O_RDWR, 0);
+	if (fd < 0) {
+		perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Clone file descriptor */
+	if (ioctl(fd, CRIOGET, &cfd)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	/* Run the test itself */
+	if (test_aes(cfd))
+		return 1;
+
+	if (test_crypto(cfd))
+		return 1;
+
+	/* Close cloned descriptor */
+	if (close(cfd)) {
+		perror("close(cfd)");
+		return 1;
+	}
+
+	/* Close the original descriptor */
+	if (close(fd)) {
+		perror("close(fd)");
+		return 1;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/staging/crypto/cryptodev/tests/fullspeed.c b/drivers/staging/crypto/cryptodev/tests/fullspeed.c
new file mode 100644
index 000000000000..611859d32ded
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/fullspeed.c
@@ -0,0 +1,184 @@
+/*  cryptodev_test - simple benchmark tool for cryptodev
+ *
+ *    Copyright (C) 2010 by Phil Sutter <phil.sutter@viprinet.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include <crypto/cryptodev.h>
+
+static int si = 1; /* SI by default */
+
+static double udifftimeval(struct timeval start, struct timeval end)
+{
+	return (double)(end.tv_usec - start.tv_usec) +
+	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
+}
+
+static int must_finish = 0;
+
+static void alarm_handler(int signo)
+{
+        must_finish = 1;
+}
+
+static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
+static char *si_units[] = { "", "K", "M", "G", "T", 0};
+
+static void value2human(int si, double bytes, double time, double* data, double* speed,char* metric)
+{
+	int unit = 0;
+
+	*data = bytes;
+	
+	if (si) {
+		while (*data > 1000 && si_units[unit + 1]) {
+			*data /= 1000;
+			unit++;
+		}
+		*speed = *data / time;
+		sprintf(metric, "%sB", si_units[unit]);
+	} else {
+		while (*data > 1024 && units[unit + 1]) {
+			*data /= 1024;
+			unit++;
+		}
+		*speed = *data / time;
+		sprintf(metric, "%sB", units[unit]);
+	}
+}
+
+#define MAX(x,y) ((x)>(y)?(x):(y))
+
+int encrypt_data(int algo, void* keybuf, int key_size, int fdc, int chunksize)
+{
+	struct crypt_op cop;
+	char *buffer, iv[32];
+	static int val = 23;
+	struct timeval start, end;
+	double total = 0;
+	double secs, ddata, dspeed;
+	char metric[16];
+	struct session_op sess;
+
+	if (posix_memalign((void **)&buffer, 16, chunksize)) {
+		printf("posix_memalign() failed! (mask %x, size: %d)\n", 16, chunksize);
+		return 1;
+	}
+
+	memset(iv, 0x23, 32);
+
+	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
+	fflush(stdout);
+
+	memset(buffer, val++, chunksize);
+
+	must_finish = 0;
+	alarm(5);
+
+	gettimeofday(&start, NULL);
+	do {
+		memset(&sess, 0, sizeof(sess));
+		sess.cipher = algo;
+		sess.keylen = key_size;
+		sess.key = keybuf;
+		if (ioctl(fdc, CIOCGSESSION, &sess)) {
+			perror("ioctl(CIOCGSESSION)");
+			return 1;
+		}
+
+		memset(&cop, 0, sizeof(cop));
+		cop.ses = sess.ses;
+		cop.len = chunksize;
+		cop.iv = (unsigned char *)iv;
+		cop.op = COP_ENCRYPT;
+		cop.src = (unsigned char *)buffer;
+		cop.dst = buffer;
+
+		if (ioctl(fdc, CIOCCRYPT, &cop)) {
+			perror("ioctl(CIOCCRYPT)");
+			return 1;
+		}
+		
+		ioctl(fdc, CIOCFSESSION, &sess.ses);
+
+		total+=chunksize;
+	} while(must_finish==0);
+	gettimeofday(&end, NULL);
+
+	secs = udifftimeval(start, end)/ 1000000.0;
+
+	value2human(si, total, secs, &ddata, &dspeed, metric);
+	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
+	printf ("%.2f %s/sec\n", dspeed, metric);
+
+	free(buffer);
+	return 0;
+}
+
+int main(int argc, char** argv)
+{
+	int fd, i, fdc = -1;
+	char keybuf[32];
+
+	signal(SIGALRM, alarm_handler);
+	
+	if (argc > 1) {
+		if (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0) {
+			printf("Usage: speed [--kib]\n");
+			exit(0);
+		}
+		if (strcmp(argv[1], "--kib") == 0) {
+			si = 0;
+		}
+	}
+
+	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
+		perror("open()");
+		return 1;
+	}
+	if (ioctl(fd, CRIOGET, &fdc)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	fprintf(stderr, "Testing NULL cipher: \n");
+
+	for (i = 512; i <= (64 * 1024); i *= 2) {
+		if (encrypt_data(CRYPTO_NULL, keybuf, 0, fdc, i))
+			break;
+	}
+
+	fprintf(stderr, "\nTesting AES-128-CBC cipher: \n");
+	memset(keybuf, 0x42, 16);
+
+	for (i = 512; i <= (64 * 1024); i *= 2) {
+		if (encrypt_data(CRYPTO_AES_CBC, keybuf, 16, fdc, i))
+			break;
+	}
+
+	close(fdc);
+	close(fd);
+	return 0;
+}
diff --git a/drivers/staging/crypto/cryptodev/tests/hashcrypt_speed.c b/drivers/staging/crypto/cryptodev/tests/hashcrypt_speed.c
new file mode 100644
index 000000000000..e60b73d8b274
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/hashcrypt_speed.c
@@ -0,0 +1,206 @@
+/*  hashcrypt_speed - simple SHA+AES benchmark tool for cryptodev
+ *
+ *    Copyright (C) 2011 by Phil Sutter <phil.sutter@viprinet.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <crypto/cryptodev.h>
+
+#define MAX(x,y) ((x)>(y)?(x):(y))
+
+static double udifftimeval(struct timeval start, struct timeval end)
+{
+	return (double)(end.tv_usec - start.tv_usec) +
+	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
+}
+
+static int must_finish = 0;
+
+static void alarm_handler(int signo)
+{
+        must_finish = 1;
+}
+
+static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
+static char *si_units[] = { "", "K", "M", "G", "T", 0};
+
+static void value2human(int si, double bytes, double time, double* data, double* speed,char* metric)
+{
+	int unit = 0;
+
+	*data = bytes;
+
+	if (si) {
+		while (*data > 1000 && si_units[unit + 1]) {
+			*data /= 1000;
+			unit++;
+		}
+		*speed = *data / time;
+		sprintf(metric, "%sB", si_units[unit]);
+	} else {
+		while (*data > 1024 && units[unit + 1]) {
+			*data /= 1024;
+			unit++;
+		}
+		*speed = *data / time;
+		sprintf(metric, "%sB", units[unit]);
+	}
+}
+
+
+int hash_data(struct session_op *sess, int fdc, int chunksize, int align)
+{
+	struct crypt_op cop;
+	char *buffer;
+	static int val = 23;
+	struct timeval start, end;
+	double total = 0;
+	double secs, ddata, dspeed;
+	char metric[16];
+	uint8_t mac[AALG_MAX_RESULT_LEN];
+
+	if (align) {
+		if (posix_memalign((void **)&buffer, align, chunksize)) {
+			printf("posix_memalign() failed, align: %d, size: %d!\n", align, chunksize);
+			return 1;
+		}
+	} else {
+		if (!(buffer = malloc(chunksize))) {
+			perror("malloc()");
+			return 1;
+		}
+	}
+
+	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
+	fflush(stdout);
+
+	memset(buffer, val++, chunksize);
+
+	must_finish = 0;
+	alarm(5);
+
+	gettimeofday(&start, NULL);
+	do {
+		memset(&cop, 0, sizeof(cop));
+		cop.ses = sess->ses;
+		cop.len = chunksize;
+		cop.op = COP_ENCRYPT;
+		cop.src = cop.dst = (unsigned char *)buffer;
+		cop.mac = mac;
+
+		if (ioctl(fdc, CIOCCRYPT, &cop)) {
+			perror("ioctl(CIOCCRYPT)");
+			return 1;
+		}
+		total+=chunksize;
+	} while(must_finish==0);
+	gettimeofday(&end, NULL);
+
+	secs = udifftimeval(start, end)/ 1000000.0;
+
+	value2human(1, total, secs, &ddata, &dspeed, metric);
+	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
+	printf ("%.2f %s/sec\n", dspeed, metric);
+
+	free(buffer);
+	return 0;
+}
+
+int main(void)
+{
+	int fd, i, fdc = -1, align = 0;
+	struct session_op sess;
+	char keybuf[32];
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	signal(SIGALRM, alarm_handler);
+
+	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
+		perror("open()");
+		return 1;
+	}
+	if (ioctl(fd, CRIOGET, &fdc)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	fprintf(stderr, "Testing AES128 with SHA1 Hash: \n");
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = 16;
+	memset(keybuf, 0x42, 32);
+	sess.key = (unsigned char *)keybuf;
+	sess.mac = CRYPTO_SHA1;
+	if (ioctl(fdc, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested hash CRYPTO_SHA1, got %s with driver %s\n",
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+	align = MAX(sizeof(void*), siop.alignmask+1);
+#endif
+
+	for (i = 256; i <= (64 * 1024); i *= 4) {
+		if (hash_data(&sess, fdc, i, align))
+			break;
+	}
+
+	fprintf(stderr, "\nTesting AES256 with SHA256 Hash: \n");
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = 32;
+	sess.key = (unsigned char *)keybuf;
+	sess.mac = CRYPTO_SHA2_256;
+	if (ioctl(fdc, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested hash CRYPTO_SHA2_256, got %s with driver %s\n",
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+	align = MAX(sizeof(void*), siop.alignmask+1);
+#endif
+
+	for (i = 256; i <= (64 * 1024); i *= 4) {
+		if (hash_data(&sess, fdc, i, align))
+			break;
+	}
+
+	close(fdc);
+	close(fd);
+	return 0;
+}
diff --git a/drivers/staging/crypto/cryptodev/tests/hmac.c b/drivers/staging/crypto/cryptodev/tests/hmac.c
new file mode 100644
index 000000000000..549e9462e483
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/hmac.c
@@ -0,0 +1,333 @@
+/*
+ * Demo on how to use /dev/crypto device for HMAC.
+ *
+ * Placed under public domain.
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+
+#include <sys/ioctl.h>
+#include <crypto/cryptodev.h>
+
+#define	DATA_SIZE	4096
+#define	BLOCK_SIZE	16
+#define	KEY_SIZE	16
+#define SHA1_HASH_LEN   20
+
+static int
+test_crypto(int cfd)
+{
+	struct {
+		uint8_t	in[DATA_SIZE],
+			encrypted[DATA_SIZE],
+			decrypted[DATA_SIZE],
+			iv[BLOCK_SIZE],
+			key[KEY_SIZE];
+	} data;
+	struct session_op sess;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+	struct crypt_op cryp;
+	uint8_t mac[AALG_MAX_RESULT_LEN];
+	uint8_t oldmac[AALG_MAX_RESULT_LEN];
+	uint8_t md5_hmac_out[] = "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38";
+	uint8_t sha1_out[] = "\x8f\x82\x03\x94\xf9\x53\x35\x18\x20\x45\xda\x24\xf3\x4d\xe5\x2b\xf8\xbc\x34\x32";
+	int i;
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	/* Use the garbage that is on the stack :-) */
+	/* memset(&data, 0, sizeof(data)); */
+
+	/* SHA1 plain test */
+	memset(mac, 0, sizeof(mac));
+
+	sess.cipher = 0;
+	sess.mac = CRYPTO_SHA1;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested mac CRYPTO_SHA1, got %s with driver %s\n",
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+#endif
+
+	cryp.ses = sess.ses;
+	cryp.len = sizeof("what do ya want for nothing?")-1;
+	cryp.src = "what do ya want for nothing?";
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	if (memcmp(mac, sha1_out, 20)!=0) {
+		printf("mac: ");
+		for (i=0;i<SHA1_HASH_LEN;i++) {
+			printf("%.2x", (uint8_t)mac[i]);
+		}
+		puts("\n");
+		fprintf(stderr, "HASH test 1: failed\n");
+	} else {
+		fprintf(stderr, "HASH test 1: passed\n");
+	}
+
+	/* MD5-HMAC test */
+	memset(mac, 0, sizeof(mac));
+
+	sess.cipher = 0;
+	sess.mackey = (uint8_t*)"Jefe";
+	sess.mackeylen = 4;
+	sess.mac = CRYPTO_MD5_HMAC;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested mac CRYPTO_MD5_HMAC, got %s with driver %s\n",
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+#endif
+
+	cryp.ses = sess.ses;
+	cryp.len = sizeof("what do ya want for nothing?")-1;
+	cryp.src = "what do ya want for nothing?";
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	if (memcmp(mac, md5_hmac_out, 16)!=0) {
+		printf("mac: ");
+		for (i=0;i<SHA1_HASH_LEN;i++) {
+			printf("%.2x", (uint8_t)mac[i]);
+		}
+		puts("\n");
+		fprintf(stderr, "HMAC test 1: failed\n");
+	} else {
+		fprintf(stderr, "HMAC test 1: passed\n");
+	}
+
+	/* Hash and encryption in one step test */
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.mac = CRYPTO_SHA1_HMAC;
+	sess.keylen = KEY_SIZE;
+	sess.key = data.key;
+	sess.mackeylen = 16;
+	sess.mackey = (uint8_t*)"\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested cipher CRYPTO_AES_CBC and mac CRYPTO_SHA1_HMAC,"
+	       " got cipher %s with driver %s and hash %s with driver %s\n",
+			siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name,
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+#endif
+
+	/* Encrypt data.in to data.encrypted */
+	cryp.ses = sess.ses;
+	cryp.len = sizeof(data.in);
+	cryp.src = data.in;
+	cryp.dst = data.encrypted;
+	cryp.iv = data.iv;
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	memcpy(oldmac, mac, sizeof(mac));
+
+	/* Decrypt data.encrypted to data.decrypted */
+	cryp.src = data.encrypted;
+	cryp.dst = data.decrypted;
+	cryp.op = COP_DECRYPT;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	/* Verify the result */
+	if (memcmp(data.in, data.decrypted, sizeof(data.in)) != 0) {
+		fprintf(stderr,
+			"FAIL: Decrypted data are different from the input data.\n");
+		return 1;
+	} else
+		printf("Crypt Test: passed\n");
+
+	if (memcmp(mac, oldmac, 20) != 0) {
+		fprintf(stderr,
+			"FAIL: Hash in decrypted data different than in encrypted.\n");
+		return 1;
+	} else
+		printf("HMAC Test 2: passed\n");
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+test_extras(int cfd)
+{
+	struct session_op sess;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+	struct crypt_op cryp;
+	uint8_t mac[AALG_MAX_RESULT_LEN];
+	uint8_t oldmac[AALG_MAX_RESULT_LEN];
+	uint8_t md5_hmac_out[] = "\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38";
+	uint8_t sha1_out[] = "\x8f\x82\x03\x94\xf9\x53\x35\x18\x20\x45\xda\x24\xf3\x4d\xe5\x2b\xf8\xbc\x34\x32";
+	int i;
+
+	memset(&sess, 0, sizeof(sess));
+	memset(&cryp, 0, sizeof(cryp));
+
+	/* Use the garbage that is on the stack :-) */
+	/* memset(&data, 0, sizeof(data)); */
+
+	/* SHA1 plain test */
+	memset(mac, 0, sizeof(mac));
+
+	sess.cipher = 0;
+	sess.mac = CRYPTO_SHA1;
+	if (ioctl(cfd, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(cfd, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested mac CRYPTO_SHA1, got %s with driver %s\n",
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+#endif
+
+	cryp.ses = sess.ses;
+	cryp.len = sizeof("what do")-1;
+	cryp.src = "what do";
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	cryp.flags = COP_FLAG_UPDATE;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	cryp.ses = sess.ses;
+	cryp.len = sizeof(" ya want for nothing?")-1;
+	cryp.src = " ya want for nothing?";
+	cryp.mac = mac;
+	cryp.op = COP_ENCRYPT;
+	cryp.flags = COP_FLAG_FINAL;
+	if (ioctl(cfd, CIOCCRYPT, &cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+
+	if (memcmp(mac, sha1_out, 20)!=0) {
+		printf("mac: ");
+		for (i=0;i<SHA1_HASH_LEN;i++) {
+			printf("%.2x", (uint8_t)mac[i]);
+		}
+		puts("\n");
+		fprintf(stderr, "HASH test [update]: failed\n");
+	} else {
+		fprintf(stderr, "HASH test [update]: passed\n");
+	}
+
+	memset(mac, 0, sizeof(mac));
+
+	/* Finish crypto session */
+	if (ioctl(cfd, CIOCFSESSION, &sess.ses)) {
+		perror("ioctl(CIOCFSESSION)");
+		return 1;
+	}
+
+	return 0;
+}
+
+
+int
+main()
+{
+	int fd = -1, cfd = -1;
+
+	/* Open the crypto device */
+	fd = open("/dev/crypto", O_RDWR, 0);
+	if (fd < 0) {
+		perror("open(/dev/crypto)");
+		return 1;
+	}
+
+	/* Clone file descriptor */
+	if (ioctl(fd, CRIOGET, &cfd)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	/* Set close-on-exec (not really neede here) */
+	if (fcntl(cfd, F_SETFD, 1) == -1) {
+		perror("fcntl(F_SETFD)");
+		return 1;
+	}
+
+	/* Run the test itself */
+	if (test_crypto(cfd))
+		return 1;
+
+	if (test_extras(cfd))
+		return 1;
+
+	/* Close cloned descriptor */
+	if (close(cfd)) {
+		perror("close(cfd)");
+		return 1;
+	}
+
+	/* Close the original descriptor */
+	if (close(fd)) {
+		perror("close(fd)");
+		return 1;
+	}
+
+	return 0;
+}
diff --git a/drivers/staging/crypto/cryptodev/tests/sha_speed.c b/drivers/staging/crypto/cryptodev/tests/sha_speed.c
new file mode 100644
index 000000000000..e1dc54ba5485
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/sha_speed.c
@@ -0,0 +1,198 @@
+/*  sha_speed - simple SHA benchmark tool for cryptodev
+ *
+ *    Copyright (C) 2011 by Phil Sutter <phil.sutter@viprinet.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <signal.h>
+
+#include <crypto/cryptodev.h>
+
+static double udifftimeval(struct timeval start, struct timeval end)
+{
+	return (double)(end.tv_usec - start.tv_usec) +
+	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
+}
+
+static int must_finish = 0;
+
+static void alarm_handler(int signo)
+{
+        must_finish = 1;
+}
+
+static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
+static char *si_units[] = { "", "K", "M", "G", "T", 0};
+
+static void value2human(int si, double bytes, double time, double* data, double* speed,char* metric)
+{
+	int unit = 0;
+
+	*data = bytes;
+
+	if (si) {
+		while (*data > 1000 && si_units[unit + 1]) {
+			*data /= 1000;
+			unit++;
+		}
+		*speed = *data / time;
+		sprintf(metric, "%sB", si_units[unit]);
+	} else {
+		while (*data > 1024 && units[unit + 1]) {
+			*data /= 1024;
+			unit++;
+		}
+		*speed = *data / time;
+		sprintf(metric, "%sB", units[unit]);
+	}
+}
+
+
+int hash_data(struct session_op *sess, int fdc, int chunksize, int alignmask)
+{
+	struct crypt_op cop;
+	char *buffer;
+	static int val = 23;
+	struct timeval start, end;
+	double total = 0;
+	double secs, ddata, dspeed;
+	char metric[16];
+	uint8_t mac[AALG_MAX_RESULT_LEN];
+
+	if (alignmask) {
+		if (posix_memalign((void **)&buffer, alignmask + 1, chunksize)) {
+			printf("posix_memalign() failed!\n");
+			return 1;
+		}
+	} else {
+		if (!(buffer = malloc(chunksize))) {
+			perror("malloc()");
+			return 1;
+		}
+	}
+
+	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
+	fflush(stdout);
+
+	memset(buffer, val++, chunksize);
+
+	must_finish = 0;
+	alarm(5);
+
+	gettimeofday(&start, NULL);
+	do {
+		memset(&cop, 0, sizeof(cop));
+		cop.ses = sess->ses;
+		cop.len = chunksize;
+		cop.op = COP_ENCRYPT;
+		cop.src = (unsigned char *)buffer;
+		cop.mac = mac;
+
+		if (ioctl(fdc, CIOCCRYPT, &cop)) {
+			perror("ioctl(CIOCCRYPT)");
+			return 1;
+		}
+		total+=chunksize;
+	} while(must_finish==0);
+	gettimeofday(&end, NULL);
+
+	secs = udifftimeval(start, end)/ 1000000.0;
+
+	value2human(1, total, secs, &ddata, &dspeed, metric);
+	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
+	printf ("%.2f %s/sec\n", dspeed, metric);
+
+	free(buffer);
+	return 0;
+}
+
+int main(void)
+{
+	int fd, i, fdc = -1, alignmask = 0;
+	struct session_op sess;
+	char keybuf[32];
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+
+	signal(SIGALRM, alarm_handler);
+
+	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
+		perror("open()");
+		return 1;
+	}
+	if (ioctl(fd, CRIOGET, &fdc)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	fprintf(stderr, "Testing SHA1 Hash: \n");
+	memset(&sess, 0, sizeof(sess));
+	sess.mac = CRYPTO_SHA1;
+	if (ioctl(fdc, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested hash CRYPTO_SHA1, got %s with driver %s\n",
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+	alignmask = siop.alignmask;
+#endif
+
+	for (i = 256; i <= (64 * 1024); i *= 4) {
+		if (hash_data(&sess, fdc, i, alignmask))
+			break;
+	}
+
+	fprintf(stderr, "\nTesting SHA256 Hash: \n");
+	memset(&sess, 0, sizeof(sess));
+	sess.mac = CRYPTO_SHA2_256;
+	if (ioctl(fdc, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	printf("requested hash CRYPTO_SHA2_256, got %s with driver %s\n",
+			siop.hash_info.cra_name, siop.hash_info.cra_driver_name);
+	alignmask = siop.alignmask;
+#endif
+
+	for (i = 256; i <= (64 * 1024); i *= 4) {
+		if (hash_data(&sess, fdc, i, alignmask))
+			break;
+	}
+
+	close(fdc);
+	close(fd);
+	return 0;
+}
diff --git a/drivers/staging/crypto/cryptodev/tests/speed.c b/drivers/staging/crypto/cryptodev/tests/speed.c
new file mode 100644
index 000000000000..81c5a652b907
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/speed.c
@@ -0,0 +1,212 @@
+/*  cryptodev_test - simple benchmark tool for cryptodev
+ *
+ *    Copyright (C) 2010 by Phil Sutter <phil.sutter@viprinet.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <signal.h>
+
+#include <crypto/cryptodev.h>
+
+static int si = 1; /* SI by default */
+
+static double udifftimeval(struct timeval start, struct timeval end)
+{
+	return (double)(end.tv_usec - start.tv_usec) +
+	       (double)(end.tv_sec - start.tv_sec) * 1000 * 1000;
+}
+
+static int must_finish = 0;
+
+static void alarm_handler(int signo)
+{
+        must_finish = 1;
+}
+
+static char *units[] = { "", "Ki", "Mi", "Gi", "Ti", 0};
+static char *si_units[] = { "", "K", "M", "G", "T", 0};
+
+static void value2human(int si, double bytes, double time, double* data, double* speed,char* metric)
+{
+	int unit = 0;
+
+	*data = bytes;
+	
+	if (si) {
+		while (*data > 1000 && si_units[unit + 1]) {
+			*data /= 1000;
+			unit++;
+		}
+		*speed = *data / time;
+		sprintf(metric, "%sB", si_units[unit]);
+	} else {
+		while (*data > 1024 && units[unit + 1]) {
+			*data /= 1024;
+			unit++;
+		}
+		*speed = *data / time;
+		sprintf(metric, "%sB", units[unit]);
+	}
+}
+
+#define MAX(x,y) ((x)>(y)?(x):(y))
+
+int encrypt_data(struct session_op *sess, int fdc, int chunksize, int alignmask)
+{
+	struct crypt_op cop;
+	char *buffer, iv[32];
+	static int val = 23;
+	struct timeval start, end;
+	double total = 0;
+	double secs, ddata, dspeed;
+	char metric[16];
+
+	if (alignmask) {
+		if (posix_memalign((void **)&buffer, MAX(alignmask + 1, sizeof(void*)), chunksize)) {
+			printf("posix_memalign() failed! (mask %x, size: %d)\n", alignmask+1, chunksize);
+			return 1;
+		}
+	} else {
+		if (!(buffer = malloc(chunksize))) {
+			perror("malloc()");
+			return 1;
+		}
+	}
+
+	memset(iv, 0x23, 32);
+
+	printf("\tEncrypting in chunks of %d bytes: ", chunksize);
+	fflush(stdout);
+
+	memset(buffer, val++, chunksize);
+
+	must_finish = 0;
+	alarm(5);
+
+	gettimeofday(&start, NULL);
+	do {
+		memset(&cop, 0, sizeof(cop));
+		cop.ses = sess->ses;
+		cop.len = chunksize;
+		cop.iv = (unsigned char *)iv;
+		cop.op = COP_ENCRYPT;
+		cop.src = cop.dst = (unsigned char *)buffer;
+
+		if (ioctl(fdc, CIOCCRYPT, &cop)) {
+			perror("ioctl(CIOCCRYPT)");
+			return 1;
+		}
+		total+=chunksize;
+	} while(must_finish==0);
+	gettimeofday(&end, NULL);
+
+	secs = udifftimeval(start, end)/ 1000000.0;
+
+	value2human(si, total, secs, &ddata, &dspeed, metric);
+	printf ("done. %.2f %s in %.2f secs: ", ddata, metric, secs);
+	printf ("%.2f %s/sec\n", dspeed, metric);
+
+	free(buffer);
+	return 0;
+}
+
+int main(int argc, char** argv)
+{
+	int fd, i, fdc = -1, alignmask = 0;
+	struct session_op sess;
+#ifdef CIOCGSESSINFO
+	struct session_info_op siop;
+#endif
+	char keybuf[32];
+
+	signal(SIGALRM, alarm_handler);
+	
+	if (argc > 1) {
+		if (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0) {
+			printf("Usage: speed [--kib]\n");
+			exit(0);
+		}
+		if (strcmp(argv[1], "--kib") == 0) {
+			si = 0;
+		}
+	}
+
+	if ((fd = open("/dev/crypto", O_RDWR, 0)) < 0) {
+		perror("open()");
+		return 1;
+	}
+	if (ioctl(fd, CRIOGET, &fdc)) {
+		perror("ioctl(CRIOGET)");
+		return 1;
+	}
+
+	fprintf(stderr, "Testing NULL cipher: \n");
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_NULL;
+	sess.keylen = 0;
+	sess.key = (unsigned char *)keybuf;
+	if (ioctl(fdc, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	alignmask = siop.alignmask;
+#endif
+
+	for (i = 512; i <= (64 * 1024); i *= 2) {
+		if (encrypt_data(&sess, fdc, i, alignmask))
+			break;
+	}
+
+	fprintf(stderr, "\nTesting AES-128-CBC cipher: \n");
+	memset(&sess, 0, sizeof(sess));
+	sess.cipher = CRYPTO_AES_CBC;
+	sess.keylen = 16;
+	memset(keybuf, 0x42, 16);
+	sess.key = (unsigned char *)keybuf;
+	if (ioctl(fdc, CIOCGSESSION, &sess)) {
+		perror("ioctl(CIOCGSESSION)");
+		return 1;
+	}
+#ifdef CIOCGSESSINFO
+	siop.ses = sess.ses;
+	if (ioctl(fdc, CIOCGSESSINFO, &siop)) {
+		perror("ioctl(CIOCGSESSINFO)");
+		return 1;
+	}
+	alignmask = siop.alignmask;
+#endif
+
+	for (i = 512; i <= (64 * 1024); i *= 2) {
+		if (encrypt_data(&sess, fdc, i, alignmask))
+			break;
+	}
+
+	close(fdc);
+	close(fd);
+	return 0;
+}
diff --git a/drivers/staging/crypto/cryptodev/tests/testhelper.h b/drivers/staging/crypto/cryptodev/tests/testhelper.h
new file mode 100644
index 000000000000..ea0b100cc2ac
--- /dev/null
+++ b/drivers/staging/crypto/cryptodev/tests/testhelper.h
@@ -0,0 +1,57 @@
+/*
+ * Some helper stuff shared between the sample programs.
+ */
+#ifndef _TESTHELPER_H
+#define _TESTHELPER_H
+
+/* poll until POLLOUT, then call CIOCASYNCCRYPT */
+inline int do_async_crypt(int cfd, struct crypt_op *cryp)
+{
+	struct pollfd pfd;
+
+	pfd.fd = cfd;
+	pfd.events = POLLOUT;
+
+	if (poll(&pfd, 1, -1) < 1) {
+		perror("poll()");
+		return 1;
+	}
+
+	if (ioctl(cfd, CIOCASYNCCRYPT, cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+	return 0;
+}
+
+/* poll until POLLIN, then call CIOCASYNCFETCH */
+inline int do_async_fetch(int cfd, struct crypt_op *cryp)
+{
+	struct pollfd pfd;
+
+	pfd.fd = cfd;
+	pfd.events = POLLIN;
+
+	if (poll(&pfd, 1, -1) < 1) {
+		perror("poll()");
+		return 1;
+	}
+
+	if (ioctl(cfd, CIOCASYNCFETCH, cryp)) {
+		perror("ioctl(CIOCCRYPT)");
+		return 1;
+	}
+	return 0;
+}
+
+/* Check return value of stmt for identity with goodval. If they
+ * don't match, call return with the value of stmt. */
+#define DO_OR_DIE(stmt, goodval) {                           \
+	int __rc_val;                                        \
+	if ((__rc_val = stmt) != goodval) {                  \
+		perror("DO_OR_DIE(" #stmt "," #goodval ")"); \
+		return __rc_val;                             \
+	}                                                    \
+}
+
+#endif /* _TESTHELPER_H */
-- 
2.1.0

