From 91b0a27bbb8e263533c097343dc5155ff0dff3ba Mon Sep 17 00:00:00 2001
From: Phil Sutter <phil@nwl.cc>
Date: Thu, 30 Jan 2014 02:50:23 +0100
Subject: [PATCH 277/291] cryptodev: introduce

Use them instead of directly calling dprintk. Also, line continuations
are to be indented with two tabs, unless there is good reason not to.

Signed-off-by: Phil Sutter <phil@nwl.cc>
---
 drivers/staging/crypto/cryptodev/authenc.c       | 125 +++++++++++------------
 drivers/staging/crypto/cryptodev/cryptlib.c      |  34 +++---
 drivers/staging/crypto/cryptodev/cryptodev_int.h |   7 +-
 drivers/staging/crypto/cryptodev/ioctl.c         |  87 +++++++---------
 drivers/staging/crypto/cryptodev/main.c          |  30 +++---
 drivers/staging/crypto/cryptodev/zc.c            |  11 +-
 6 files changed, 132 insertions(+), 162 deletions(-)

diff --git a/drivers/staging/crypto/cryptodev/authenc.c b/drivers/staging/crypto/cryptodev/authenc.c
index 96701f5f2a86..9d4893f7834b 100644
--- a/drivers/staging/crypto/cryptodev/authenc.c
+++ b/drivers/staging/crypto/cryptodev/authenc.c
@@ -63,12 +63,12 @@ static int get_userbuf_tls(struct csession *ses, struct kernel_crypt_auth_op *kc
 
 	if (ses->alignmask) {
 		if (!IS_ALIGNED((unsigned long)caop->dst, ses->alignmask))
-			dprintk(2, KERN_WARNING, "careful - source address %lx is not %d byte aligned\n",
-				(unsigned long)caop->dst, ses->alignmask + 1);
+			dwarning(2, "careful - source address %lx is not %d byte aligned",
+					(unsigned long)caop->dst, ses->alignmask + 1);
 	}
 
 	if (kcaop->dst_len == 0) {
-		dprintk(1, KERN_WARNING, "Destination length cannot be zero\n");
+		dwarning(1, "Destination length cannot be zero");
 		return -EINVAL;
 	}
 
@@ -84,8 +84,7 @@ static int get_userbuf_tls(struct csession *ses, struct kernel_crypt_auth_op *kc
 	rc = __get_userbuf(caop->dst, kcaop->dst_len, 1, pagecount,
 	                   ses->pages, ses->sg, kcaop->task, kcaop->mm);
 	if (unlikely(rc)) {
-		dprintk(1, KERN_ERR,
-			"failed to get user pages for data input\n");
+		derr(1, "failed to get user pages for data input");
 		return -EINVAL;
 	}
 
@@ -112,21 +111,21 @@ static int get_userbuf_srtp(struct csession *ses, struct kernel_crypt_auth_op *k
 	int rc;
 
 	if (caop->dst == NULL && caop->auth_src == NULL) {
-		dprintk(1, KERN_ERR, "dst and auth_src cannot be both null\n");
+		derr(1, "dst and auth_src cannot be both null");
 		return -EINVAL;
 	}
 
 	if (ses->alignmask) {
 		if (!IS_ALIGNED((unsigned long)caop->dst, ses->alignmask))
-			dprintk(2, KERN_WARNING, "careful - source address %lx is not %d byte aligned\n",
-				(unsigned long)caop->dst, ses->alignmask + 1);
+			dwarning(2, "careful - source address %lx is not %d byte aligned",
+					(unsigned long)caop->dst, ses->alignmask + 1);
 		if (!IS_ALIGNED((unsigned long)caop->auth_src, ses->alignmask))
-			dprintk(2, KERN_WARNING, "careful - source address %lx is not %d byte aligned\n",
-				(unsigned long)caop->auth_src, ses->alignmask + 1);
+			dwarning(2, "careful - source address %lx is not %d byte aligned",
+					(unsigned long)caop->auth_src, ses->alignmask + 1);
 	}
 
 	if (unlikely(kcaop->dst_len == 0 || caop->auth_len == 0)) {
-		dprintk(1, KERN_WARNING, "Destination length cannot be zero\n");
+		dwarning(1, "Destination length cannot be zero");
 		return -EINVAL;
 	}
 
@@ -136,7 +135,7 @@ static int get_userbuf_srtp(struct csession *ses, struct kernel_crypt_auth_op *k
 	auth_pagecount = PAGECOUNT(caop->auth_src, caop->auth_len);
 	diff = (int)(caop->src - caop->auth_src);
 	if (diff > MAX_SRTP_AUTH_DATA_DIFF || diff < 0) {
-		dprintk(1, KERN_WARNING, "auth_src must overlap with src (diff: %d).\n", diff);
+		dwarning(1, "auth_src must overlap with src (diff: %d).", diff);
 		return -EINVAL;
 	}
 
@@ -144,15 +143,14 @@ static int get_userbuf_srtp(struct csession *ses, struct kernel_crypt_auth_op *k
 
 	rc = adjust_sg_array(ses, pagecount*2); /* double pages to have pages for dst(=auth_src) */
 	if (rc) {
-		dprintk(1, KERN_ERR, "cannot adjust sg array\n");
+		derr(1, "cannot adjust sg array");
 		return rc;
 	}
 
 	rc = __get_userbuf(caop->auth_src, caop->auth_len, 1, auth_pagecount,
 			   ses->pages, ses->sg, kcaop->task, kcaop->mm);
 	if (unlikely(rc)) {
-		dprintk(1, KERN_ERR,
-			"failed to get user pages for data input\n");
+		derr(1, "failed to get user pages for data input");
 		return -EINVAL;
 	}
 
@@ -167,8 +165,7 @@ static int get_userbuf_srtp(struct csession *ses, struct kernel_crypt_auth_op *k
 	(*dst_sg) = sg_advance(*dst_sg, diff);
 	if (*dst_sg == NULL) {
 		release_user_pages(ses);
-		dprintk(1, KERN_ERR,
-			"failed to get enough pages for auth data\n");
+		derr(1, "failed to get enough pages for auth data");
 		return -EINVAL;
 	}
 
@@ -184,14 +181,13 @@ static int fill_kcaop_from_caop(struct kernel_crypt_auth_op *kcaop, struct fcryp
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, caop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", caop->ses);
+		derr(1, "invalid session ID=0x%08X", caop->ses);
 		return -EINVAL;
 	}
 
 	if (caop->flags & COP_FLAG_AEAD_TLS_TYPE || caop->flags & COP_FLAG_AEAD_SRTP_TYPE) {
 		if (caop->src != caop->dst) {
-			dprintk(1, KERN_ERR,
-				"Non-inplace encryption and decryption is not efficient and not implemented\n");
+			derr(1, "Non-inplace encryption and decryption is not efficient and not implemented");
 			ret = -EINVAL;
 			goto out_unlock;
 		}
@@ -213,9 +209,8 @@ static int fill_kcaop_from_caop(struct kernel_crypt_auth_op *kcaop, struct fcryp
 	if (caop->iv) {
 		ret = copy_from_user(kcaop->iv, caop->iv, kcaop->ivlen);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR,
-				"error copying IV (%d bytes), copy_from_user returned %d for address %lx\n",
-				kcaop->ivlen, ret, (unsigned long)caop->iv);
+			derr(1, "error copying IV (%d bytes), copy_from_user returned %d for address %lx",
+					kcaop->ivlen, ret, (unsigned long)caop->iv);
 			ret = -EFAULT;
 			goto out_unlock;
 		}
@@ -239,7 +234,7 @@ static int fill_caop_from_kcaop(struct kernel_crypt_auth_op *kcaop, struct fcryp
 		ret = copy_to_user(kcaop->caop.iv,
 				kcaop->iv, kcaop->ivlen);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR, "Error in copying to userspace\n");
+			derr(1, "Error in copying to userspace");
 			return -EFAULT;
 		}
 	}
@@ -251,7 +246,7 @@ int kcaop_from_user(struct kernel_crypt_auth_op *kcaop,
 			struct fcrypt *fcr, void __user *arg)
 {
 	if (unlikely(copy_from_user(&kcaop->caop, arg, sizeof(kcaop->caop)))) {
-		dprintk(1, KERN_ERR, "Error in copying from userspace\n");
+		derr(1, "Error in copying from userspace");
 		return -EFAULT;
 	}
 
@@ -265,12 +260,12 @@ int kcaop_to_user(struct kernel_crypt_auth_op *kcaop,
 
 	ret = fill_caop_from_kcaop(kcaop, fcr);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_ERR, "fill_caop_from_kcaop\n");
+		derr(1, "fill_caop_from_kcaop");
 		return ret;
 	}
 
 	if (unlikely(copy_to_user(arg, &kcaop->caop, sizeof(kcaop->caop)))) {
-		dprintk(1, KERN_ERR, "Error in copying to userspace\n");
+		derr(1, "Error in copying to userspace");
 		return -EFAULT;
 	}
 	return 0;
@@ -307,7 +302,7 @@ static int verify_tls_record_pad(struct scatterlist *dst_sg, int len, int block_
 	scatterwalk_map_and_copy(&pad_size, dst_sg, len - 1, 1, 0);
 
 	if (pad_size + 1 > len) {
-		dprintk(1, KERN_ERR, "Pad size: %d\n", pad_size);
+		derr(1, "Pad size: %d", pad_size);
 		return -EBADMSG;
 	}
 
@@ -315,7 +310,7 @@ static int verify_tls_record_pad(struct scatterlist *dst_sg, int len, int block_
 
 	for (i = 0; i < pad_size; i++)
 		if (pad[i] != pad_size) {
-			dprintk(1, KERN_ERR, "Pad size: %d, pad: %d\n", pad_size, (int)pad[i]);
+			derr(1, "Pad size: %d, pad: %d", pad_size, (int)pad[i]);
 			return -EBADMSG;
 		}
 
@@ -343,7 +338,7 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 								auth_sg, auth_len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
@@ -352,14 +347,14 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 								dst_sg, len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
 
 			ret = cryptodev_hash_final(&ses_ptr->hdata, hash_output);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_final: %d\n", ret);
+				derr(0, "cryptodev_hash_final: %d", ret);
 				return ret;
 			}
 
@@ -376,7 +371,7 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 			ret = cryptodev_cipher_encrypt(&ses_ptr->cdata,
 							dst_sg, dst_sg, len);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_cipher_encrypt: %d\n", ret);
+				derr(0, "cryptodev_cipher_encrypt: %d", ret);
 				return ret;
 			}
 		}
@@ -386,14 +381,14 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 							dst_sg, dst_sg, len);
 
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_cipher_decrypt: %d\n", ret);
+				derr(0, "cryptodev_cipher_decrypt: %d", ret);
 				return ret;
 			}
 
 			if (ses_ptr->cdata.blocksize > 1) {
 				ret = verify_tls_record_pad(dst_sg, len, ses_ptr->cdata.blocksize);
 				if (unlikely(ret < 0)) {
-					dprintk(2, KERN_ERR, "verify_record_pad: %d\n", ret);
+					derr(2, "verify_record_pad: %d", ret);
 					fail = 1;
 				} else {
 					len -= ret;
@@ -403,7 +398,7 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 
 		if (ses_ptr->hdata.init != 0) {
 			if (unlikely(caop->tag_len > sizeof(vhash) || caop->tag_len > len)) {
-				dprintk(1, KERN_ERR, "Illegal tag len size\n");
+				derr(1, "Illegal tag len size");
 				return -EINVAL;
 			}
 
@@ -414,7 +409,7 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 								auth_sg, auth_len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
@@ -423,19 +418,19 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 									dst_sg, len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
 
 			ret = cryptodev_hash_final(&ses_ptr->hdata, hash_output);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_final: %d\n", ret);
+				derr(0, "cryptodev_hash_final: %d", ret);
 				return ret;
 			}
 
 			if (memcmp(vhash, hash_output, caop->tag_len) != 0 || fail != 0) {
-				dprintk(2, KERN_ERR, "MAC verification failed (tag_len: %d)\n", caop->tag_len);
+				derr(2, "MAC verification failed (tag_len: %d)", caop->tag_len);
 				return -EBADMSG;
 			}
 		}
@@ -464,7 +459,7 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 			ret = cryptodev_cipher_encrypt(&ses_ptr->cdata,
 							dst_sg, dst_sg, len);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_cipher_encrypt: %d\n", ret);
+				derr(0, "cryptodev_cipher_encrypt: %d", ret);
 				return ret;
 			}
 		}
@@ -474,14 +469,14 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 								auth_sg, auth_len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
 
 			ret = cryptodev_hash_final(&ses_ptr->hdata, hash_output);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_final: %d\n", ret);
+				derr(0, "cryptodev_hash_final: %d", ret);
 				return ret;
 			}
 
@@ -492,7 +487,7 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 	} else {
 		if (ses_ptr->hdata.init != 0) {
 			if (unlikely(caop->tag_len > sizeof(vhash) || caop->tag_len > len)) {
-				dprintk(1, KERN_ERR, "Illegal tag len size\n");
+				derr(1, "Illegal tag len size");
 				return -EINVAL;
 			}
 
@@ -502,18 +497,18 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 			ret = cryptodev_hash_update(&ses_ptr->hdata,
 							auth_sg, auth_len);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+				derr(0, "cryptodev_hash_update: %d", ret);
 				return ret;
 			}
 
 			ret = cryptodev_hash_final(&ses_ptr->hdata, hash_output);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_final: %d\n", ret);
+				derr(0, "cryptodev_hash_final: %d", ret);
 				return ret;
 			}
 
 			if (memcmp(vhash, hash_output, caop->tag_len) != 0 || fail != 0) {
-				dprintk(2, KERN_ERR, "MAC verification failed\n");
+				derr(2, "MAC verification failed");
 				return -EBADMSG;
 			}
 		}
@@ -523,7 +518,7 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 							dst_sg, dst_sg, len);
 
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_cipher_decrypt: %d\n", ret);
+				derr(0, "cryptodev_cipher_decrypt: %d", ret);
 				return ret;
 			}
 		}
@@ -548,7 +543,7 @@ auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 
 	max_tag_len = cryptodev_cipher_get_tag_size(&ses_ptr->cdata);
 	if (unlikely(caop->tag_len > max_tag_len)) {
-		dprintk(0, KERN_ERR, "Illegal tag length: %d\n", caop->tag_len);
+		derr(0, "Illegal tag length: %d", caop->tag_len);
 		return -EINVAL;
 	}
 
@@ -563,7 +558,7 @@ auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 		ret = cryptodev_cipher_encrypt(&ses_ptr->cdata,
 						src_sg, dst_sg, len);
 		if (unlikely(ret)) {
-			dprintk(0, KERN_ERR, "cryptodev_cipher_encrypt: %d\n", ret);
+			derr(0, "cryptodev_cipher_encrypt: %d", ret);
 			return ret;
 		}
 		kcaop->dst_len = len + caop->tag_len;
@@ -573,7 +568,7 @@ auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 						src_sg, dst_sg, len);
 
 		if (unlikely(ret)) {
-			dprintk(0, KERN_ERR, "cryptodev_cipher_decrypt: %d\n", ret);
+			derr(0, "cryptodev_cipher_decrypt: %d", ret);
 			return ret;
 		}
 		kcaop->dst_len = len - caop->tag_len;
@@ -595,13 +590,13 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 		if (unlikely(ses_ptr->cdata.init != 0 &&
 		             (ses_ptr->cdata.stream == 0 ||
 			      ses_ptr->cdata.aead != 0))) {
-			dprintk(0, KERN_ERR, "Only stream modes are allowed in SRTP mode (but not AEAD)\n");
+			derr(0, "Only stream modes are allowed in SRTP mode (but not AEAD)");
 			return -EINVAL;
 		}
 
 		ret = get_userbuf_srtp(ses_ptr, kcaop, &auth_sg, &dst_sg);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR, "get_userbuf_srtp(): Error getting user pages.\n");
+			derr(1, "get_userbuf_srtp(): Error getting user pages.");
 			return ret;
 		}
 
@@ -617,19 +612,19 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 		struct scatterlist tmp;
 
 		if (unlikely(caop->auth_len > PAGE_SIZE)) {
-			dprintk(1, KERN_ERR, "auth data len is excessive.\n");
+			derr(1, "auth data len is excessive.");
 			return -EINVAL;
 		}
 
 		auth_buf = (char *)__get_free_page(GFP_KERNEL);
 		if (unlikely(!auth_buf)) {
-			dprintk(1, KERN_ERR, "unable to get a free page.\n");
+			derr(1, "unable to get a free page.");
 			return -ENOMEM;
 		}
 
 		if (caop->auth_src && caop->auth_len > 0) {
 			if (unlikely(copy_from_user(auth_buf, caop->auth_src, caop->auth_len))) {
-				dprintk(1, KERN_ERR, "unable to copy auth data from userspace.\n");
+				derr(1, "unable to copy auth data from userspace.");
 				ret = -EFAULT;
 				goto free_auth_buf;
 			}
@@ -643,7 +638,7 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 		if (caop->flags & COP_FLAG_AEAD_TLS_TYPE && ses_ptr->cdata.aead == 0) {
 			ret = get_userbuf_tls(ses_ptr, kcaop, &dst_sg);
 			if (unlikely(ret)) {
-				dprintk(1, KERN_ERR, "get_userbuf_tls(): Error getting user pages.\n");
+				derr(1, "get_userbuf_tls(): Error getting user pages.");
 				goto free_auth_buf;
 			}
 
@@ -655,7 +650,7 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 			if (unlikely(ses_ptr->cdata.init == 0 ||
 			             (ses_ptr->cdata.stream == 0 &&
 				      ses_ptr->cdata.aead == 0))) {
-				dprintk(0, KERN_ERR, "Only stream and AEAD ciphers are allowed for authenc\n");
+				derr(0, "Only stream and AEAD ciphers are allowed for authenc");
 				ret = -EINVAL;
 				goto free_auth_buf;
 			}
@@ -668,7 +663,7 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 			ret = get_userbuf(ses_ptr, caop->src, caop->len, caop->dst, dst_len,
 					  kcaop->task, kcaop->mm, &src_sg, &dst_sg);
 			if (unlikely(ret)) {
-				dprintk(1, KERN_ERR, "get_userbuf(): Error getting user pages.\n");
+				derr(1, "get_userbuf(): Error getting user pages.");
 				goto free_auth_buf;
 			}
 
@@ -693,19 +688,19 @@ int crypto_auth_run(struct fcrypt *fcr, struct kernel_crypt_auth_op *kcaop)
 	int ret;
 
 	if (unlikely(caop->op != COP_ENCRYPT && caop->op != COP_DECRYPT)) {
-		dprintk(1, KERN_DEBUG, "invalid operation op=%u\n", caop->op);
+		ddebug(1, "invalid operation op=%u", caop->op);
 		return -EINVAL;
 	}
 
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, caop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", caop->ses);
+		derr(1, "invalid session ID=0x%08X", caop->ses);
 		return -EINVAL;
 	}
 
 	if (unlikely(ses_ptr->cdata.init == 0)) {
-		dprintk(1, KERN_ERR, "cipher context not initialized\n");
+		derr(1, "cipher context not initialized");
 		ret = -EINVAL;
 		goto out_unlock;
 	}
@@ -714,8 +709,7 @@ int crypto_auth_run(struct fcrypt *fcr, struct kernel_crypt_auth_op *kcaop)
 	if (ses_ptr->hdata.init != 0) {
 		ret = cryptodev_hash_reset(&ses_ptr->hdata);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR,
-				"error in cryptodev_hash_reset()\n");
+			derr(1, "error in cryptodev_hash_reset()");
 			goto out_unlock;
 		}
 	}
@@ -725,8 +719,7 @@ int crypto_auth_run(struct fcrypt *fcr, struct kernel_crypt_auth_op *kcaop)
 
 	ret = __crypto_auth_run_zc(ses_ptr, kcaop);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_ERR,
-			"error in __crypto_auth_run_zc()\n");
+		derr(1, "error in __crypto_auth_run_zc()");
 		goto out_unlock;
 	}
 
diff --git a/drivers/staging/crypto/cryptodev/cryptlib.c b/drivers/staging/crypto/cryptodev/cryptlib.c
index d9f17ee02466..a7fbff412822 100644
--- a/drivers/staging/crypto/cryptodev/cryptlib.c
+++ b/drivers/staging/crypto/cryptodev/cryptlib.c
@@ -63,7 +63,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 
 		out->async.s = crypto_alloc_ablkcipher(alg_name, 0, 0);
 		if (unlikely(IS_ERR(out->async.s))) {
-			dprintk(1, KERN_DEBUG, "Failed to load cipher %s\n", alg_name);
+			ddebug(1, "Failed to load cipher %s", alg_name);
 				return -EINVAL;
 		}
 
@@ -73,11 +73,8 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 			if (alg->max_keysize > 0 &&
 					unlikely((keylen < alg->min_keysize) ||
 					(keylen > alg->max_keysize))) {
-				dprintk(1, KERN_DEBUG,
-					"Wrong keylen '%zu' for algorithm '%s'. \
-					Use %u to %u.\n",
-					   keylen, alg_name, alg->min_keysize,
-					   alg->max_keysize);
+				ddebug(1, "Wrong keylen '%zu' for algorithm '%s'. Use %u to %u.",
+						keylen, alg_name, alg->min_keysize, alg->max_keysize);
 				ret = -EINVAL;
 				goto error;
 			}
@@ -91,7 +88,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 	} else {
 		out->async.as = crypto_alloc_aead(alg_name, 0, 0);
 		if (unlikely(IS_ERR(out->async.as))) {
-			dprintk(1, KERN_DEBUG, "Failed to load cipher %s\n", alg_name);
+			ddebug(1, "Failed to load cipher %s", alg_name);
 			return -EINVAL;
 		}
 
@@ -103,8 +100,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 	}
 
 	if (unlikely(ret)) {
-		dprintk(1, KERN_DEBUG, "Setting key failed for %s-%zu.\n",
-			alg_name, keylen*8);
+		ddebug(1, "Setting key failed for %s-%zu.", alg_name, keylen*8);
 		ret = -EINVAL;
 		goto error;
 	}
@@ -123,7 +119,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 	if (aead == 0) {
 		out->async.request = ablkcipher_request_alloc(out->async.s, GFP_KERNEL);
 		if (unlikely(!out->async.request)) {
-			dprintk(1, KERN_ERR, "error allocating async crypto request\n");
+			derr(1, "error allocating async crypto request");
 			ret = -ENOMEM;
 			goto error;
 		}
@@ -134,7 +130,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 	} else {
 		out->async.arequest = aead_request_alloc(out->async.as, GFP_KERNEL);
 		if (unlikely(!out->async.arequest)) {
-			dprintk(1, KERN_ERR, "error allocating async crypto request\n");
+			derr(1, "error allocating async crypto request");
 			ret = -ENOMEM;
 			goto error;
 		}
@@ -198,8 +194,7 @@ static inline int waitfor(struct cryptodev_result *cr, ssize_t ret)
 		 * another request. */
 
 		if (unlikely(cr->err)) {
-			dprintk(0, KERN_ERR, "error from async request: %d\n",
-				cr->err);
+			derr(0, "error from async request: %d", cr->err);
 			return cr->err;
 		}
 
@@ -265,7 +260,7 @@ int cryptodev_hash_init(struct hash_data *hdata, const char *alg_name,
 
 	hdata->async.s = crypto_alloc_ahash(alg_name, 0, 0);
 	if (unlikely(IS_ERR(hdata->async.s))) {
-		dprintk(1, KERN_DEBUG, "Failed to load transform for %s\n", alg_name);
+		ddebug(1, "Failed to load transform for %s", alg_name);
 		return -EINVAL;
 	}
 
@@ -273,9 +268,8 @@ int cryptodev_hash_init(struct hash_data *hdata, const char *alg_name,
 	if (hmac_mode != 0) {
 		ret = crypto_ahash_setkey(hdata->async.s, mackey, mackeylen);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_DEBUG,
-				"Setting hmac key failed for %s-%zu.\n",
-				alg_name, mackeylen*8);
+			ddebug(1, "Setting hmac key failed for %s-%zu.",
+					alg_name, mackeylen*8);
 			ret = -EINVAL;
 			goto error;
 		}
@@ -294,7 +288,7 @@ int cryptodev_hash_init(struct hash_data *hdata, const char *alg_name,
 
 	hdata->async.request = ahash_request_alloc(hdata->async.s, GFP_KERNEL);
 	if (unlikely(!hdata->async.request)) {
-		dprintk(0, KERN_ERR, "error allocating async crypto request\n");
+		derr(0, "error allocating async crypto request");
 		ret = -ENOMEM;
 		goto error;
 	}
@@ -305,7 +299,7 @@ int cryptodev_hash_init(struct hash_data *hdata, const char *alg_name,
 
 	ret = crypto_ahash_init(hdata->async.request);
 	if (unlikely(ret)) {
-		dprintk(0, KERN_ERR, "error in crypto_hash_init()\n");
+		derr(0, "error in crypto_hash_init()");
 		goto error_request;
 	}
 
@@ -338,7 +332,7 @@ int cryptodev_hash_reset(struct hash_data *hdata)
 
 	ret = crypto_ahash_init(hdata->async.request);
 	if (unlikely(ret)) {
-		dprintk(0, KERN_ERR, "error in crypto_hash_init()\n");
+		derr(0, "error in crypto_hash_init()");
 		return ret;
 	}
 
diff --git a/drivers/staging/crypto/cryptodev/cryptodev_int.h b/drivers/staging/crypto/cryptodev/cryptodev_int.h
index 781f9b9b1f23..d7660fac5344 100644
--- a/drivers/staging/crypto/cryptodev/cryptodev_int.h
+++ b/drivers/staging/crypto/cryptodev/cryptodev_int.h
@@ -24,11 +24,16 @@
 #define dprintk(level, severity, format, a...)			\
 	do {							\
 		if (level <= cryptodev_verbosity)		\
-			printk(severity PFX "%s[%u] (%s:%u): " format,	\
+			printk(severity PFX "%s[%u] (%s:%u): " format "\n",	\
 			       current->comm, current->pid,	\
 			       __func__, __LINE__,		\
 			       ##a);				\
 	} while (0)
+#define derr(level, format, a...) dprintk(level, KERN_ERR, format, ##a)
+#define dwarning(level, format, a...) dprintk(level, KERN_WARNING, format, ##a)
+#define dinfo(level, format, a...) dprintk(level, KERN_INFO, format, ##a)
+#define ddebug(level, format, a...) dprintk(level, KERN_DEBUG, format, ##a)
+
 
 extern int cryptodev_verbosity;
 
diff --git a/drivers/staging/crypto/cryptodev/ioctl.c b/drivers/staging/crypto/cryptodev/ioctl.c
index ba97b48ce2a2..0bdaef505a9d 100644
--- a/drivers/staging/crypto/cryptodev/ioctl.c
+++ b/drivers/staging/crypto/cryptodev/ioctl.c
@@ -112,7 +112,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 
 	/* Does the request make sense? */
 	if (unlikely(!sop->cipher && !sop->mac)) {
-		dprintk(1, KERN_DEBUG, "Both 'cipher' and 'mac' unset.\n");
+		ddebug(1, "Both 'cipher' and 'mac' unset.");
 		return -EINVAL;
 	}
 
@@ -151,7 +151,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		stream = 1;
 		break;
 	default:
-		dprintk(1, KERN_DEBUG, "bad cipher: %d\n", sop->cipher);
+		ddebug(1, "bad cipher: %d", sop->cipher);
 		return -EINVAL;
 	}
 
@@ -211,7 +211,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		hmac_mode = 0;
 		break;
 	default:
-		dprintk(1, KERN_DEBUG, "bad mac: %d\n", sop->mac);
+		ddebug(1, "bad mac: %d", sop->mac);
 		return -EINVAL;
 	}
 
@@ -225,8 +225,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		uint8_t keyp[CRYPTO_CIPHER_MAX_KEY_LEN];
 
 		if (unlikely(sop->keylen > CRYPTO_CIPHER_MAX_KEY_LEN)) {
-			dprintk(1, KERN_DEBUG,
-				"Setting key failed for %s-%zu.\n",
+			ddebug(1, "Setting key failed for %s-%zu.",
 				alg_name, (size_t)sop->keylen*8);
 			ret = -EINVAL;
 			goto error_cipher;
@@ -240,8 +239,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		ret = cryptodev_cipher_init(&ses_new->cdata, alg_name, keyp,
 						sop->keylen, stream, aead);
 		if (ret < 0) {
-			dprintk(1, KERN_DEBUG,
-				"Failed to load cipher for %s\n", alg_name);
+			ddebug(1, "Failed to load cipher for %s", alg_name);
 			ret = -EINVAL;
 			goto error_cipher;
 		}
@@ -251,8 +249,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		uint8_t keyp[CRYPTO_HMAC_MAX_KEY_LEN];
 
 		if (unlikely(sop->mackeylen > CRYPTO_HMAC_MAX_KEY_LEN)) {
-			dprintk(1, KERN_DEBUG,
-				"Setting key failed for %s-%zu.\n",
+			ddebug(1, "Setting key failed for %s-%zu.",
 				hash_name, (size_t)sop->mackeylen*8);
 			ret = -EINVAL;
 			goto error_hash;
@@ -267,7 +264,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		ret = cryptodev_hash_init(&ses_new->hdata, hash_name, hmac_mode,
 							keyp, sop->mackeylen);
 		if (ret != 0) {
-			dprintk(1, KERN_DEBUG, "Failed to load hash for %s\n", hash_name);
+			ddebug(1, "Failed to load hash for %s", hash_name);
 			ret = -EINVAL;
 			goto error_hash;
 		}
@@ -275,17 +272,16 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 
 	ses_new->alignmask = max(ses_new->cdata.alignmask,
 	                                          ses_new->hdata.alignmask);
-	dprintk(2, KERN_DEBUG, "got alignmask %d\n", ses_new->alignmask);
+	ddebug(2, "got alignmask %d", ses_new->alignmask);
 
 	ses_new->array_size = DEFAULT_PREALLOC_PAGES;
-	dprintk(2, KERN_DEBUG, "preallocating for %d user pages\n",
-			ses_new->array_size);
+	ddebug(2, "preallocating for %d user pages", ses_new->array_size);
 	ses_new->pages = kzalloc(ses_new->array_size *
 			sizeof(struct page *), GFP_KERNEL);
 	ses_new->sg = kzalloc(ses_new->array_size *
 			sizeof(struct scatterlist), GFP_KERNEL);
 	if (ses_new->sg == NULL || ses_new->pages == NULL) {
-		dprintk(0, KERN_DEBUG, "Memory error\n");
+		ddebug(0, "Memory error");
 		ret = -ENOMEM;
 		goto error_hash;
 	}
@@ -330,15 +326,13 @@ static inline void
 crypto_destroy_session(struct csession *ses_ptr)
 {
 	if (!mutex_trylock(&ses_ptr->sem)) {
-		dprintk(2, KERN_DEBUG, "Waiting for semaphore of sid=0x%08X\n",
-			ses_ptr->sid);
+		ddebug(2, "Waiting for semaphore of sid=0x%08X", ses_ptr->sid);
 		mutex_lock(&ses_ptr->sem);
 	}
-	dprintk(2, KERN_DEBUG, "Removed session 0x%08X\n", ses_ptr->sid);
+	ddebug(2, "Removed session 0x%08X", ses_ptr->sid);
 	cryptodev_cipher_deinit(&ses_ptr->cdata);
 	cryptodev_hash_deinit(&ses_ptr->hdata);
-	dprintk(2, KERN_DEBUG, "freeing space for %d user pages\n",
-			ses_ptr->array_size);
+	ddebug(2, "freeing space for %d user pages", ses_ptr->array_size);
 	kfree(ses_ptr->pages);
 	kfree(ses_ptr->sg);
 	mutex_unlock(&ses_ptr->sem);
@@ -365,8 +359,7 @@ crypto_finish_session(struct fcrypt *fcr, uint32_t sid)
 	}
 
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "Session with sid=0x%08X not found!\n",
-			sid);
+		derr(1, "Session with sid=0x%08X not found!", sid);
 		ret = -ENOENT;
 	}
 	mutex_unlock(&fcr->sem);
@@ -430,8 +423,7 @@ static void cryptask_routine(struct work_struct *work)
 	list_for_each_entry(item, &tmp, __hook) {
 		item->result = crypto_run(&pcr->fcrypt, &item->kcop);
 		if (unlikely(item->result))
-			dprintk(0, KERN_ERR, "crypto_run() failed: %d\n",
-					item->result);
+			derr(0, "crypto_run() failed: %d", item->result);
 	}
 
 	/* push all handled jobs to the done list at once */
@@ -476,14 +468,12 @@ cryptodev_open(struct inode *inode, struct file *filp)
 		if (!tmp)
 			return -ENOMEM;
 		pcr->itemcount++;
-		dprintk(2, KERN_DEBUG, "allocated new item at %lx\n",
-				(unsigned long)tmp);
+		ddebug(2, "allocated new item at %lx", (unsigned long)tmp);
 		list_add(&tmp->__hook, &pcr->free.list);
 	}
 
-	dprintk(2, KERN_DEBUG,
-	        "Cryptodev handle initialised, %d elements in queue\n",
-		DEF_COP_RINGSIZE);
+	ddebug(2, "Cryptodev handle initialised, %d elements in queue",
+			DEF_COP_RINGSIZE);
 	return 0;
 }
 
@@ -503,17 +493,15 @@ cryptodev_release(struct inode *inode, struct file *filp)
 	list_splice_tail(&pcr->done.list, &pcr->free.list);
 
 	list_for_each_entry_safe(item, item_safe, &pcr->free.list, __hook) {
-		dprintk(2, KERN_DEBUG, "freeing item at %lx\n",
-				(unsigned long)item);
+		ddebug(2, "freeing item at %lx", (unsigned long)item);
 		list_del(&item->__hook);
 		kfree(item);
 		items_freed++;
 	}
 
 	if (items_freed != pcr->itemcount) {
-		dprintk(0, KERN_ERR,
-		        "freed %d items, but %d should exist!\n",
-		        items_freed, pcr->itemcount);
+		derr(0, "freed %d items, but %d should exist!",
+				items_freed, pcr->itemcount);
 	}
 
 	crypto_finish_all_sessions(&pcr->fcrypt);
@@ -526,9 +514,8 @@ cryptodev_release(struct inode *inode, struct file *filp)
 	kfree(pcr);
 	filp->private_data = NULL;
 
-	dprintk(2, KERN_DEBUG,
-	        "Cryptodev handle deinitialised, %d elements freed\n",
-	        items_freed);
+	ddebug(2, "Cryptodev handle deinitialised, %d elements freed",
+			items_freed);
 	return 0;
 }
 
@@ -577,8 +564,7 @@ static int crypto_async_run(struct crypt_priv *pcr, struct kernel_crypt_op *kcop
 		item = kzalloc(sizeof(struct todo_list_item), GFP_KERNEL);
 		if (unlikely(!item))
 			return -EFAULT;
-		dprintk(1, KERN_INFO, "increased item count to %d\n",
-				pcr->itemcount);
+		dinfo(1, "increased item count to %d", pcr->itemcount);
 	}
 
 	memcpy(&item->kcop, kcop, sizeof(struct kernel_crypt_op));
@@ -635,7 +621,7 @@ static int fill_kcop_from_cop(struct kernel_crypt_op *kcop, struct fcrypt *fcr)
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, cop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", cop->ses);
+		derr(1, "invalid session ID=0x%08X", cop->ses);
 		return -EINVAL;
 	}
 	kcop->ivlen = cop->iv ? ses_ptr->cdata.ivsize : 0;
@@ -649,9 +635,8 @@ static int fill_kcop_from_cop(struct kernel_crypt_op *kcop, struct fcrypt *fcr)
 	if (cop->iv) {
 		rc = copy_from_user(kcop->iv, cop->iv, kcop->ivlen);
 		if (unlikely(rc)) {
-			dprintk(1, KERN_ERR,
-				"error copying IV (%d bytes), copy_from_user returned %d for address %lx\n",
-				kcop->ivlen, rc, (unsigned long)cop->iv);
+			derr(1, "error copying IV (%d bytes), copy_from_user returned %d for address %lx",
+					kcop->ivlen, rc, (unsigned long)cop->iv);
 			return -EFAULT;
 		}
 	}
@@ -695,12 +680,12 @@ static int kcop_to_user(struct kernel_crypt_op *kcop,
 
 	ret = fill_cop_from_kcop(kcop, fcr);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_ERR, "Error in fill_cop_from_kcop\n");
+		derr(1, "Error in fill_cop_from_kcop");
 		return ret;
 	}
 
 	if (unlikely(copy_to_user(arg, &kcop->cop, sizeof(kcop->cop)))) {
-		dprintk(1, KERN_ERR, "Cannot copy to userspace\n");
+		derr(1, "Cannot copy to userspace");
 		return -EFAULT;
 	}
 	return 0;
@@ -749,7 +734,7 @@ static int get_session_info(struct fcrypt *fcr, struct session_info_op *siop)
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, siop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", siop->ses);
+		derr(1, "invalid session ID=0x%08X", siop->ses);
 		return -EINVAL;
 	}
 
@@ -846,26 +831,26 @@ cryptodev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg_)
 		return copy_to_user(arg, &siop, sizeof(siop));
 	case CIOCCRYPT:
 		if (unlikely(ret = kcop_from_user(&kcop, fcr, arg))) {
-			dprintk(1, KERN_WARNING, "Error copying from user\n");
+			dwarning(1, "Error copying from user");
 			return ret;
 		}
 
 		ret = crypto_run(fcr, &kcop);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_WARNING, "Error in crypto_run\n");
+			dwarning(1, "Error in crypto_run");
 			return ret;
 		}
 
 		return kcop_to_user(&kcop, fcr, arg);
 	case CIOCAUTHCRYPT:
 		if (unlikely(ret = kcaop_from_user(&kcaop, fcr, arg))) {
-			dprintk(1, KERN_WARNING, "Error copying from user\n");
+			dwarning(1, "Error copying from user");
 			return ret;
 		}
 
 		ret = crypto_auth_run(fcr, &kcaop);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_WARNING, "Error in crypto_auth_run\n");
+			dwarning(1, "Error in crypto_auth_run");
 			return ret;
 		}
 		return kcaop_to_user(&kcaop, fcr, arg);
@@ -964,13 +949,13 @@ static int compat_kcop_to_user(struct kernel_crypt_op *kcop,
 
 	ret = fill_cop_from_kcop(kcop, fcr);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_WARNING, "Error in fill_cop_from_kcop\n");
+		dwarning(1, "Error in fill_cop_from_kcop");
 		return ret;
 	}
 	crypt_op_to_compat(&kcop->cop, &compat_cop);
 
 	if (unlikely(copy_to_user(arg, &compat_cop, sizeof(compat_cop)))) {
-		dprintk(1, KERN_WARNING, "Error copying to user\n");
+		dwarning(1, "Error copying to user");
 		return -EFAULT;
 	}
 	return 0;
diff --git a/drivers/staging/crypto/cryptodev/main.c b/drivers/staging/crypto/cryptodev/main.c
index a25b2c6a44d1..6ce0efe37ff7 100644
--- a/drivers/staging/crypto/cryptodev/main.c
+++ b/drivers/staging/crypto/cryptodev/main.c
@@ -95,7 +95,7 @@ hash_n_crypt(struct csession *ses_ptr, struct crypt_op *cop,
 	}
 	return 0;
 out_err:
-	dprintk(0, KERN_ERR, "CryptoAPI failure: %d\n", ret);
+	derr(0, "CryptoAPI failure: %d", ret);
 	return ret;
 }
 
@@ -114,7 +114,7 @@ __crypto_run_std(struct csession *ses_ptr, struct crypt_op *cop)
 	data = (char *)__get_free_page(GFP_KERNEL);
 
 	if (unlikely(!data)) {
-		dprintk(1, KERN_ERR, "Error getting free page.\n");
+		derr(1, "Error getting free page.");
 		return -ENOMEM;
 	}
 
@@ -127,7 +127,7 @@ __crypto_run_std(struct csession *ses_ptr, struct crypt_op *cop)
 		size_t current_len = nbytes > bufsize ? bufsize : nbytes;
 
 		if (unlikely(copy_from_user(data, src, current_len))) {
-		        dprintk(1, KERN_ERR, "Error copying %d bytes from user address %p.\n", (int)current_len, src);
+		        derr(1, "Error copying %d bytes from user address %p.", (int)current_len, src);
 			ret = -EFAULT;
 			break;
 		}
@@ -137,13 +137,13 @@ __crypto_run_std(struct csession *ses_ptr, struct crypt_op *cop)
 		ret = hash_n_crypt(ses_ptr, cop, &sg, &sg, current_len);
 
 		if (unlikely(ret)) {
-		        dprintk(1, KERN_ERR, "hash_n_crypt failed.\n");
+		        derr(1, "hash_n_crypt failed.");
 			break;
 		}
 
 		if (ses_ptr->cdata.init != 0) {
 			if (unlikely(copy_to_user(dst, data, current_len))) {
-			        dprintk(1, KERN_ERR, "could not copy to user.\n");
+			        derr(1, "could not copy to user.");
 				ret = -EFAULT;
 				break;
 			}
@@ -171,8 +171,7 @@ __crypto_run_zc(struct csession *ses_ptr, struct kernel_crypt_op *kcop)
 	ret = get_userbuf(ses_ptr, cop->src, cop->len, cop->dst, cop->len,
 	                  kcop->task, kcop->mm, &src_sg, &dst_sg);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_ERR, "Error getting user pages. "
-					"Falling back to non zero copy.\n");
+		derr(1, "Error getting user pages. Falling back to non zero copy.");
 		return __crypto_run_std(ses_ptr, cop);
 	}
 
@@ -189,22 +188,21 @@ int crypto_run(struct fcrypt *fcr, struct kernel_crypt_op *kcop)
 	int ret;
 
 	if (unlikely(cop->op != COP_ENCRYPT && cop->op != COP_DECRYPT)) {
-		dprintk(1, KERN_DEBUG, "invalid operation op=%u\n", cop->op);
+		ddebug(1, "invalid operation op=%u", cop->op);
 		return -EINVAL;
 	}
 
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, cop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", cop->ses);
+		derr(1, "invalid session ID=0x%08X", cop->ses);
 		return -EINVAL;
 	}
 
 	if (ses_ptr->hdata.init != 0 && (cop->flags == 0 || cop->flags & COP_FLAG_RESET)) {
 		ret = cryptodev_hash_reset(&ses_ptr->hdata);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR,
-				"error in cryptodev_hash_reset()\n");
+			derr(1, "error in cryptodev_hash_reset()");
 			goto out_unlock;
 		}
 	}
@@ -213,9 +211,7 @@ int crypto_run(struct fcrypt *fcr, struct kernel_crypt_op *kcop)
 		int blocksize = ses_ptr->cdata.blocksize;
 
 		if (unlikely(cop->len % blocksize)) {
-			dprintk(1, KERN_ERR,
-				"data size (%u) isn't a multiple "
-				"of block size (%u)\n",
+			derr(1, "data size (%u) isn't a multiple of block size (%u)",
 				cop->len, blocksize);
 			ret = -EINVAL;
 			goto out_unlock;
@@ -228,13 +224,13 @@ int crypto_run(struct fcrypt *fcr, struct kernel_crypt_op *kcop)
 	if (likely(cop->len)) {
 		if (cop->flags & COP_FLAG_NO_ZC) {
 			if (unlikely(ses_ptr->alignmask && !IS_ALIGNED((unsigned long)cop->src, ses_ptr->alignmask))) {
-				dprintk(2, KERN_WARNING, "source address %lx is not %d byte aligned - disabling zero copy\n",
+				dwarning(2, "source address %lx is not %d byte aligned - disabling zero copy",
 						(unsigned long)cop->src, ses_ptr->alignmask + 1);
 				cop->flags &= ~COP_FLAG_NO_ZC;
 			}
 
 			if (unlikely(ses_ptr->alignmask && !IS_ALIGNED((unsigned long)cop->dst, ses_ptr->alignmask))) {
-				dprintk(2, KERN_WARNING, "destination address %lx is not %d byte aligned - disabling zero copy\n",
+				dwarning(2, "destination address %lx is not %d byte aligned - disabling zero copy",
 						(unsigned long)cop->dst, ses_ptr->alignmask + 1);
 				cop->flags &= ~COP_FLAG_NO_ZC;
 			}
@@ -259,7 +255,7 @@ int crypto_run(struct fcrypt *fcr, struct kernel_crypt_op *kcop)
 
 		ret = cryptodev_hash_final(&ses_ptr->hdata, kcop->hash_output);
 		if (unlikely(ret)) {
-			dprintk(0, KERN_ERR, "CryptoAPI failure: %d\n", ret);
+			derr(0, "CryptoAPI failure: %d", ret);
 			goto out_unlock;
 		}
 		kcop->digestsize = ses_ptr->hdata.digestsize;
diff --git a/drivers/staging/crypto/cryptodev/zc.c b/drivers/staging/crypto/cryptodev/zc.c
index 3b986e7a3863..809a36d7ce98 100644
--- a/drivers/staging/crypto/cryptodev/zc.c
+++ b/drivers/staging/crypto/cryptodev/zc.c
@@ -89,7 +89,7 @@ int adjust_sg_array(struct csession *ses, int pagecount)
 	for (array_size = ses->array_size; array_size < pagecount;
 	     array_size *= 2)
 		;
-	dprintk(0, KERN_DEBUG, "reallocating from %d to %d pages\n",
+	ddebug(0, "reallocating from %d to %d pages",
 			ses->array_size, array_size);
 	pages = krealloc(ses->pages, array_size * sizeof(struct page *),
 			 GFP_KERNEL);
@@ -165,8 +165,7 @@ int get_userbuf(struct csession *ses,
 		rc = __get_userbuf(src, src_len, 1, ses->used_pages,
 			               ses->pages, ses->sg, task, mm);
 		if (unlikely(rc)) {
-			dprintk(1, KERN_ERR,
-				"failed to get user pages for data IO\n");
+			derr(1, "failed to get user pages for data IO");
 			return rc;
 		}
 		(*src_sg) = (*dst_sg) = ses->sg;
@@ -180,8 +179,7 @@ int get_userbuf(struct csession *ses,
 		rc = __get_userbuf(src, src_len, 0, ses->readonly_pages,
 					   ses->pages, ses->sg, task, mm);
 		if (unlikely(rc)) {
-			dprintk(1, KERN_ERR,
-				"failed to get user pages for data input\n");
+			derr(1, "failed to get user pages for data input");
 			return rc;
 		}
 		*src_sg = ses->sg;
@@ -196,8 +194,7 @@ int get_userbuf(struct csession *ses,
 		rc = __get_userbuf(dst, dst_len, 1, writable_pages,
 					   dst_pages, *dst_sg, task, mm);
 		if (unlikely(rc)) {
-			dprintk(1, KERN_ERR,
-					"failed to get user pages for data output\n");
+			derr(1, "failed to get user pages for data output");
 			release_user_pages(ses);  /* FIXME: use __release_userbuf(src, ...) */
 			return rc;
 		}
-- 
2.1.0

