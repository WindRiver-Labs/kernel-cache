From b62fc3fbf1b884e538969f4c4fe204e9ad0ca6e3 Mon Sep 17 00:00:00 2001
From: Phil Sutter <phil@nwl.cc>
Date: Thu, 30 Jan 2014 02:50:23 +0100
Subject: [PATCH 277/292] introduce ddebug, dinfo, dwarning and derr macros

Use them instead of directly calling dprintk. Also, line continuations
are to be indented with two tabs, unless there is good reason not to.

Signed-off-by: Phil Sutter <phil@nwl.cc>
---
 drivers/staging/crypto/cryptodev/authenc.c       | 125 +++++++++++------------
 drivers/staging/crypto/cryptodev/cryptlib.c      |  34 +++---
 drivers/staging/crypto/cryptodev/cryptodev_int.h |   7 +-
 drivers/staging/crypto/cryptodev/ioctl.c         |  87 +++++++---------
 drivers/staging/crypto/cryptodev/main.c          |  30 +++---
 drivers/staging/crypto/cryptodev/zc.c            |  11 +-
 6 files changed, 132 insertions(+), 162 deletions(-)

diff --git a/drivers/staging/crypto/cryptodev/authenc.c b/drivers/staging/crypto/cryptodev/authenc.c
index 96701f5f2a86..9d4893f7834b 100644
--- a/drivers/staging/crypto/cryptodev/authenc.c
+++ b/drivers/staging/crypto/cryptodev/authenc.c
@@ -63,12 +63,12 @@ static int get_userbuf_tls(struct csession *ses, struct kernel_crypt_auth_op *kc
 
 	if (ses->alignmask) {
 		if (!IS_ALIGNED((unsigned long)caop->dst, ses->alignmask))
-			dprintk(2, KERN_WARNING, "careful - source address %lx is not %d byte aligned\n",
-				(unsigned long)caop->dst, ses->alignmask + 1);
+			dwarning(2, "careful - source address %lx is not %d byte aligned",
+					(unsigned long)caop->dst, ses->alignmask + 1);
 	}
 
 	if (kcaop->dst_len == 0) {
-		dprintk(1, KERN_WARNING, "Destination length cannot be zero\n");
+		dwarning(1, "Destination length cannot be zero");
 		return -EINVAL;
 	}
 
@@ -84,8 +84,7 @@ static int get_userbuf_tls(struct csession *ses, struct kernel_crypt_auth_op *kc
 	rc = __get_userbuf(caop->dst, kcaop->dst_len, 1, pagecount,
 	                   ses->pages, ses->sg, kcaop->task, kcaop->mm);
 	if (unlikely(rc)) {
-		dprintk(1, KERN_ERR,
-			"failed to get user pages for data input\n");
+		derr(1, "failed to get user pages for data input");
 		return -EINVAL;
 	}
 
@@ -112,21 +111,21 @@ static int get_userbuf_srtp(struct csession *ses, struct kernel_crypt_auth_op *k
 	int rc;
 
 	if (caop->dst == NULL && caop->auth_src == NULL) {
-		dprintk(1, KERN_ERR, "dst and auth_src cannot be both null\n");
+		derr(1, "dst and auth_src cannot be both null");
 		return -EINVAL;
 	}
 
 	if (ses->alignmask) {
 		if (!IS_ALIGNED((unsigned long)caop->dst, ses->alignmask))
-			dprintk(2, KERN_WARNING, "careful - source address %lx is not %d byte aligned\n",
-				(unsigned long)caop->dst, ses->alignmask + 1);
+			dwarning(2, "careful - source address %lx is not %d byte aligned",
+					(unsigned long)caop->dst, ses->alignmask + 1);
 		if (!IS_ALIGNED((unsigned long)caop->auth_src, ses->alignmask))
-			dprintk(2, KERN_WARNING, "careful - source address %lx is not %d byte aligned\n",
-				(unsigned long)caop->auth_src, ses->alignmask + 1);
+			dwarning(2, "careful - source address %lx is not %d byte aligned",
+					(unsigned long)caop->auth_src, ses->alignmask + 1);
 	}
 
 	if (unlikely(kcaop->dst_len == 0 || caop->auth_len == 0)) {
-		dprintk(1, KERN_WARNING, "Destination length cannot be zero\n");
+		dwarning(1, "Destination length cannot be zero");
 		return -EINVAL;
 	}
 
@@ -136,7 +135,7 @@ static int get_userbuf_srtp(struct csession *ses, struct kernel_crypt_auth_op *k
 	auth_pagecount = PAGECOUNT(caop->auth_src, caop->auth_len);
 	diff = (int)(caop->src - caop->auth_src);
 	if (diff > MAX_SRTP_AUTH_DATA_DIFF || diff < 0) {
-		dprintk(1, KERN_WARNING, "auth_src must overlap with src (diff: %d).\n", diff);
+		dwarning(1, "auth_src must overlap with src (diff: %d).", diff);
 		return -EINVAL;
 	}
 
@@ -144,15 +143,14 @@ static int get_userbuf_srtp(struct csession *ses, struct kernel_crypt_auth_op *k
 
 	rc = adjust_sg_array(ses, pagecount*2); /* double pages to have pages for dst(=auth_src) */
 	if (rc) {
-		dprintk(1, KERN_ERR, "cannot adjust sg array\n");
+		derr(1, "cannot adjust sg array");
 		return rc;
 	}
 
 	rc = __get_userbuf(caop->auth_src, caop->auth_len, 1, auth_pagecount,
 			   ses->pages, ses->sg, kcaop->task, kcaop->mm);
 	if (unlikely(rc)) {
-		dprintk(1, KERN_ERR,
-			"failed to get user pages for data input\n");
+		derr(1, "failed to get user pages for data input");
 		return -EINVAL;
 	}
 
@@ -167,8 +165,7 @@ static int get_userbuf_srtp(struct csession *ses, struct kernel_crypt_auth_op *k
 	(*dst_sg) = sg_advance(*dst_sg, diff);
 	if (*dst_sg == NULL) {
 		release_user_pages(ses);
-		dprintk(1, KERN_ERR,
-			"failed to get enough pages for auth data\n");
+		derr(1, "failed to get enough pages for auth data");
 		return -EINVAL;
 	}
 
@@ -184,14 +181,13 @@ static int fill_kcaop_from_caop(struct kernel_crypt_auth_op *kcaop, struct fcryp
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, caop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", caop->ses);
+		derr(1, "invalid session ID=0x%08X", caop->ses);
 		return -EINVAL;
 	}
 
 	if (caop->flags & COP_FLAG_AEAD_TLS_TYPE || caop->flags & COP_FLAG_AEAD_SRTP_TYPE) {
 		if (caop->src != caop->dst) {
-			dprintk(1, KERN_ERR,
-				"Non-inplace encryption and decryption is not efficient and not implemented\n");
+			derr(1, "Non-inplace encryption and decryption is not efficient and not implemented");
 			ret = -EINVAL;
 			goto out_unlock;
 		}
@@ -213,9 +209,8 @@ static int fill_kcaop_from_caop(struct kernel_crypt_auth_op *kcaop, struct fcryp
 	if (caop->iv) {
 		ret = copy_from_user(kcaop->iv, caop->iv, kcaop->ivlen);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR,
-				"error copying IV (%d bytes), copy_from_user returned %d for address %lx\n",
-				kcaop->ivlen, ret, (unsigned long)caop->iv);
+			derr(1, "error copying IV (%d bytes), copy_from_user returned %d for address %lx",
+					kcaop->ivlen, ret, (unsigned long)caop->iv);
 			ret = -EFAULT;
 			goto out_unlock;
 		}
@@ -239,7 +234,7 @@ static int fill_caop_from_kcaop(struct kernel_crypt_auth_op *kcaop, struct fcryp
 		ret = copy_to_user(kcaop->caop.iv,
 				kcaop->iv, kcaop->ivlen);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR, "Error in copying to userspace\n");
+			derr(1, "Error in copying to userspace");
 			return -EFAULT;
 		}
 	}
@@ -251,7 +246,7 @@ int kcaop_from_user(struct kernel_crypt_auth_op *kcaop,
 			struct fcrypt *fcr, void __user *arg)
 {
 	if (unlikely(copy_from_user(&kcaop->caop, arg, sizeof(kcaop->caop)))) {
-		dprintk(1, KERN_ERR, "Error in copying from userspace\n");
+		derr(1, "Error in copying from userspace");
 		return -EFAULT;
 	}
 
@@ -265,12 +260,12 @@ int kcaop_to_user(struct kernel_crypt_auth_op *kcaop,
 
 	ret = fill_caop_from_kcaop(kcaop, fcr);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_ERR, "fill_caop_from_kcaop\n");
+		derr(1, "fill_caop_from_kcaop");
 		return ret;
 	}
 
 	if (unlikely(copy_to_user(arg, &kcaop->caop, sizeof(kcaop->caop)))) {
-		dprintk(1, KERN_ERR, "Error in copying to userspace\n");
+		derr(1, "Error in copying to userspace");
 		return -EFAULT;
 	}
 	return 0;
@@ -307,7 +302,7 @@ static int verify_tls_record_pad(struct scatterlist *dst_sg, int len, int block_
 	scatterwalk_map_and_copy(&pad_size, dst_sg, len - 1, 1, 0);
 
 	if (pad_size + 1 > len) {
-		dprintk(1, KERN_ERR, "Pad size: %d\n", pad_size);
+		derr(1, "Pad size: %d", pad_size);
 		return -EBADMSG;
 	}
 
@@ -315,7 +310,7 @@ static int verify_tls_record_pad(struct scatterlist *dst_sg, int len, int block_
 
 	for (i = 0; i < pad_size; i++)
 		if (pad[i] != pad_size) {
-			dprintk(1, KERN_ERR, "Pad size: %d, pad: %d\n", pad_size, (int)pad[i]);
+			derr(1, "Pad size: %d, pad: %d", pad_size, (int)pad[i]);
 			return -EBADMSG;
 		}
 
@@ -343,7 +338,7 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 								auth_sg, auth_len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
@@ -352,14 +347,14 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 								dst_sg, len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
 
 			ret = cryptodev_hash_final(&ses_ptr->hdata, hash_output);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_final: %d\n", ret);
+				derr(0, "cryptodev_hash_final: %d", ret);
 				return ret;
 			}
 
@@ -376,7 +371,7 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 			ret = cryptodev_cipher_encrypt(&ses_ptr->cdata,
 							dst_sg, dst_sg, len);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_cipher_encrypt: %d\n", ret);
+				derr(0, "cryptodev_cipher_encrypt: %d", ret);
 				return ret;
 			}
 		}
@@ -386,14 +381,14 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 							dst_sg, dst_sg, len);
 
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_cipher_decrypt: %d\n", ret);
+				derr(0, "cryptodev_cipher_decrypt: %d", ret);
 				return ret;
 			}
 
 			if (ses_ptr->cdata.blocksize > 1) {
 				ret = verify_tls_record_pad(dst_sg, len, ses_ptr->cdata.blocksize);
 				if (unlikely(ret < 0)) {
-					dprintk(2, KERN_ERR, "verify_record_pad: %d\n", ret);
+					derr(2, "verify_record_pad: %d", ret);
 					fail = 1;
 				} else {
 					len -= ret;
@@ -403,7 +398,7 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 
 		if (ses_ptr->hdata.init != 0) {
 			if (unlikely(caop->tag_len > sizeof(vhash) || caop->tag_len > len)) {
-				dprintk(1, KERN_ERR, "Illegal tag len size\n");
+				derr(1, "Illegal tag len size");
 				return -EINVAL;
 			}
 
@@ -414,7 +409,7 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 								auth_sg, auth_len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
@@ -423,19 +418,19 @@ tls_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 									dst_sg, len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
 
 			ret = cryptodev_hash_final(&ses_ptr->hdata, hash_output);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_final: %d\n", ret);
+				derr(0, "cryptodev_hash_final: %d", ret);
 				return ret;
 			}
 
 			if (memcmp(vhash, hash_output, caop->tag_len) != 0 || fail != 0) {
-				dprintk(2, KERN_ERR, "MAC verification failed (tag_len: %d)\n", caop->tag_len);
+				derr(2, "MAC verification failed (tag_len: %d)", caop->tag_len);
 				return -EBADMSG;
 			}
 		}
@@ -464,7 +459,7 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 			ret = cryptodev_cipher_encrypt(&ses_ptr->cdata,
 							dst_sg, dst_sg, len);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_cipher_encrypt: %d\n", ret);
+				derr(0, "cryptodev_cipher_encrypt: %d", ret);
 				return ret;
 			}
 		}
@@ -474,14 +469,14 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 				ret = cryptodev_hash_update(&ses_ptr->hdata,
 								auth_sg, auth_len);
 				if (unlikely(ret)) {
-					dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+					derr(0, "cryptodev_hash_update: %d", ret);
 					return ret;
 				}
 			}
 
 			ret = cryptodev_hash_final(&ses_ptr->hdata, hash_output);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_final: %d\n", ret);
+				derr(0, "cryptodev_hash_final: %d", ret);
 				return ret;
 			}
 
@@ -492,7 +487,7 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 	} else {
 		if (ses_ptr->hdata.init != 0) {
 			if (unlikely(caop->tag_len > sizeof(vhash) || caop->tag_len > len)) {
-				dprintk(1, KERN_ERR, "Illegal tag len size\n");
+				derr(1, "Illegal tag len size");
 				return -EINVAL;
 			}
 
@@ -502,18 +497,18 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 			ret = cryptodev_hash_update(&ses_ptr->hdata,
 							auth_sg, auth_len);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_update: %d\n", ret);
+				derr(0, "cryptodev_hash_update: %d", ret);
 				return ret;
 			}
 
 			ret = cryptodev_hash_final(&ses_ptr->hdata, hash_output);
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_hash_final: %d\n", ret);
+				derr(0, "cryptodev_hash_final: %d", ret);
 				return ret;
 			}
 
 			if (memcmp(vhash, hash_output, caop->tag_len) != 0 || fail != 0) {
-				dprintk(2, KERN_ERR, "MAC verification failed\n");
+				derr(2, "MAC verification failed");
 				return -EBADMSG;
 			}
 		}
@@ -523,7 +518,7 @@ srtp_auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 							dst_sg, dst_sg, len);
 
 			if (unlikely(ret)) {
-				dprintk(0, KERN_ERR, "cryptodev_cipher_decrypt: %d\n", ret);
+				derr(0, "cryptodev_cipher_decrypt: %d", ret);
 				return ret;
 			}
 		}
@@ -548,7 +543,7 @@ auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 
 	max_tag_len = cryptodev_cipher_get_tag_size(&ses_ptr->cdata);
 	if (unlikely(caop->tag_len > max_tag_len)) {
-		dprintk(0, KERN_ERR, "Illegal tag length: %d\n", caop->tag_len);
+		derr(0, "Illegal tag length: %d", caop->tag_len);
 		return -EINVAL;
 	}
 
@@ -563,7 +558,7 @@ auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 		ret = cryptodev_cipher_encrypt(&ses_ptr->cdata,
 						src_sg, dst_sg, len);
 		if (unlikely(ret)) {
-			dprintk(0, KERN_ERR, "cryptodev_cipher_encrypt: %d\n", ret);
+			derr(0, "cryptodev_cipher_encrypt: %d", ret);
 			return ret;
 		}
 		kcaop->dst_len = len + caop->tag_len;
@@ -573,7 +568,7 @@ auth_n_crypt(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcaop,
 						src_sg, dst_sg, len);
 
 		if (unlikely(ret)) {
-			dprintk(0, KERN_ERR, "cryptodev_cipher_decrypt: %d\n", ret);
+			derr(0, "cryptodev_cipher_decrypt: %d", ret);
 			return ret;
 		}
 		kcaop->dst_len = len - caop->tag_len;
@@ -595,13 +590,13 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 		if (unlikely(ses_ptr->cdata.init != 0 &&
 		             (ses_ptr->cdata.stream == 0 ||
 			      ses_ptr->cdata.aead != 0))) {
-			dprintk(0, KERN_ERR, "Only stream modes are allowed in SRTP mode (but not AEAD)\n");
+			derr(0, "Only stream modes are allowed in SRTP mode (but not AEAD)");
 			return -EINVAL;
 		}
 
 		ret = get_userbuf_srtp(ses_ptr, kcaop, &auth_sg, &dst_sg);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR, "get_userbuf_srtp(): Error getting user pages.\n");
+			derr(1, "get_userbuf_srtp(): Error getting user pages.");
 			return ret;
 		}
 
@@ -617,19 +612,19 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 		struct scatterlist tmp;
 
 		if (unlikely(caop->auth_len > PAGE_SIZE)) {
-			dprintk(1, KERN_ERR, "auth data len is excessive.\n");
+			derr(1, "auth data len is excessive.");
 			return -EINVAL;
 		}
 
 		auth_buf = (char *)__get_free_page(GFP_KERNEL);
 		if (unlikely(!auth_buf)) {
-			dprintk(1, KERN_ERR, "unable to get a free page.\n");
+			derr(1, "unable to get a free page.");
 			return -ENOMEM;
 		}
 
 		if (caop->auth_src && caop->auth_len > 0) {
 			if (unlikely(copy_from_user(auth_buf, caop->auth_src, caop->auth_len))) {
-				dprintk(1, KERN_ERR, "unable to copy auth data from userspace.\n");
+				derr(1, "unable to copy auth data from userspace.");
 				ret = -EFAULT;
 				goto free_auth_buf;
 			}
@@ -643,7 +638,7 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 		if (caop->flags & COP_FLAG_AEAD_TLS_TYPE && ses_ptr->cdata.aead == 0) {
 			ret = get_userbuf_tls(ses_ptr, kcaop, &dst_sg);
 			if (unlikely(ret)) {
-				dprintk(1, KERN_ERR, "get_userbuf_tls(): Error getting user pages.\n");
+				derr(1, "get_userbuf_tls(): Error getting user pages.");
 				goto free_auth_buf;
 			}
 
@@ -655,7 +650,7 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 			if (unlikely(ses_ptr->cdata.init == 0 ||
 			             (ses_ptr->cdata.stream == 0 &&
 				      ses_ptr->cdata.aead == 0))) {
-				dprintk(0, KERN_ERR, "Only stream and AEAD ciphers are allowed for authenc\n");
+				derr(0, "Only stream and AEAD ciphers are allowed for authenc");
 				ret = -EINVAL;
 				goto free_auth_buf;
 			}
@@ -668,7 +663,7 @@ __crypto_auth_run_zc(struct csession *ses_ptr, struct kernel_crypt_auth_op *kcao
 			ret = get_userbuf(ses_ptr, caop->src, caop->len, caop->dst, dst_len,
 					  kcaop->task, kcaop->mm, &src_sg, &dst_sg);
 			if (unlikely(ret)) {
-				dprintk(1, KERN_ERR, "get_userbuf(): Error getting user pages.\n");
+				derr(1, "get_userbuf(): Error getting user pages.");
 				goto free_auth_buf;
 			}
 
@@ -693,19 +688,19 @@ int crypto_auth_run(struct fcrypt *fcr, struct kernel_crypt_auth_op *kcaop)
 	int ret;
 
 	if (unlikely(caop->op != COP_ENCRYPT && caop->op != COP_DECRYPT)) {
-		dprintk(1, KERN_DEBUG, "invalid operation op=%u\n", caop->op);
+		ddebug(1, "invalid operation op=%u", caop->op);
 		return -EINVAL;
 	}
 
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, caop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", caop->ses);
+		derr(1, "invalid session ID=0x%08X", caop->ses);
 		return -EINVAL;
 	}
 
 	if (unlikely(ses_ptr->cdata.init == 0)) {
-		dprintk(1, KERN_ERR, "cipher context not initialized\n");
+		derr(1, "cipher context not initialized");
 		ret = -EINVAL;
 		goto out_unlock;
 	}
@@ -714,8 +709,7 @@ int crypto_auth_run(struct fcrypt *fcr, struct kernel_crypt_auth_op *kcaop)
 	if (ses_ptr->hdata.init != 0) {
 		ret = cryptodev_hash_reset(&ses_ptr->hdata);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR,
-				"error in cryptodev_hash_reset()\n");
+			derr(1, "error in cryptodev_hash_reset()");
 			goto out_unlock;
 		}
 	}
@@ -725,8 +719,7 @@ int crypto_auth_run(struct fcrypt *fcr, struct kernel_crypt_auth_op *kcaop)
 
 	ret = __crypto_auth_run_zc(ses_ptr, kcaop);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_ERR,
-			"error in __crypto_auth_run_zc()\n");
+		derr(1, "error in __crypto_auth_run_zc()");
 		goto out_unlock;
 	}
 
diff --git a/drivers/staging/crypto/cryptodev/cryptlib.c b/drivers/staging/crypto/cryptodev/cryptlib.c
index d9f17ee02466..a7fbff412822 100644
--- a/drivers/staging/crypto/cryptodev/cryptlib.c
+++ b/drivers/staging/crypto/cryptodev/cryptlib.c
@@ -63,7 +63,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 
 		out->async.s = crypto_alloc_ablkcipher(alg_name, 0, 0);
 		if (unlikely(IS_ERR(out->async.s))) {
-			dprintk(1, KERN_DEBUG, "Failed to load cipher %s\n", alg_name);
+			ddebug(1, "Failed to load cipher %s", alg_name);
 				return -EINVAL;
 		}
 
@@ -73,11 +73,8 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 			if (alg->max_keysize > 0 &&
 					unlikely((keylen < alg->min_keysize) ||
 					(keylen > alg->max_keysize))) {
-				dprintk(1, KERN_DEBUG,
-					"Wrong keylen '%zu' for algorithm '%s'. \
-					Use %u to %u.\n",
-					   keylen, alg_name, alg->min_keysize,
-					   alg->max_keysize);
+				ddebug(1, "Wrong keylen '%zu' for algorithm '%s'. Use %u to %u.",
+						keylen, alg_name, alg->min_keysize, alg->max_keysize);
 				ret = -EINVAL;
 				goto error;
 			}
@@ -91,7 +88,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 	} else {
 		out->async.as = crypto_alloc_aead(alg_name, 0, 0);
 		if (unlikely(IS_ERR(out->async.as))) {
-			dprintk(1, KERN_DEBUG, "Failed to load cipher %s\n", alg_name);
+			ddebug(1, "Failed to load cipher %s", alg_name);
 			return -EINVAL;
 		}
 
@@ -103,8 +100,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 	}
 
 	if (unlikely(ret)) {
-		dprintk(1, KERN_DEBUG, "Setting key failed for %s-%zu.\n",
-			alg_name, keylen*8);
+		ddebug(1, "Setting key failed for %s-%zu.", alg_name, keylen*8);
 		ret = -EINVAL;
 		goto error;
 	}
@@ -123,7 +119,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 	if (aead == 0) {
 		out->async.request = ablkcipher_request_alloc(out->async.s, GFP_KERNEL);
 		if (unlikely(!out->async.request)) {
-			dprintk(1, KERN_ERR, "error allocating async crypto request\n");
+			derr(1, "error allocating async crypto request");
 			ret = -ENOMEM;
 			goto error;
 		}
@@ -134,7 +130,7 @@ int cryptodev_cipher_init(struct cipher_data *out, const char *alg_name,
 	} else {
 		out->async.arequest = aead_request_alloc(out->async.as, GFP_KERNEL);
 		if (unlikely(!out->async.arequest)) {
-			dprintk(1, KERN_ERR, "error allocating async crypto request\n");
+			derr(1, "error allocating async crypto request");
 			ret = -ENOMEM;
 			goto error;
 		}
@@ -198,8 +194,7 @@ static inline int waitfor(struct cryptodev_result *cr, ssize_t ret)
 		 * another request. */
 
 		if (unlikely(cr->err)) {
-			dprintk(0, KERN_ERR, "error from async request: %d\n",
-				cr->err);
+			derr(0, "error from async request: %d", cr->err);
 			return cr->err;
 		}
 
@@ -265,7 +260,7 @@ int cryptodev_hash_init(struct hash_data *hdata, const char *alg_name,
 
 	hdata->async.s = crypto_alloc_ahash(alg_name, 0, 0);
 	if (unlikely(IS_ERR(hdata->async.s))) {
-		dprintk(1, KERN_DEBUG, "Failed to load transform for %s\n", alg_name);
+		ddebug(1, "Failed to load transform for %s", alg_name);
 		return -EINVAL;
 	}
 
@@ -273,9 +268,8 @@ int cryptodev_hash_init(struct hash_data *hdata, const char *alg_name,
 	if (hmac_mode != 0) {
 		ret = crypto_ahash_setkey(hdata->async.s, mackey, mackeylen);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_DEBUG,
-				"Setting hmac key failed for %s-%zu.\n",
-				alg_name, mackeylen*8);
+			ddebug(1, "Setting hmac key failed for %s-%zu.",
+					alg_name, mackeylen*8);
 			ret = -EINVAL;
 			goto error;
 		}
@@ -294,7 +288,7 @@ int cryptodev_hash_init(struct hash_data *hdata, const char *alg_name,
 
 	hdata->async.request = ahash_request_alloc(hdata->async.s, GFP_KERNEL);
 	if (unlikely(!hdata->async.request)) {
-		dprintk(0, KERN_ERR, "error allocating async crypto request\n");
+		derr(0, "error allocating async crypto request");
 		ret = -ENOMEM;
 		goto error;
 	}
@@ -305,7 +299,7 @@ int cryptodev_hash_init(struct hash_data *hdata, const char *alg_name,
 
 	ret = crypto_ahash_init(hdata->async.request);
 	if (unlikely(ret)) {
-		dprintk(0, KERN_ERR, "error in crypto_hash_init()\n");
+		derr(0, "error in crypto_hash_init()");
 		goto error_request;
 	}
 
@@ -338,7 +332,7 @@ int cryptodev_hash_reset(struct hash_data *hdata)
 
 	ret = crypto_ahash_init(hdata->async.request);
 	if (unlikely(ret)) {
-		dprintk(0, KERN_ERR, "error in crypto_hash_init()\n");
+		derr(0, "error in crypto_hash_init()");
 		return ret;
 	}
 
diff --git a/drivers/staging/crypto/cryptodev/cryptodev_int.h b/drivers/staging/crypto/cryptodev/cryptodev_int.h
index 781f9b9b1f23..d7660fac5344 100644
--- a/drivers/staging/crypto/cryptodev/cryptodev_int.h
+++ b/drivers/staging/crypto/cryptodev/cryptodev_int.h
@@ -24,11 +24,16 @@
 #define dprintk(level, severity, format, a...)			\
 	do {							\
 		if (level <= cryptodev_verbosity)		\
-			printk(severity PFX "%s[%u] (%s:%u): " format,	\
+			printk(severity PFX "%s[%u] (%s:%u): " format "\n",	\
 			       current->comm, current->pid,	\
 			       __func__, __LINE__,		\
 			       ##a);				\
 	} while (0)
+#define derr(level, format, a...) dprintk(level, KERN_ERR, format, ##a)
+#define dwarning(level, format, a...) dprintk(level, KERN_WARNING, format, ##a)
+#define dinfo(level, format, a...) dprintk(level, KERN_INFO, format, ##a)
+#define ddebug(level, format, a...) dprintk(level, KERN_DEBUG, format, ##a)
+
 
 extern int cryptodev_verbosity;
 
diff --git a/drivers/staging/crypto/cryptodev/ioctl.c b/drivers/staging/crypto/cryptodev/ioctl.c
index ba97b48ce2a2..0bdaef505a9d 100644
--- a/drivers/staging/crypto/cryptodev/ioctl.c
+++ b/drivers/staging/crypto/cryptodev/ioctl.c
@@ -112,7 +112,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 
 	/* Does the request make sense? */
 	if (unlikely(!sop->cipher && !sop->mac)) {
-		dprintk(1, KERN_DEBUG, "Both 'cipher' and 'mac' unset.\n");
+		ddebug(1, "Both 'cipher' and 'mac' unset.");
 		return -EINVAL;
 	}
 
@@ -151,7 +151,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		stream = 1;
 		break;
 	default:
-		dprintk(1, KERN_DEBUG, "bad cipher: %d\n", sop->cipher);
+		ddebug(1, "bad cipher: %d", sop->cipher);
 		return -EINVAL;
 	}
 
@@ -211,7 +211,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		hmac_mode = 0;
 		break;
 	default:
-		dprintk(1, KERN_DEBUG, "bad mac: %d\n", sop->mac);
+		ddebug(1, "bad mac: %d", sop->mac);
 		return -EINVAL;
 	}
 
@@ -225,8 +225,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		uint8_t keyp[CRYPTO_CIPHER_MAX_KEY_LEN];
 
 		if (unlikely(sop->keylen > CRYPTO_CIPHER_MAX_KEY_LEN)) {
-			dprintk(1, KERN_DEBUG,
-				"Setting key failed for %s-%zu.\n",
+			ddebug(1, "Setting key failed for %s-%zu.",
 				alg_name, (size_t)sop->keylen*8);
 			ret = -EINVAL;
 			goto error_cipher;
@@ -240,8 +239,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		ret = cryptodev_cipher_init(&ses_new->cdata, alg_name, keyp,
 						sop->keylen, stream, aead);
 		if (ret < 0) {
-			dprintk(1, KERN_DEBUG,
-				"Failed to load cipher for %s\n", alg_name);
+			ddebug(1, "Failed to load cipher for %s", alg_name);
 			ret = -EINVAL;
 			goto error_cipher;
 		}
@@ -251,8 +249,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		uint8_t keyp[CRYPTO_HMAC_MAX_KEY_LEN];
 
 		if (unlikely(sop->mackeylen > CRYPTO_HMAC_MAX_KEY_LEN)) {
-			dprintk(1, KERN_DEBUG,
-				"Setting key failed for %s-%zu.\n",
+			ddebug(1, "Setting key failed for %s-%zu.",
 				hash_name, (size_t)sop->mackeylen*8);
 			ret = -EINVAL;
 			goto error_hash;
@@ -267,7 +264,7 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 		ret = cryptodev_hash_init(&ses_new->hdata, hash_name, hmac_mode,
 							keyp, sop->mackeylen);
 		if (ret != 0) {
-			dprintk(1, KERN_DEBUG, "Failed to load hash for %s\n", hash_name);
+			ddebug(1, "Failed to load hash for %s", hash_name);
 			ret = -EINVAL;
 			goto error_hash;
 		}
@@ -275,17 +272,16 @@ crypto_create_session(struct fcrypt *fcr, struct session_op *sop)
 
 	ses_new->alignmask = max(ses_new->cdata.alignmask,
 	                                          ses_new->hdata.alignmask);
-	dprintk(2, KERN_DEBUG, "got alignmask %d\n", ses_new->alignmask);
+	ddebug(2, "got alignmask %d", ses_new->alignmask);
 
 	ses_new->array_size = DEFAULT_PREALLOC_PAGES;
-	dprintk(2, KERN_DEBUG, "preallocating for %d user pages\n",
-			ses_new->array_size);
+	ddebug(2, "preallocating for %d user pages", ses_new->array_size);
 	ses_new->pages = kzalloc(ses_new->array_size *
 			sizeof(struct page *), GFP_KERNEL);
 	ses_new->sg = kzalloc(ses_new->array_size *
 			sizeof(struct scatterlist), GFP_KERNEL);
 	if (ses_new->sg == NULL || ses_new->pages == NULL) {
-		dprintk(0, KERN_DEBUG, "Memory error\n");
+		ddebug(0, "Memory error");
 		ret = -ENOMEM;
 		goto error_hash;
 	}
@@ -330,15 +326,13 @@ static inline void
 crypto_destroy_session(struct csession *ses_ptr)
 {
 	if (!mutex_trylock(&ses_ptr->sem)) {
-		dprintk(2, KERN_DEBUG, "Waiting for semaphore of sid=0x%08X\n",
-			ses_ptr->sid);
+		ddebug(2, "Waiting for semaphore of sid=0x%08X", ses_ptr->sid);
 		mutex_lock(&ses_ptr->sem);
 	}
-	dprintk(2, KERN_DEBUG, "Removed session 0x%08X\n", ses_ptr->sid);
+	ddebug(2, "Removed session 0x%08X", ses_ptr->sid);
 	cryptodev_cipher_deinit(&ses_ptr->cdata);
 	cryptodev_hash_deinit(&ses_ptr->hdata);
-	dprintk(2, KERN_DEBUG, "freeing space for %d user pages\n",
-			ses_ptr->array_size);
+	ddebug(2, "freeing space for %d user pages", ses_ptr->array_size);
 	kfree(ses_ptr->pages);
 	kfree(ses_ptr->sg);
 	mutex_unlock(&ses_ptr->sem);
@@ -365,8 +359,7 @@ crypto_finish_session(struct fcrypt *fcr, uint32_t sid)
 	}
 
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "Session with sid=0x%08X not found!\n",
-			sid);
+		derr(1, "Session with sid=0x%08X not found!", sid);
 		ret = -ENOENT;
 	}
 	mutex_unlock(&fcr->sem);
@@ -430,8 +423,7 @@ static void cryptask_routine(struct work_struct *work)
 	list_for_each_entry(item, &tmp, __hook) {
 		item->result = crypto_run(&pcr->fcrypt, &item->kcop);
 		if (unlikely(item->result))
-			dprintk(0, KERN_ERR, "crypto_run() failed: %d\n",
-					item->result);
+			derr(0, "crypto_run() failed: %d", item->result);
 	}
 
 	/* push all handled jobs to the done list at once */
@@ -476,14 +468,12 @@ cryptodev_open(struct inode *inode, struct file *filp)
 		if (!tmp)
 			return -ENOMEM;
 		pcr->itemcount++;
-		dprintk(2, KERN_DEBUG, "allocated new item at %lx\n",
-				(unsigned long)tmp);
+		ddebug(2, "allocated new item at %lx", (unsigned long)tmp);
 		list_add(&tmp->__hook, &pcr->free.list);
 	}
 
-	dprintk(2, KERN_DEBUG,
-	        "Cryptodev handle initialised, %d elements in queue\n",
-		DEF_COP_RINGSIZE);
+	ddebug(2, "Cryptodev handle initialised, %d elements in queue",
+			DEF_COP_RINGSIZE);
 	return 0;
 }
 
@@ -503,17 +493,15 @@ cryptodev_release(struct inode *inode, struct file *filp)
 	list_splice_tail(&pcr->done.list, &pcr->free.list);
 
 	list_for_each_entry_safe(item, item_safe, &pcr->free.list, __hook) {
-		dprintk(2, KERN_DEBUG, "freeing item at %lx\n",
-				(unsigned long)item);
+		ddebug(2, "freeing item at %lx", (unsigned long)item);
 		list_del(&item->__hook);
 		kfree(item);
 		items_freed++;
 	}
 
 	if (items_freed != pcr->itemcount) {
-		dprintk(0, KERN_ERR,
-		        "freed %d items, but %d should exist!\n",
-		        items_freed, pcr->itemcount);
+		derr(0, "freed %d items, but %d should exist!",
+				items_freed, pcr->itemcount);
 	}
 
 	crypto_finish_all_sessions(&pcr->fcrypt);
@@ -526,9 +514,8 @@ cryptodev_release(struct inode *inode, struct file *filp)
 	kfree(pcr);
 	filp->private_data = NULL;
 
-	dprintk(2, KERN_DEBUG,
-	        "Cryptodev handle deinitialised, %d elements freed\n",
-	        items_freed);
+	ddebug(2, "Cryptodev handle deinitialised, %d elements freed",
+			items_freed);
 	return 0;
 }
 
@@ -577,8 +564,7 @@ static int crypto_async_run(struct crypt_priv *pcr, struct kernel_crypt_op *kcop
 		item = kzalloc(sizeof(struct todo_list_item), GFP_KERNEL);
 		if (unlikely(!item))
 			return -EFAULT;
-		dprintk(1, KERN_INFO, "increased item count to %d\n",
-				pcr->itemcount);
+		dinfo(1, "increased item count to %d", pcr->itemcount);
 	}
 
 	memcpy(&item->kcop, kcop, sizeof(struct kernel_crypt_op));
@@ -635,7 +621,7 @@ static int fill_kcop_from_cop(struct kernel_crypt_op *kcop, struct fcrypt *fcr)
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, cop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", cop->ses);
+		derr(1, "invalid session ID=0x%08X", cop->ses);
 		return -EINVAL;
 	}
 	kcop->ivlen = cop->iv ? ses_ptr->cdata.ivsize : 0;
@@ -649,9 +635,8 @@ static int fill_kcop_from_cop(struct kernel_crypt_op *kcop, struct fcrypt *fcr)
 	if (cop->iv) {
 		rc = copy_from_user(kcop->iv, cop->iv, kcop->ivlen);
 		if (unlikely(rc)) {
-			dprintk(1, KERN_ERR,
-				"error copying IV (%d bytes), copy_from_user returned %d for address %lx\n",
-				kcop->ivlen, rc, (unsigned long)cop->iv);
+			derr(1, "error copying IV (%d bytes), copy_from_user returned %d for address %lx",
+					kcop->ivlen, rc, (unsigned long)cop->iv);
 			return -EFAULT;
 		}
 	}
@@ -695,12 +680,12 @@ static int kcop_to_user(struct kernel_crypt_op *kcop,
 
 	ret = fill_cop_from_kcop(kcop, fcr);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_ERR, "Error in fill_cop_from_kcop\n");
+		derr(1, "Error in fill_cop_from_kcop");
 		return ret;
 	}
 
 	if (unlikely(copy_to_user(arg, &kcop->cop, sizeof(kcop->cop)))) {
-		dprintk(1, KERN_ERR, "Cannot copy to userspace\n");
+		derr(1, "Cannot copy to userspace");
 		return -EFAULT;
 	}
 	return 0;
@@ -749,7 +734,7 @@ static int get_session_info(struct fcrypt *fcr, struct session_info_op *siop)
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, siop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", siop->ses);
+		derr(1, "invalid session ID=0x%08X", siop->ses);
 		return -EINVAL;
 	}
 
@@ -846,26 +831,26 @@ cryptodev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg_)
 		return copy_to_user(arg, &siop, sizeof(siop));
 	case CIOCCRYPT:
 		if (unlikely(ret = kcop_from_user(&kcop, fcr, arg))) {
-			dprintk(1, KERN_WARNING, "Error copying from user\n");
+			dwarning(1, "Error copying from user");
 			return ret;
 		}
 
 		ret = crypto_run(fcr, &kcop);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_WARNING, "Error in crypto_run\n");
+			dwarning(1, "Error in crypto_run");
 			return ret;
 		}
 
 		return kcop_to_user(&kcop, fcr, arg);
 	case CIOCAUTHCRYPT:
 		if (unlikely(ret = kcaop_from_user(&kcaop, fcr, arg))) {
-			dprintk(1, KERN_WARNING, "Error copying from user\n");
+			dwarning(1, "Error copying from user");
 			return ret;
 		}
 
 		ret = crypto_auth_run(fcr, &kcaop);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_WARNING, "Error in crypto_auth_run\n");
+			dwarning(1, "Error in crypto_auth_run");
 			return ret;
 		}
 		return kcaop_to_user(&kcaop, fcr, arg);
@@ -964,13 +949,13 @@ static int compat_kcop_to_user(struct kernel_crypt_op *kcop,
 
 	ret = fill_cop_from_kcop(kcop, fcr);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_WARNING, "Error in fill_cop_from_kcop\n");
+		dwarning(1, "Error in fill_cop_from_kcop");
 		return ret;
 	}
 	crypt_op_to_compat(&kcop->cop, &compat_cop);
 
 	if (unlikely(copy_to_user(arg, &compat_cop, sizeof(compat_cop)))) {
-		dprintk(1, KERN_WARNING, "Error copying to user\n");
+		dwarning(1, "Error copying to user");
 		return -EFAULT;
 	}
 	return 0;
diff --git a/drivers/staging/crypto/cryptodev/main.c b/drivers/staging/crypto/cryptodev/main.c
index a25b2c6a44d1..6ce0efe37ff7 100644
--- a/drivers/staging/crypto/cryptodev/main.c
+++ b/drivers/staging/crypto/cryptodev/main.c
@@ -95,7 +95,7 @@ hash_n_crypt(struct csession *ses_ptr, struct crypt_op *cop,
 	}
 	return 0;
 out_err:
-	dprintk(0, KERN_ERR, "CryptoAPI failure: %d\n", ret);
+	derr(0, "CryptoAPI failure: %d", ret);
 	return ret;
 }
 
@@ -114,7 +114,7 @@ __crypto_run_std(struct csession *ses_ptr, struct crypt_op *cop)
 	data = (char *)__get_free_page(GFP_KERNEL);
 
 	if (unlikely(!data)) {
-		dprintk(1, KERN_ERR, "Error getting free page.\n");
+		derr(1, "Error getting free page.");
 		return -ENOMEM;
 	}
 
@@ -127,7 +127,7 @@ __crypto_run_std(struct csession *ses_ptr, struct crypt_op *cop)
 		size_t current_len = nbytes > bufsize ? bufsize : nbytes;
 
 		if (unlikely(copy_from_user(data, src, current_len))) {
-		        dprintk(1, KERN_ERR, "Error copying %d bytes from user address %p.\n", (int)current_len, src);
+		        derr(1, "Error copying %d bytes from user address %p.", (int)current_len, src);
 			ret = -EFAULT;
 			break;
 		}
@@ -137,13 +137,13 @@ __crypto_run_std(struct csession *ses_ptr, struct crypt_op *cop)
 		ret = hash_n_crypt(ses_ptr, cop, &sg, &sg, current_len);
 
 		if (unlikely(ret)) {
-		        dprintk(1, KERN_ERR, "hash_n_crypt failed.\n");
+		        derr(1, "hash_n_crypt failed.");
 			break;
 		}
 
 		if (ses_ptr->cdata.init != 0) {
 			if (unlikely(copy_to_user(dst, data, current_len))) {
-			        dprintk(1, KERN_ERR, "could not copy to user.\n");
+			        derr(1, "could not copy to user.");
 				ret = -EFAULT;
 				break;
 			}
@@ -171,8 +171,7 @@ __crypto_run_zc(struct csession *ses_ptr, struct kernel_crypt_op *kcop)
 	ret = get_userbuf(ses_ptr, cop->src, cop->len, cop->dst, cop->len,
 	                  kcop->task, kcop->mm, &src_sg, &dst_sg);
 	if (unlikely(ret)) {
-		dprintk(1, KERN_ERR, "Error getting user pages. "
-					"Falling back to non zero copy.\n");
+		derr(1, "Error getting user pages. Falling back to non zero copy.");
 		return __crypto_run_std(ses_ptr, cop);
 	}
 
@@ -189,22 +188,21 @@ int crypto_run(struct fcrypt *fcr, struct kernel_crypt_op *kcop)
 	int ret;
 
 	if (unlikely(cop->op != COP_ENCRYPT && cop->op != COP_DECRYPT)) {
-		dprintk(1, KERN_DEBUG, "invalid operation op=%u\n", cop->op);
+		ddebug(1, "invalid operation op=%u", cop->op);
 		return -EINVAL;
 	}
 
 	/* this also enters ses_ptr->sem */
 	ses_ptr = crypto_get_session_by_sid(fcr, cop->ses);
 	if (unlikely(!ses_ptr)) {
-		dprintk(1, KERN_ERR, "invalid session ID=0x%08X\n", cop->ses);
+		derr(1, "invalid session ID=0x%08X", cop->ses);
 		return -EINVAL;
 	}
 
 	if (ses_ptr->hdata.init != 0 && (cop->flags == 0 || cop->flags & COP_FLAG_RESET)) {
 		ret = cryptodev_hash_reset(&ses_ptr->hdata);
 		if (unlikely(ret)) {
-			dprintk(1, KERN_ERR,
-				"error in cryptodev_hash_reset()\n");
+			derr(1, "error in cryptodev_hash_reset()");
 			goto out_unlock;
 		}
 	}
@@ -213,9 +211,7 @@ int crypto_run(struct fcrypt *fcr, struct kernel_crypt_op *kcop)
 		int blocksize = ses_ptr->cdata.blocksize;
 
 		if (unlikely(cop->len % blocksize)) {
-			dprintk(1, KERN_ERR,
-				"data size (%u) isn't a multiple "
-				"of block size (%u)\n",
+			derr(1, "data size (%u) isn't a multiple of block size (%u)",
 				cop->len, blocksize);
 			ret = -EINVAL;
 			goto out_unlock;
@@ -228,13 +224,13 @@ int crypto_run(struct fcrypt *fcr, struct kernel_crypt_op *kcop)
 	if (likely(cop->len)) {
 		if (cop->flags & COP_FLAG_NO_ZC) {
 			if (unlikely(ses_ptr->alignmask && !IS_ALIGNED((unsigned long)cop->src, ses_ptr->alignmask))) {
-				dprintk(2, KERN_WARNING, "source address %lx is not %d byte aligned - disabling zero copy\n",
+				dwarning(2, "source address %lx is not %d byte aligned - disabling zero copy",
 						(unsigned long)cop->src, ses_ptr->alignmask + 1);
 				cop->flags &= ~COP_FLAG_NO_ZC;
 			}
 
 			if (unlikely(ses_ptr->alignmask && !IS_ALIGNED((unsigned long)cop->dst, ses_ptr->alignmask))) {
-				dprintk(2, KERN_WARNING, "destination address %lx is not %d byte aligned - disabling zero copy\n",
+				dwarning(2, "destination address %lx is not %d byte aligned - disabling zero copy",
 						(unsigned long)cop->dst, ses_ptr->alignmask + 1);
 				cop->flags &= ~COP_FLAG_NO_ZC;
 			}
@@ -259,7 +255,7 @@ int crypto_run(struct fcrypt *fcr, struct kernel_crypt_op *kcop)
 
 		ret = cryptodev_hash_final(&ses_ptr->hdata, kcop->hash_output);
 		if (unlikely(ret)) {
-			dprintk(0, KERN_ERR, "CryptoAPI failure: %d\n", ret);
+			derr(0, "CryptoAPI failure: %d", ret);
 			goto out_unlock;
 		}
 		kcop->digestsize = ses_ptr->hdata.digestsize;
diff --git a/drivers/staging/crypto/cryptodev/zc.c b/drivers/staging/crypto/cryptodev/zc.c
index 3b986e7a3863..809a36d7ce98 100644
--- a/drivers/staging/crypto/cryptodev/zc.c
+++ b/drivers/staging/crypto/cryptodev/zc.c
@@ -89,7 +89,7 @@ int adjust_sg_array(struct csession *ses, int pagecount)
 	for (array_size = ses->array_size; array_size < pagecount;
 	     array_size *= 2)
 		;
-	dprintk(0, KERN_DEBUG, "reallocating from %d to %d pages\n",
+	ddebug(0, "reallocating from %d to %d pages",
 			ses->array_size, array_size);
 	pages = krealloc(ses->pages, array_size * sizeof(struct page *),
 			 GFP_KERNEL);
@@ -165,8 +165,7 @@ int get_userbuf(struct csession *ses,
 		rc = __get_userbuf(src, src_len, 1, ses->used_pages,
 			               ses->pages, ses->sg, task, mm);
 		if (unlikely(rc)) {
-			dprintk(1, KERN_ERR,
-				"failed to get user pages for data IO\n");
+			derr(1, "failed to get user pages for data IO");
 			return rc;
 		}
 		(*src_sg) = (*dst_sg) = ses->sg;
@@ -180,8 +179,7 @@ int get_userbuf(struct csession *ses,
 		rc = __get_userbuf(src, src_len, 0, ses->readonly_pages,
 					   ses->pages, ses->sg, task, mm);
 		if (unlikely(rc)) {
-			dprintk(1, KERN_ERR,
-				"failed to get user pages for data input\n");
+			derr(1, "failed to get user pages for data input");
 			return rc;
 		}
 		*src_sg = ses->sg;
@@ -196,8 +194,7 @@ int get_userbuf(struct csession *ses,
 		rc = __get_userbuf(dst, dst_len, 1, writable_pages,
 					   dst_pages, *dst_sg, task, mm);
 		if (unlikely(rc)) {
-			dprintk(1, KERN_ERR,
-					"failed to get user pages for data output\n");
+			derr(1, "failed to get user pages for data output");
 			release_user_pages(ses);  /* FIXME: use __release_userbuf(src, ...) */
 			return rc;
 		}
-- 
1.8.1.2

