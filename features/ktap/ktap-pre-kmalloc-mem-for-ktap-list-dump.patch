From f834c5c639733d23849db2d8491ac51db86612fa Mon Sep 17 00:00:00 2001
From: huanhuan Wang <huanhuan.Wang@windriver.com>
Date: Wed, 29 Oct 2014 09:34:15 +0800
Subject: [PATCH] ktap: pre-kmalloc mem for ktap list dump

In preempt-rt kernel, there is the following kernel bug
when execute "ktap samples/mem/kmalloc-stack.kp":

BUG: sleeping function called from invalid context at linux/kernel/locking/rtmutex.c:905
in_atomic(): 1, irqs_disabled(): 0, pid: 136, name: ksoftirqd/17
INFO: lockdep is turned off.
Preemption disabled at:[<ffffffff8107ec62>] run_hrtimer_softirq+0x42/0x1e0

CPU: 17 PID: 136 Comm: ksoftirqd/17 Tainted: G C O 3.14.22-rt9-WR7.0.0.0_preempt-rt #1
Hardware name: Intel Corporation S2600CP/S2600CP, BIOS RMLSDP.86I.R4.26.D674.1304190022 04/19/2013
 ffffffff81ec5740 ffff880fc4833718 ffffffff81a5f28e 0000000000000000
 ffff880fc4833740 ffffffff81087397 ffff88101eeb0380 ffff88103fffbe00
 0000000000010380 ffff880fc4833760 ffffffff81a66be4 ffff88103fffbe00
Call Trace:
 [<ffffffff81a5f28e>] dump_stack+0x4e/0x7a
 [<ffffffff81087397>] __might_sleep+0x147/0x240
 [<ffffffff81a66be4>] rt_spin_lock+0x24/0x80
 [<ffffffff8114409e>] get_page_from_freelist+0x5ae/0xb20
 [<ffffffff81145b1e>] __alloc_pages_nodemask+0x4ae/0xdf0
 [<ffffffff8118a365>] ? alloc_pages_current+0x125/0x1d0
 [<ffffffff8118a345>] alloc_pages_current+0x105/0x1d0
 [<ffffffff8114077e>] ? __get_free_pages+0xe/0x50
 [<ffffffff8114077e>] __get_free_pages+0xe/0x50
 [<ffffffff811623d3>] kmalloc_order_trace+0x33/0x180
 [<ffffffff81197109>] __kmalloc+0x1e9/0x3c0
 [<ffffffffa00bad85>] tab_histdump+0x55/0x420 [ktapvm]
 [<ffffffff81098b1b>] ? find_busiest_group+0x11b/0x870
 [<ffffffffa00bc783>] kp_tab_print_hist+0x43/0x50 [ktapvm]
 [<ffffffffa00c2030>] kplib_print_hist+0x60/0xc0 [ktapvm]
 [<ffffffffa00be6e5>] kp_vm_call+0x1be5/0x1f10 [ktapvm]
 [<ffffffff81a668fc>] ? _raw_spin_unlock_irq+0x2c/0x60
 [<ffffffffa00c25a0>] ? kp_lib_init_kdebug+0x20/0x20 [ktapvm]
 [<ffffffffa00c265c>] hrtimer_ktap_fn+0xbc/0x140 [ktapvm]
 [<ffffffff8107ecd5>] run_hrtimer_softirq+0xb5/0x1e0
 [<ffffffff81052cbe>] do_current_softirqs+0x26e/0x600
 [<ffffffff810a75df>] ? trace_hardirqs_off_caller+0x1f/0x150
 [<ffffffff810532ac>] run_ksoftirqd+0x2c/0x50
 [<ffffffff8108356d>] smpboot_thread_fn+0x18d/0x2d0
 [<ffffffff81a64010>] ? schedule+0x30/0xa0
 [<ffffffff810833e0>] ? SyS_setgroups+0x190/0x190
 [<ffffffff8107ab38>] kthread+0xe8/0x100
 [<ffffffff8107aa50>] ? flush_kthread_work+0x1d0/0x1d0
 [<ffffffff81a6fe2c>] ret_from_fork+0x7c/0xb0
 [<ffffffff8107aa50>] ? flush_kthread_work+0x1d0/0x1d0
                         value ------------- Distribution ------------- count

The reason for that is the preempt will be disabled by softirq scheme and the
following call:
  hrtimer_ktap_fn
  +--rcu_read_lock_sched_notrace
     +--preempt_disable_notrace
and then kmalloc/rt_spin_lock will be called for entry dump, then in
rt_spin_lock:
  rt_spin_lock
  +--rt_spin_lock_fastlock
     +--might_sleep
        +--__might_sleep
will check the preempt state and complain about it.

Fix it by moving the kmalloc to the time when the ktab structure is created,
and the pre-allocated memory for list dump use can only hold
KTAB_MAX_DUMP_ENTRY_NUM entries as this is the max number of entries to be
dumped when tab_histdump is called.

Signed-off-by: huanhuan Wang <huanhuan.Wang@windriver.com>
---
 include/uapi/ktap/ktap_types.h |    6 ++++++
 kernel/trace/ktap/kp_tab.c     |   21 ++++++++++-----------
 kernel/trace/ktap/ktap.h       |    5 +++++
 kernel/trace/ktap/lib_base.c   |    3 +--
 4 files changed, 22 insertions(+), 13 deletions(-)

diff --git a/include/uapi/ktap/ktap_types.h b/include/uapi/ktap/ktap_types.h
index f477ac7..332c659 100644
--- a/include/uapi/ktap/ktap_types.h
+++ b/include/uapi/ktap/ktap_types.h
@@ -206,6 +206,11 @@ typedef struct ktap_node_t {
 	struct ktap_node_t *next;  /* hash chain */
 } ktap_node_t;
 
+typedef struct ktap_node2 {
+	ktap_val_t key;
+	ktap_val_t val;
+} ktap_node2_t;
+
 /* ktap_tab */
 typedef struct ktap_tab {
 	GCHeader;
@@ -215,6 +220,7 @@ typedef struct ktap_tab {
 	ktap_val_t *array;    /* Array part. */
 	ktap_node_t *node;    /* Hash part. */
 	ktap_node_t *freetop; /* any free position is before this position */
+	ktap_node2_t *sort_mem;
 
 	uint32_t asize;		/* Size of array part (keys [0, asize-1]). */
 	uint32_t hmask;		/* log2 of size of `node' array */
diff --git a/kernel/trace/ktap/kp_tab.c b/kernel/trace/ktap/kp_tab.c
index 79e3ce7..766a04d 100644
--- a/kernel/trace/ktap/kp_tab.c
+++ b/kernel/trace/ktap/kp_tab.c
@@ -158,6 +158,7 @@ static ktap_tab_t *newtab(ktap_state_t *ks, uint32_t asize, uint32_t hbits)
 	t->array = NULL;
 	t->asize = 0;  /* In case the array allocation fails. */
 	t->hmask = 0;
+	t->sort_mem = NULL;
 
 	tab_lock_init(t);
 
@@ -177,6 +178,9 @@ static ktap_tab_t *newtab(ktap_state_t *ks, uint32_t asize, uint32_t hbits)
 			vfree(t->array);
 			return NULL;		
 		}
+	t->sort_mem = kmalloc((t->asize + KTAB_MAX_DUMP_ENTRY_NUM) \
+			* sizeof(ktap_node2_t),	GFP_ATOMIC);
+
 	return t;
 }
 
@@ -268,6 +272,8 @@ void kp_tab_free(ktap_state_t *ks, ktap_tab_t *t)
 		vfree(t->node);
 	if (t->asize > 0)
 		vfree(t->array);
+	if (t->sort_mem)
+		kfree(t->sort_mem);
 	kp_free(ks, t);
 }
 
@@ -713,11 +719,6 @@ static void string_convert(char *output, const char *input)
 		memcpy(output, input, strlen(input));
 }
 
-typedef struct ktap_node2 {
-	ktap_val_t key;
-	ktap_val_t val;
-} ktap_node2_t;
-
 static int hist_record_cmp(const void *i, const void *j)
 {
 	ktap_number n1 = nvalue(&((const ktap_node2_t *)i)->val);
@@ -747,13 +748,12 @@ static void tab_histdump(ktap_state_t *ks, ktap_tab_t *t, int shownums)
 
 	start_time = gettimeofday_ns();
 
-	sort_mem = kmalloc((t->asize + t->hnum) * sizeof(ktap_node2_t),
-				GFP_ATOMIC);
-	if (!sort_mem)
+	if (!t->sort_mem)
 		return;
 
+	sort_mem = t->sort_mem;
 	/* copy all values in table into sort_mem. */
-	for (i = 0; i < asize; i++) {
+	for (i = 0; i < asize && total < shownums; i++) {
 		ktap_val_t *val = &array[i];
 		if (is_nil(val))
 			continue;
@@ -769,7 +769,7 @@ static void tab_histdump(ktap_state_t *ks, ktap_tab_t *t, int shownums)
 		total++;
 	}
 
-	for (i = 0; i <= hmask; i++) {
+	for (i = 0; i <= hmask && total < shownums; i++) {
 		ktap_node_t *n = &node[i];
 		ktap_val_t *val = &n->val;
 
@@ -832,7 +832,6 @@ static void tab_histdump(ktap_state_t *ks, ktap_tab_t *t, int shownums)
 		kp_printf(ks, "%31s |\n", "...");
 
  out:
-	kfree(sort_mem);
 
 	delta_time = (gettimeofday_ns() - start_time) / NSEC_PER_USEC;
 	kp_verbose_printf(ks, "tab_histdump time: %d (us)\n", delta_time);
diff --git a/kernel/trace/ktap/ktap.h b/kernel/trace/ktap/ktap.h
index 4efd901..fa030b7 100644
--- a/kernel/trace/ktap/ktap.h
+++ b/kernel/trace/ktap/ktap.h
@@ -5,6 +5,11 @@
 #include <linux/hardirq.h>
 #include <linux/trace_seq.h>
 
+#define KTAP_MAX_ARG_OPT_NUM		1000
+#define HISTOGRAM_DEFAULT_TOP_NUM	20
+#define KTAB_MAX_DUMP_ENTRY_NUM (HISTOGRAM_DEFAULT_TOP_NUM 	\
+		< KTAP_MAX_ARG_OPT_NUM ? KTAP_MAX_ARG_OPT_NUM 	\
+		: HISTOGRAM_DEFAULT_TOP_NUM)
 /* for built-in library C function register */
 typedef struct ktap_libfunc {
         const char *name; /* function name */
diff --git a/kernel/trace/ktap/lib_base.c b/kernel/trace/ktap/lib_base.c
index b776af6..afdde69 100644
--- a/kernel/trace/ktap/lib_base.c
+++ b/kernel/trace/ktap/lib_base.c
@@ -83,7 +83,6 @@ static int kplib_printf(ktap_state_t *ks)
 	return 0;
 }
 
-#define HISTOGRAM_DEFAULT_TOP_NUM	20
 
 static int kplib_print_hist(ktap_state_t *ks)
 {
@@ -92,7 +91,7 @@ static int kplib_print_hist(ktap_state_t *ks)
 	kp_arg_check(ks, 1, KTAP_TTAB);
 	n = kp_arg_checkoptnumber(ks, 2, HISTOGRAM_DEFAULT_TOP_NUM);
 
-	n = min(n, 1000);
+	n = min(n, KTAP_MAX_ARG_OPT_NUM);
 	n = max(n, HISTOGRAM_DEFAULT_TOP_NUM);
 
 	kp_tab_print_hist(ks, hvalue(kp_arg(ks, 1)), n);
-- 
1.7.5.4

