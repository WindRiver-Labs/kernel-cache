From 6d1ab7fea92c9bc1d369a3e61559a128c2a0063c Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 15 Sep 2014 15:41:03 -0700
Subject: [PATCH 2/4] ktap: Add userspace ktap utility

Integrate ktap userspace utility into kernel tree like what perf does.
Correct headers include path and create Makefile for utility build.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 tools/Makefile                                     |   11 +-
 tools/ktap/Makefile                                |   67 +
 tools/ktap/cparser.h                               |  208 ++
 tools/ktap/ffi/cparser.c                           | 1806 +++++++++++
 tools/ktap/ffi/ctype.c                             |  632 ++++
 tools/ktap/kp_bcwrite.c                            |  376 +++
 tools/ktap/kp_lex.c                                |  552 ++++
 tools/ktap/kp_lex.h                                |   94 +
 tools/ktap/kp_main.c                               |  455 +++
 tools/ktap/kp_parse.c                              | 3139 ++++++++++++++++++++
 tools/ktap/kp_parse.h                              |    4 +
 tools/ktap/kp_parse_events.c                       |  798 +++++
 tools/ktap/kp_reader.c                             |  106 +
 tools/ktap/kp_symbol.c                             |  360 +++
 tools/ktap/kp_symbol.h                             |   50 +
 tools/ktap/kp_util.c                               |  646 ++++
 tools/ktap/kp_util.h                               |  134 +
 tools/ktap/samples/ansi/ansi_color_demo.kp         |   22 +
 tools/ktap/samples/basic/backtrace.kp              |    6 +
 tools/ktap/samples/basic/event_trigger.kp          |   27 +
 tools/ktap/samples/basic/event_trigger_ftrace.kp   |   27 +
 tools/ktap/samples/basic/ftrace.kp                 |    8 +
 tools/ktap/samples/basic/function_time.kp          |   62 +
 tools/ktap/samples/basic/kretprobe.kp              |    6 +
 tools/ktap/samples/basic/memcpy_memset.kp          |   23 +
 tools/ktap/samples/ffi/ffi_kmalloc.kp              |   19 +
 tools/ktap/samples/ffi/printk.kp                   |   10 +
 tools/ktap/samples/ffi/sched_clock.kp              |    6 +
 tools/ktap/samples/ffi/skb_cast.kp                 |  106 +
 tools/ktap/samples/game/tetris.kp                  |  297 ++
 tools/ktap/samples/helloworld.kp                   |    3 +
 tools/ktap/samples/interrupt/hardirq_time.kp       |   25 +
 tools/ktap/samples/interrupt/softirq_time.kp       |   24 +
 tools/ktap/samples/io/kprobes-do-sys-open.kp       |   20 +
 tools/ktap/samples/io/traceio.kp                   |   61 +
 tools/ktap/samples/mem/kmalloc-stack.kp            |   12 +
 tools/ktap/samples/mem/kmem_count.kp               |   29 +
 tools/ktap/samples/network/tcp_ipaddr.kp           |   20 +
 tools/ktap/samples/profiling/function_profiler.kp  |   41 +
 .../profiling/kprobe_all_kernel_functions.kp       |   13 +
 tools/ktap/samples/profiling/stack_profile.kp      |   27 +
 tools/ktap/samples/schedule/sched_transition.kp    |    5 +
 tools/ktap/samples/schedule/schedtimes.kp          |  131 +
 tools/ktap/samples/syscalls/errinfo.kp             |  145 +
 tools/ktap/samples/syscalls/execve.kp              |    9 +
 tools/ktap/samples/syscalls/opensnoop.kp           |   31 +
 tools/ktap/samples/syscalls/sctop.kp               |   13 +
 tools/ktap/samples/syscalls/syscalls.kp            |    6 +
 tools/ktap/samples/syscalls/syscalls_count.kp      |   54 +
 .../samples/syscalls/syscalls_count_by_proc.kp     |   22 +
 tools/ktap/samples/syscalls/syslatl.kp             |   33 +
 tools/ktap/samples/syscalls/syslist.kp             |   31 +
 tools/ktap/samples/tracepoints/eventcount.kp       |  210 ++
 .../ktap/samples/tracepoints/eventcount_by_proc.kp |   57 +
 tools/ktap/samples/tracepoints/raw_tracepoint.kp   |   15 +
 tools/ktap/samples/tracepoints/tracepoints.kp      |    6 +
 tools/ktap/samples/userspace/gcc_unwind.kp         |    9 +
 tools/ktap/samples/userspace/glibc_func_hist.kp    |   44 +
 tools/ktap/samples/userspace/glibc_sdt.kp          |   11 +
 tools/ktap/samples/userspace/glibc_trace.kp        |   11 +
 tools/ktap/samples/userspace/malloc_free.kp        |   20 +
 tools/ktap/samples/userspace/malloc_size_hist.kp   |   22 +
 tools/ktap/samples/userspace/pthread.kp            |    8 +
 63 files changed, 11220 insertions(+), 5 deletions(-)
 create mode 100644 tools/ktap/Makefile
 create mode 100644 tools/ktap/cparser.h
 create mode 100644 tools/ktap/ffi/cparser.c
 create mode 100644 tools/ktap/ffi/ctype.c
 create mode 100644 tools/ktap/kp_bcwrite.c
 create mode 100644 tools/ktap/kp_lex.c
 create mode 100644 tools/ktap/kp_lex.h
 create mode 100644 tools/ktap/kp_main.c
 create mode 100644 tools/ktap/kp_parse.c
 create mode 100644 tools/ktap/kp_parse.h
 create mode 100644 tools/ktap/kp_parse_events.c
 create mode 100644 tools/ktap/kp_reader.c
 create mode 100644 tools/ktap/kp_symbol.c
 create mode 100644 tools/ktap/kp_symbol.h
 create mode 100644 tools/ktap/kp_util.c
 create mode 100644 tools/ktap/kp_util.h
 create mode 100644 tools/ktap/samples/ansi/ansi_color_demo.kp
 create mode 100644 tools/ktap/samples/basic/backtrace.kp
 create mode 100644 tools/ktap/samples/basic/event_trigger.kp
 create mode 100644 tools/ktap/samples/basic/event_trigger_ftrace.kp
 create mode 100644 tools/ktap/samples/basic/ftrace.kp
 create mode 100644 tools/ktap/samples/basic/function_time.kp
 create mode 100644 tools/ktap/samples/basic/kretprobe.kp
 create mode 100644 tools/ktap/samples/basic/memcpy_memset.kp
 create mode 100644 tools/ktap/samples/ffi/ffi_kmalloc.kp
 create mode 100644 tools/ktap/samples/ffi/printk.kp
 create mode 100644 tools/ktap/samples/ffi/sched_clock.kp
 create mode 100644 tools/ktap/samples/ffi/skb_cast.kp
 create mode 100644 tools/ktap/samples/game/tetris.kp
 create mode 100644 tools/ktap/samples/helloworld.kp
 create mode 100644 tools/ktap/samples/interrupt/hardirq_time.kp
 create mode 100644 tools/ktap/samples/interrupt/softirq_time.kp
 create mode 100644 tools/ktap/samples/io/kprobes-do-sys-open.kp
 create mode 100644 tools/ktap/samples/io/traceio.kp
 create mode 100644 tools/ktap/samples/mem/kmalloc-stack.kp
 create mode 100644 tools/ktap/samples/mem/kmem_count.kp
 create mode 100644 tools/ktap/samples/network/tcp_ipaddr.kp
 create mode 100644 tools/ktap/samples/profiling/function_profiler.kp
 create mode 100644 tools/ktap/samples/profiling/kprobe_all_kernel_functions.kp
 create mode 100644 tools/ktap/samples/profiling/stack_profile.kp
 create mode 100644 tools/ktap/samples/schedule/sched_transition.kp
 create mode 100644 tools/ktap/samples/schedule/schedtimes.kp
 create mode 100644 tools/ktap/samples/syscalls/errinfo.kp
 create mode 100644 tools/ktap/samples/syscalls/execve.kp
 create mode 100644 tools/ktap/samples/syscalls/opensnoop.kp
 create mode 100644 tools/ktap/samples/syscalls/sctop.kp
 create mode 100644 tools/ktap/samples/syscalls/syscalls.kp
 create mode 100644 tools/ktap/samples/syscalls/syscalls_count.kp
 create mode 100644 tools/ktap/samples/syscalls/syscalls_count_by_proc.kp
 create mode 100644 tools/ktap/samples/syscalls/syslatl.kp
 create mode 100644 tools/ktap/samples/syscalls/syslist.kp
 create mode 100644 tools/ktap/samples/tracepoints/eventcount.kp
 create mode 100644 tools/ktap/samples/tracepoints/eventcount_by_proc.kp
 create mode 100644 tools/ktap/samples/tracepoints/raw_tracepoint.kp
 create mode 100644 tools/ktap/samples/tracepoints/tracepoints.kp
 create mode 100644 tools/ktap/samples/userspace/gcc_unwind.kp
 create mode 100644 tools/ktap/samples/userspace/glibc_func_hist.kp
 create mode 100644 tools/ktap/samples/userspace/glibc_sdt.kp
 create mode 100644 tools/ktap/samples/userspace/glibc_trace.kp
 create mode 100644 tools/ktap/samples/userspace/malloc_free.kp
 create mode 100644 tools/ktap/samples/userspace/malloc_size_hist.kp
 create mode 100644 tools/ktap/samples/userspace/pthread.kp

diff --git a/tools/Makefile b/tools/Makefile
index feec3ad..85174d3 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -17,6 +17,7 @@ help:
 	@echo '  vm         - misc vm tools'
 	@echo '  x86_energy_perf_policy - Intel energy policy tool'
 	@echo '  tmon       - thermal monitoring and tuning tool'
+	@echo '  ktap       - ktap userspace utility'
 	@echo ''
 	@echo 'You can do:'
 	@echo ' $$ make -C tools/ <tool>_install'
@@ -40,7 +41,7 @@ acpi: FORCE
 cpupower: FORCE
 	$(call descend,power/$@)
 
-cgroup firewire guest usb virtio vm net: FORCE
+cgroup firewire guest usb virtio vm net ktap: FORCE
 	$(call descend,$@)
 
 libapikfs: FORCE
@@ -64,7 +65,7 @@ acpi_install:
 cpupower_install:
 	$(call descend,power/$(@:_install=),install)
 
-cgroup_install firewire_install lguest_install perf_install usb_install virtio_install vm_install net_install:
+cgroup_install firewire_install lguest_install perf_install usb_install virtio_install vm_install net_install ktap_install:
 	$(call descend,$(@:_install=),install)
 
 selftests_install:
@@ -77,7 +78,7 @@ tmon_install:
 	$(call descend,thermal/$(@:_install=),install)
 
 install: acpi_install cgroup_install cpupower_install firewire_install lguest_install \
-		perf_install selftests_install turbostat_install usb_install \
+		perf_install selftests_install turbostat_install usb_install ktap_install \
 		virtio_install vm_install net_install x86_energy_perf_policy_install \
 	tmon
 
@@ -87,7 +88,7 @@ acpi_clean:
 cpupower_clean:
 	$(call descend,power/cpupower,clean)
 
-cgroup_clean firewire_clean lguest_clean usb_clean virtio_clean vm_clean net_clean:
+cgroup_clean firewire_clean lguest_clean usb_clean virtio_clean vm_clean net_clean ktap_clean:
 	$(call descend,$(@:_clean=),clean)
 
 libapikfs_clean:
@@ -107,6 +108,6 @@ tmon_clean:
 
 clean: acpi_clean cgroup_clean cpupower_clean firewire_clean lguest_clean \
 		perf_clean selftests_clean turbostat_clean usb_clean virtio_clean \
-		vm_clean net_clean x86_energy_perf_policy_clean tmon_clean
+		vm_clean net_clean x86_energy_perf_policy_clean tmon_clean ktap_clean
 
 .PHONY: FORCE
diff --git a/tools/ktap/Makefile b/tools/ktap/Makefile
new file mode 100644
index 0000000..23c99bc
--- /dev/null
+++ b/tools/ktap/Makefile
@@ -0,0 +1,67 @@
+CC              = $(CROSS_COMPILE)gcc
+BUILD_OUTPUT    := $(PWD)
+PREFIX          := /usr
+DESTDIR         :=
+
+CFLAGS += -Wall -O2
+KTAP_LIBS += -lpthread
+ 
+ifdef NO_LIBELF
+    CFLAGS += -DNO_LIBELF
+else
+    KTAP_LIBS += -lelf
+endif
+
+$(BUILD_OUTPUT)kp_main.o: kp_main.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+$(BUILD_OUTPUT)kp_lex.o: kp_lex.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+$(BUILD_OUTPUT)kp_parse.o: kp_parse.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+$(BUILD_OUTPUT)kp_bcwrite.o: kp_bcwrite.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+$(BUILD_OUTPUT)kp_reader.o: kp_reader.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+$(BUILD_OUTPUT)kp_util.o: kp_util.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+$(BUILD_OUTPUT)kp_parse_events.o: kp_parse_events.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+ifndef NO_LIBELF
+$(BUILD_OUTPUT)kp_symbol.o: kp_symbol.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+endif
+ifdef FFI
+CFLAGS += -DCONFIG_KTAP_FFI
+$(BUILD_OUTPUT)ffi_type.o: ffi/ffi_type.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+$(BUILD_OUTPUT)ffi/cparser.o: ffi/cparser.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+$(BUILD_OUTPUT)ffi/ctype.o: ffi/ctype.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+endif
+
+KTAPOBJS =
+KTAPOBJS += $(BUILD_OUTPUT)kp_main.o
+KTAPOBJS += $(BUILD_OUTPUT)kp_lex.o
+KTAPOBJS += $(BUILD_OPTPUT)kp_parse.o
+KTAPOBJS += $(BUILD_OUTPUT)kp_bcwrite.o
+KTAPOBJS += $(BUILD_OUTPUT)kp_reader.o
+KTAPOBJS += $(BUILD_OUTPUT)kp_util.o
+KTAPOBJS += $(BUILD_OUTPUT)kp_parse_events.o
+ifndef NO_LIBELF
+KTAPOBJS += $(BUILD_OUTPUT)kp_symbol.o
+endif
+ifdef FFI
+KTAPOBJS += $(BUILD_OUTPUT)ffi_type.o
+KTAPOBJS += $(BUILD_OUTPUT)ffi/cparser.o
+KTAPOBJS += $(BUILD_OUTPUT)ffi/ctype.o
+endif
+
+ktap: $(KTAPOBJS)
+	$(CC) $(CFLAGS) -o $@ $(KTAPOBJS) $(KTAP_LIBS)
+
+install: ktap
+	install -d $(DESTDIR)$(PREFIX)/bin/
+	install $(BUILD_OUTPUT)/ktap $(DESTDIR)$(PREFIX)/bin/ktap
+clean:
+	@rm -f $(BUILD_OUTPUT)/ktap
diff --git a/tools/ktap/cparser.h b/tools/ktap/cparser.h
new file mode 100644
index 0000000..3d75bd7
--- /dev/null
+++ b/tools/ktap/cparser.h
@@ -0,0 +1,208 @@
+#ifndef __KTAP_CPARSER_H__
+#define __KTAP_CPARSER_H__
+
+/*
+ * Copyright (c) 2011 James R. McKaskill
+ *
+ * This software is licensed under the stock MIT license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * ----------------------------------------------------------------------------
+ */
+
+/*
+ * Adapted from luaffi commit: abc638c9341025580099dcf77795c4b320ba0e63
+ *
+ * Copyright (c) 2013 Yicheng Qin, Qingping Hou
+ */
+
+#ifdef CONFIG_KTAP_FFI
+
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "../include/ktap_ffi.h"
+
+#define PTR_ALIGN_MASK (sizeof(void*) - 1)
+#define FUNCTION_ALIGN_MASK (sizeof(void (*)()) - 1)
+#define DEFAULT_ALIGN_MASK 7
+
+struct parser {
+	int line;
+	const char *next;
+	const char *prev;
+	unsigned align_mask;
+};
+
+enum {
+	C_CALL,
+	STD_CALL,
+	FAST_CALL,
+};
+
+
+#define MAX_TYPE_NAME_LEN CSYM_NAME_MAX_LEN
+
+enum {
+	/* 0 - 4 */
+	INVALID_TYPE,
+	VOID_TYPE,
+	BOOL_TYPE,
+	INT8_TYPE,
+	INT16_TYPE,
+	/* 5 - 9 */
+	INT32_TYPE,
+	INT64_TYPE,
+	INTPTR_TYPE,
+	ENUM_TYPE,
+	UNION_TYPE,
+	/* 10 - 12 */
+	STRUCT_TYPE,
+	FUNCTION_TYPE,
+	FUNCTION_PTR_TYPE,
+};
+
+
+#define IS_CHAR_UNSIGNED (((char) -1) > 0)
+
+#define POINTER_BITS 2
+#define POINTER_MAX ((1 << POINTER_BITS) - 1)
+
+#define ALIGNOF(S) ((int) ((char*) &S.v - (char*) &S - 1))
+
+
+/* Note: if adding a new member that is associated with a struct/union
+ * definition then it needs to be copied over in ctype.c:set_defined for when
+ * we create types based off of the declaration alone.
+ *
+ * Since this is used as a header for every ctype and cdata, and we create a
+ * ton of them on the stack, we try and minimise its size.
+ */
+struct cp_ctype {
+	size_t base_size; /* size of the base type in bytes */
+	int ffi_base_cs_id;
+	int ffi_cs_id; /* index for csymbol from ktap vm */
+	union {
+		/* valid if is_bitfield */
+		struct {
+			/* size of bitfield in bits */
+			unsigned bit_size : 7;
+			/* offset within the current byte between 0-63 */
+			unsigned bit_offset : 6;
+		};
+		/* Valid if is_array */
+		size_t array_size;
+		/* Valid for is_variable_struct or is_variable_array. If
+		 * variable_size_known (only used for is_variable_struct)
+		 * then this is the total increment otherwise this is the
+		 * per element increment.
+		 */
+		size_t variable_increment;
+	};
+	size_t offset;
+	/* as (align bytes - 1) eg 7 gives 8 byte alignment */
+	unsigned align_mask : 4;
+	/* number of dereferences to get to the base type
+	 * including +1 for arrays */
+	unsigned pointers : POINTER_BITS;
+	/* const pointer mask, LSB is current pointer, +1 for the whether
+	 * the base type is const */
+	unsigned const_mask : POINTER_MAX + 1;
+	unsigned type : 5; /* value given by type enum above */
+	unsigned is_reference : 1;
+	unsigned is_array : 1;
+	unsigned is_defined : 1;
+	unsigned is_null : 1;
+	unsigned has_member_name : 1;
+	unsigned calling_convention : 2;
+	unsigned has_var_arg : 1;
+	/* set for variable array types where we don't know
+	 * the variable size yet */
+	unsigned is_variable_array : 1;
+	unsigned is_variable_struct : 1;
+	/* used for variable structs after we know the variable size */
+	unsigned variable_size_known : 1;
+	unsigned is_bitfield : 1;
+	unsigned has_bitfield : 1;
+	unsigned is_jitted : 1;
+	unsigned is_packed : 1;
+	unsigned is_unsigned : 1;
+};
+
+#define ALIGNED_DEFAULT (__alignof__(void* __attribute__((aligned))) - 1)
+
+csymbol *cp_id_to_csym(int id);
+#define ct_ffi_cs(ct) (cp_id_to_csym((ct)->ffi_cs_id))
+
+size_t ctype_size(const struct cp_ctype* ct);
+int ctype_stack_top();
+int cp_ctype_init();
+int cp_ctype_free();
+struct cp_ctype *ctype_lookup_type(char *name);
+void cp_ctype_dump_stack();
+void cp_error(const char *err_msg_fmt, ...);
+struct cp_ctype *cp_ctype_reg_type(char *name, struct cp_ctype *ct);
+
+void cp_update_csym_in_ctype(struct cp_ctype *ct);
+void cp_push_ctype_with_name(struct cp_ctype *ct, const char *name, int nlen);
+void cp_push_ctype(struct cp_ctype *ct);
+void cp_set_defined(struct cp_ctype *ct);
+
+int cp_symbol_build_func(struct cp_ctype *type, const char *fname, int fn_size);
+int cp_symbol_build_record(const char *stname, int type, int start_top);
+int cp_symbol_build_fake_record(const char *stname, int type);
+int cp_symbol_build_pointer(struct cp_ctype *ct);
+
+int ffi_parse_cdef(const char *s);
+void ffi_parse_new(const char *s, struct cp_ctype *ct);
+int ffi_lookup_csymbol_id_by_name(const char *s);
+
+void ffi_cparser_init(void);
+void ffi_cparser_free(void);
+
+
+static inline csymbol *cp_csymf_ret(csymbol_func *csf)
+{
+	return cp_id_to_csym(csf->ret_id);
+}
+
+static inline csymbol *cp_csymf_arg(csymbol_func *csf, int idx)
+{
+	return cp_id_to_csym(csf->arg_ids[idx]);
+}
+
+
+#else
+static inline void ffi_cparser_init(void)
+{
+	return;
+}
+static inline void ffi_cparser_free(void)
+{
+	return;
+}
+#endif /* CONFIG_KTAP_FFI */
+
+
+#endif /* __KTAP_CPARSER_H__ */
diff --git a/tools/ktap/ffi/cparser.c b/tools/ktap/ffi/cparser.c
new file mode 100644
index 0000000..8128fec
--- /dev/null
+++ b/tools/ktap/ffi/cparser.c
@@ -0,0 +1,1806 @@
+#include <stdarg.h>
+#include "../cparser.h"
+
+#define IS_CONST(tok) (IS_LITERAL(tok, "const") || IS_LITERAL(tok, "__const") \
+			|| IS_LITERAL(tok, "__const__"))
+#define IS_VOLATILE(tok) (IS_LITERAL(tok, "volatile") || \
+				IS_LITERAL(tok, "__volatile") || \
+				IS_LITERAL(tok, "__volatile__"))
+#define IS_RESTRICT(tok) (IS_LITERAL(tok, "restrict") || \
+				IS_LITERAL(tok, "__restrict") || \
+				IS_LITERAL(tok, "__restrict__"))
+
+#define max(a,b) ((a) < (b) ? (b) : (a))
+#define min(a,b) ((a) < (b) ? (a) : (b))
+
+
+enum etoken {
+	/* 0 - 3 */
+	TOK_NIL,
+	TOK_NUMBER,
+	TOK_STRING,
+	TOK_TOKEN,
+
+	/* the order of these values must match the token strings in lex.c */
+
+	/* 4 - 5 */
+	TOK_3_BEGIN,
+	TOK_VA_ARG,
+
+	/* 6 - 14 */
+	TOK_2_BEGIN,
+	TOK_LEFT_SHIFT, TOK_RIGHT_SHIFT, TOK_LOGICAL_AND, TOK_LOGICAL_OR,
+	TOK_LESS_EQUAL, TOK_GREATER_EQUAL, TOK_EQUAL, TOK_NOT_EQUAL,
+
+	/* 15 - 20 */
+	TOK_1_BEGIN,
+	TOK_OPEN_CURLY, TOK_CLOSE_CURLY, TOK_SEMICOLON, TOK_COMMA, TOK_COLON,
+	/* 21 - 30 */
+	TOK_ASSIGN, TOK_OPEN_PAREN, TOK_CLOSE_PAREN, TOK_OPEN_SQUARE, TOK_CLOSE_SQUARE,
+	TOK_DOT, TOK_AMPERSAND, TOK_LOGICAL_NOT, TOK_BITWISE_NOT, TOK_MINUS,
+	/* 31 - 40 */
+	TOK_PLUS, TOK_STAR, TOK_DIVIDE, TOK_MODULUS, TOK_LESS,
+	TOK_GREATER, TOK_BITWISE_XOR, TOK_BITWISE_OR, TOK_QUESTION, TOK_POUND,
+
+	/* 41 - 43 */
+	TOK_REFERENCE = TOK_AMPERSAND,
+	TOK_MULTIPLY = TOK_STAR,
+	TOK_BITWISE_AND = TOK_AMPERSAND,
+};
+
+struct token {
+	enum etoken type;
+	int64_t integer;
+	const char *str;
+	size_t size;
+};
+
+#define IS_LITERAL(TOK, STR) \
+	(((TOK).size == sizeof(STR) - 1) && \
+		0 == memcmp((TOK).str, STR, sizeof(STR) - 1))
+
+
+static int parse_type_name(struct parser *P, char *type_name);
+static void parse_argument(struct parser *P, struct cp_ctype *ct,
+		struct token *pname, struct parser *asmname);
+static int parse_attribute(struct parser *P, struct token *tok,
+		struct cp_ctype *ct, struct parser *asmname);
+static int parse_record(struct parser *P, struct cp_ctype *ct);
+static void instantiate_typedef(struct parser *P, struct cp_ctype *tt,
+		const struct cp_ctype *ft);
+
+
+/* the order of tokens _must_ match the order of the enum etoken enum */
+
+static char tok3[][4] = {
+	"...", /* unused ">>=", "<<=", */
+};
+
+static char tok2[][3] = {
+	"<<", ">>", "&&", "||", "<=",
+	">=", "==", "!=",
+	/* unused "+=", "-=", "*=", "/=", "%=", "&=", "^=",
+	 * "|=", "++", "--", "->", "::", */
+};
+
+static char tok1[] = {
+	'{', '}', ';', ',', ':',
+	'=', '(', ')', '[', ']',
+	'.', '&', '!', '~', '-',
+	'+', '*', '/', '%', '<',
+	'>', '^', '|', '?', '#'
+};
+
+
+/* this function never returns, but it's an idiom to use it in C functions
+ * as return cp_error */
+void cp_error(const char *err_msg_fmt, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "cparser error:\n");
+
+	va_start(ap, err_msg_fmt);
+	vfprintf(stderr, err_msg_fmt, ap);
+	va_end(ap);
+
+	exit(EXIT_FAILURE);
+}
+
+static int set_type_name(char *dst, unsigned type, const char *src, int len)
+{
+	int prefix_len;
+	char *prefix = NULL;
+
+	if (type == STRUCT_TYPE)
+		prefix = "struct ";
+	else if (type == UNION_TYPE)
+		prefix = "union ";
+	else
+		cp_error("Only set type name for struct or union\n");
+	prefix_len = sizeof(prefix);
+
+	if (len + prefix_len > MAX_TYPE_NAME_LEN)
+		return -1;
+
+	memset(dst, 0, MAX_TYPE_NAME_LEN);
+	strcpy(dst, prefix);
+	strncat(dst, src, len);
+
+	return 0;
+}
+
+static void increase_ptr_deref_level(struct parser *P, struct cp_ctype *ct)
+{
+	if (ct->pointers == POINTER_MAX) {
+		cp_error("maximum number of pointer derefs reached - use a "
+			"struct to break up the pointers on line %d", P->line);
+	} else {
+		ct->pointers++;
+		ct->const_mask <<= 1;
+	}
+}
+
+static int next_token(struct parser *P, struct token *tok)
+{
+	size_t i;
+	const char *s = P->next;
+
+	/* UTF8 BOM */
+	if (s[0] == '\xEF' && s[1] == '\xBB' && s[2] == '\xBF') {
+		s += 3;
+	}
+
+	/* consume whitespace and comments */
+	for (;;) {
+		/* consume whitespace */
+		while (*s == '\t' || *s == '\n' || *s == ' '
+				|| *s == '\v' || *s == '\r') {
+			if (*s == '\n') {
+				P->line++;
+			}
+			s++;
+		}
+
+		/* consume comments */
+		if (*s == '/' && *(s+1) == '/') {
+
+			s = strchr(s, '\n');
+			if (!s) {
+				cp_error("non-terminated comment");
+			}
+
+		} else if (*s == '/' && *(s+1) == '*') {
+			s += 2;
+
+			for (;;) {
+				if (s[0] == '\0') {
+					cp_error("non-terminated comment");
+				} else if (s[0] == '*' && s[1] == '/') {
+					s += 2;
+					break;
+				} else if (s[0] == '\n') {
+					P->line++;
+				}
+				s++;
+			}
+
+		} else if (*s == '\0') {
+			tok->type = TOK_NIL;
+			return 0;
+
+		} else {
+			break;
+		}
+	}
+
+	P->prev = s;
+
+	for (i = 0; i < sizeof(tok3) / sizeof(tok3[0]); i++) {
+		if (s[0] == tok3[i][0] && s[1] == tok3[i][1] && s[2] == tok3[i][2]) {
+			tok->type = (enum etoken) (TOK_3_BEGIN + 1 + i);
+			P->next = s + 3;
+			goto end;
+		}
+	}
+
+	for (i = 0; i < sizeof(tok2) / sizeof(tok2[0]); i++) {
+		if (s[0] == tok2[i][0] && s[1] == tok2[i][1]) {
+			tok->type = (enum etoken) (TOK_2_BEGIN + 1 + i);
+			P->next = s + 2;
+			goto end;
+		}
+	}
+
+	for (i = 0; i < sizeof(tok1) / sizeof(tok1[0]); i++) {
+		if (s[0] == tok1[i]) {
+			tok->type = (enum etoken) (TOK_1_BEGIN + 1 + i);
+			P->next = s + 1;
+			goto end;
+		}
+	}
+
+	if (*s == '.' || *s == '-' || ('0' <= *s && *s <= '9')) {
+		/* number */
+		tok->type = TOK_NUMBER;
+
+		/* split out the negative case so we get the full range of
+		 * bits for unsigned (eg to support 0xFFFFFFFF where
+		 * sizeof(long) == 4 */
+		if (*s == '-') {
+			tok->integer = strtol(s, (char**) &s, 0);
+		} else {
+			tok->integer = strtoul(s, (char**) &s, 0);
+		}
+
+		while (*s == 'u' || *s == 'U' || *s == 'l' || *s == 'L') {
+			s++;
+		}
+
+		P->next = s;
+		goto end;
+
+	} else if (*s == '\'' || *s == '\"') {
+		/* "..." or '...' */
+		char quote = *s;
+		s++; /* jump over " */
+
+		tok->type = TOK_STRING;
+		tok->str = s;
+
+		while (*s != quote) {
+			if (*s == '\0' || (*s == '\\' && *(s+1) == '\0')) {
+				cp_error("string not finished\n");
+			}
+			if (*s == '\\') {
+				s++;
+			}
+			s++;
+		}
+
+		tok->size = s - tok->str;
+		s++; /* jump over " */
+		P->next = s;
+		goto end;
+
+	} else if (('a' <= *s && *s <= 'z') || ('A' <= *s && *s <= 'Z')
+			|| *s == '_') {
+		/* tokens */
+		tok->type = TOK_TOKEN;
+		tok->str = s;
+
+		while (('a' <= *s && *s <= 'z') || ('A' <= *s && *s <= 'Z')
+				|| *s == '_' || ('0' <= *s && *s <= '9')) {
+			s++;
+		}
+
+		tok->size = s - tok->str;
+		P->next = s;
+		goto end;
+	} else {
+		cp_error("invalid character %d", P->line);
+	}
+
+end:
+	return 1;
+}
+
+static void require_token(struct parser *P, struct token *tok)
+{
+	if (!next_token(P, tok)) {
+		cp_error("unexpected end");
+	}
+}
+
+static void check_token(struct parser *P, int type, const char *str,
+				const char *err, ...)
+{
+	va_list ap;
+	struct token tok;
+	if (!next_token(P, &tok) || tok.type != type
+			|| (tok.type == TOK_TOKEN && (tok.size != strlen(str)
+				|| memcmp(tok.str, str, tok.size) != 0))) {
+
+		va_start(ap, err);
+		vfprintf(stderr, err, ap);
+		va_end(ap);
+
+		exit(EXIT_FAILURE);
+	}
+}
+
+static void put_back(struct parser *P) {
+	P->next = P->prev;
+}
+
+int64_t calculate_constant(struct parser *P);
+
+/* parses out the base type of a type expression in a function declaration,
+ * struct definition, typedef etc
+ *
+ * leaves the usr value of the type on the stack
+ */
+int parse_type(struct parser *P, struct cp_ctype *ct)
+{
+	struct token tok;
+
+	memset(ct, 0, sizeof(*ct));
+
+	require_token(P, &tok);
+
+	/* get function attributes before the return type */
+	while (parse_attribute(P, &tok, ct, NULL)) {
+		require_token(P, &tok);
+	}
+
+	/* get const/volatile before the base type */
+	for (;;) {
+		if (tok.type != TOK_TOKEN) {
+			cp_error("unexpected value before type name on line %d",
+					P->line);
+			return 0;
+		} else if (IS_CONST(tok)) {
+			ct->const_mask = 1;
+			require_token(P, &tok);
+		} else if (IS_VOLATILE(tok) || IS_RESTRICT(tok)) {
+			/* ignored for now */
+			require_token(P, &tok);
+		} else {
+			break;
+		}
+	}
+
+	/* get base type */
+	if (tok.type != TOK_TOKEN) {
+		cp_error("unexpected value before type name on line %d", P->line);
+		return 0;
+	} else if (IS_LITERAL(tok, "struct")) {
+		ct->type = STRUCT_TYPE;
+		parse_record(P, ct);
+	} else if (IS_LITERAL(tok, "union")) {
+		ct->type = UNION_TYPE;
+		parse_record(P, ct);
+	} else if (IS_LITERAL(tok, "enum")) {
+		ct->type = ENUM_TYPE;
+		parse_record(P, ct);
+	} else {
+		put_back(P);
+
+		/* lookup type */
+		struct cp_ctype *lct;
+		char cur_type_name[MAX_TYPE_NAME_LEN];
+
+		memset(cur_type_name, 0, MAX_TYPE_NAME_LEN);
+		parse_type_name(P, cur_type_name);
+		lct = ctype_lookup_type(cur_type_name);
+		if (!lct)
+			cp_error("unknow type: \"%s\"\n", cur_type_name);
+
+		instantiate_typedef(P, ct, lct);
+	}
+
+	while (next_token(P, &tok)) {
+		if (tok.type != TOK_TOKEN) {
+			put_back(P);
+			break;
+		} else if (IS_CONST(tok) || IS_VOLATILE(tok)) {
+			/* ignore for now */
+		} else {
+			put_back(P);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+enum test {TEST};
+
+/* Parses an enum definition from after the open curly through to the close
+ * curly. Expects the user table to be on the top of the stack
+ */
+static int parse_enum(struct parser *P, struct cp_ctype *type)
+{
+	struct token tok;
+	int value = -1;
+
+	/*@TODO clean up this function when enum support is added*/
+	cp_error("TODO: enum not supported!\n");
+
+	for (;;) {
+		require_token(P, &tok);
+
+		if (tok.type == TOK_CLOSE_CURLY) {
+			break;
+		} else if (tok.type != TOK_TOKEN) {
+			cp_error("unexpected token in enum at line %d", P->line);
+			return 0;
+		}
+		require_token(P, &tok);
+
+		if (tok.type == TOK_COMMA || tok.type == TOK_CLOSE_CURLY) {
+			/* we have an auto calculated enum value */
+			value++;
+		} else if (tok.type == TOK_ASSIGN) {
+			/* we have an explicit enum value */
+			value = (int) calculate_constant(P);
+			require_token(P, &tok);
+		} else {
+			cp_error("unexpected token in enum at line %d", P->line);
+			return 0;
+		}
+
+		if (tok.type == TOK_CLOSE_CURLY) {
+			break;
+		} else if (tok.type != TOK_COMMA) {
+			cp_error("unexpected token in enum at line %d", P->line);
+			return 0;
+		}
+	}
+
+	type->base_size = sizeof(enum test);
+	type->align_mask = sizeof(enum test) - 1;
+
+	return 0;
+}
+
+/* Parses a struct from after the open curly through to the close curly. */
+static int parse_struct(struct parser *P, const struct cp_ctype *ct)
+{
+	struct token tok;
+
+	/* parse members */
+	for (;;) {
+		struct cp_ctype mbase;
+
+		/* see if we're at the end of the struct */
+		require_token(P, &tok);
+		if (tok.type == TOK_CLOSE_CURLY) {
+			break;
+		} else if (ct->is_variable_struct) {
+			cp_error("can't have members after a variable sized "
+					"member on line %d", P->line);
+			return -1;
+		} else {
+			put_back(P);
+		}
+
+		/* members are of the form
+		 * <base type> <arg>, <arg>, <arg>;
+		 * eg struct foo bar, *bar2[2];
+		 * mbase is 'struct foo'
+		 * mtype is '' then '*[2]'
+		 * mname is 'bar' then 'bar2'
+		 */
+
+		parse_type(P, &mbase);
+
+		for (;;) {
+			struct token mname;
+			struct cp_ctype mt = mbase;
+
+			memset(&mname, 0, sizeof(mname));
+
+			if (ct->is_variable_struct) {
+				cp_error("can't have members after a variable "
+					"sized member on line %d", P->line);
+				return -1;
+			}
+
+			parse_argument(P, &mt, &mname, NULL);
+
+			if (!mt.is_defined && (mt.pointers - mt.is_array) == 0) {
+				cp_error("member type is undefined on line %d",
+						P->line);
+				return -1;
+			}
+
+			if (mt.type == VOID_TYPE
+					&& (mt.pointers - mt.is_array) == 0) {
+				cp_error("member type can not be void on line %d",
+						P->line);
+				return -1;
+			}
+
+			mt.has_member_name = (mname.size > 0);
+			if (mt.has_member_name) {
+				cp_push_ctype_with_name(&mt,
+						mname.str, mname.size);
+			} else {
+				cp_push_ctype(&mt);
+			}
+
+			require_token(P, &tok);
+			if (tok.type == TOK_SEMICOLON) {
+				break;
+			} else if (tok.type != TOK_COMMA) {
+				cp_error("unexpected token in struct "
+					"definition on line %d", P->line);
+			}
+		}
+	}
+
+	return 0;
+}
+
+/* copy over attributes that could be specified before the typedef eg
+ * __attribute__(packed) const type_t */
+static void instantiate_typedef(struct parser *P, struct cp_ctype *tt,
+		const struct cp_ctype *ft)
+{
+	struct cp_ctype pt = *tt;
+	*tt = *ft;
+
+	tt->const_mask |= pt.const_mask;
+	tt->is_packed = pt.is_packed;
+
+	if (tt->is_packed) {
+		tt->align_mask = 0;
+	} else {
+		/* Instantiate the typedef in the current packing. This may be
+		 * further updated if a pointer is added or another alignment
+		 * attribute is applied. If pt.align_mask is already non-zero
+		 * than an increased alignment via __declspec(aligned(#)) has
+		 * been set. */
+		tt->align_mask = max(min(P->align_mask, tt->align_mask),
+					pt.align_mask);
+	}
+}
+
+/* this parses a struct or union starting with the optional
+ * name before the opening brace
+ * leaves the type usr value on the stack */
+static int parse_record(struct parser *P, struct cp_ctype *ct)
+{
+	struct token tok;
+	char cur_type_name[MAX_TYPE_NAME_LEN];
+	int has_name;
+
+	require_token(P, &tok);
+
+	/* name is optional */
+	memset(cur_type_name, 0, MAX_TYPE_NAME_LEN);
+	if (tok.type == TOK_TOKEN) {
+		/* declaration */
+		struct cp_ctype *lct;
+
+		set_type_name(cur_type_name, ct->type, tok.str, tok.size);
+
+		/* lookup the name to see if we've seen this type before */
+		lct = ctype_lookup_type(cur_type_name);
+
+		if (!lct) {
+			/* new type, delay type registration to the end
+			 * of this function */
+			ct->ffi_base_cs_id = ct->ffi_cs_id = -1;
+		} else {
+			/* get the exsting declared type */
+			if (lct->type != ct->type) {
+				cp_error("type '%s' previously declared as '%s'",
+					cur_type_name,
+					csym_name(ct_ffi_cs(lct)));
+			}
+
+			instantiate_typedef(P, ct, lct);
+		}
+
+		/* if a name is given then we may be at the end of the string
+		 * eg for ffi.new('struct foo') */
+		if (!next_token(P, &tok)) {
+			return 0;
+		}
+		has_name = 1;
+	} else {
+		char anon_name[MAX_TYPE_NAME_LEN];
+		/* create a new unnamed record */
+		sprintf(anon_name, "%d line", P->line);
+		set_type_name(cur_type_name, ct->type,
+				anon_name, strlen(anon_name));
+		ct->ffi_base_cs_id = ct->ffi_cs_id = -1;
+		has_name = 0;
+	}
+
+	if (tok.type != TOK_OPEN_CURLY) {
+		/* this may just be a declaration or use of the type as an
+		 * argument or member */
+		put_back(P);
+		if (!has_name)
+			cp_error("noname record type declaration\n");
+
+		/* build symbol for vm */
+		ct->ffi_base_cs_id =
+			cp_symbol_build_fake_record(cur_type_name, ct->type);
+		ct->ffi_cs_id = ct->ffi_base_cs_id;
+		return 0;
+	}
+
+	if (ct->is_defined) {
+		cp_error("redefinition in line %d", P->line);
+		return 0;
+	}
+
+	if (ct->type == ENUM_TYPE) {
+		parse_enum(P, ct);
+		cp_set_defined(ct);
+	} else {
+		int start_top = ctype_stack_top();
+		/* we do a two stage parse, where we parse the content first
+		 * and build up the temp user table. We then iterate over that
+		 * to calculate the offsets and fill out ct_usr. This is so we
+		 * can handle out of order members (eg vtable) and attributes
+		 * specified at the end of the struct. */
+		parse_struct(P, ct);
+		cp_set_defined(ct);
+		/* build symbol for vm */
+		ct->ffi_base_cs_id = cp_symbol_build_record(
+				cur_type_name, ct->type, start_top);
+		ct->ffi_cs_id = ct->ffi_base_cs_id;
+		/* save cp_ctype for parser */
+		cp_ctype_reg_type(cur_type_name, ct);
+	}
+
+	return 0;
+}
+
+/* parses single or multi work built in types, and pushes it onto the stack */
+static int parse_type_name(struct parser *P, char *type_name)
+{
+	struct token tok;
+	int flags = 0;
+
+	enum {
+		UNSIGNED = 0x01,
+		SIGNED = 0x02,
+		LONG = 0x04,
+		SHORT = 0x08,
+		INT = 0x10,
+		CHAR = 0x20,
+		LONG_LONG = 0x40,
+		INT8 = 0x80,
+		INT16 = 0x100,
+		INT32 = 0x200,
+		INT64 = 0x400,
+	};
+
+	require_token(P, &tok);
+
+	/* we have to manually decode the builtin types since they can take up
+	 * more then one token */
+	for (;;) {
+		if (tok.type != TOK_TOKEN) {
+			break;
+		} else if (IS_LITERAL(tok, "unsigned")) {
+			flags |= UNSIGNED;
+		} else if (IS_LITERAL(tok, "signed")) {
+			flags |= SIGNED;
+		} else if (IS_LITERAL(tok, "short")) {
+			flags |= SHORT;
+		} else if (IS_LITERAL(tok, "char")) {
+			flags |= CHAR;
+		} else if (IS_LITERAL(tok, "long")) {
+			flags |= (flags & LONG) ? LONG_LONG : LONG;
+		} else if (IS_LITERAL(tok, "int")) {
+			flags |= INT;
+		} else if (IS_LITERAL(tok, "__int8")) {
+			flags |= INT8;
+		} else if (IS_LITERAL(tok, "__int16")) {
+			flags |= INT16;
+		} else if (IS_LITERAL(tok, "__int32")) {
+			flags |= INT32;
+		} else if (IS_LITERAL(tok, "__int64")) {
+			flags |= INT64;
+		} else if (IS_LITERAL(tok, "register")) {
+			/* ignore */
+		} else {
+			break;
+		}
+
+		if (!next_token(P, &tok)) {
+			break;
+		}
+	}
+
+	if (flags) {
+		put_back(P);
+	}
+
+	if (flags & CHAR) {
+		if (flags & SIGNED) {
+			strcpy(type_name, "int8_t");
+		} else if (flags & UNSIGNED) {
+			strcpy(type_name, "uint8_t");
+		} else {
+			if (((char) -1) > 0) {
+				strcpy(type_name, "uint8_t");
+			} else {
+				strcpy(type_name, "int8_t");
+			}
+		}
+	} else if (flags & INT8) {
+		strcpy(type_name, (flags & UNSIGNED) ? "uint8_t" : "int8_t");
+	} else if (flags & INT16) {
+		strcpy(type_name, (flags & UNSIGNED) ? "uint16_t" : "int16_t");
+	} else if (flags & INT32) {
+		strcpy(type_name, (flags & UNSIGNED) ? "uint32_t" : "int32_t");
+	} else if (flags & INT64) {
+		strcpy(type_name, (flags & UNSIGNED) ? "uint64_t" : "int64_t");
+	} else if (flags & LONG_LONG) {
+		strcpy(type_name, (flags & UNSIGNED) ? "uint64_t" : "int64_t");
+	} else if (flags & SHORT) {
+#define SHORT_TYPE(u) (sizeof(short) == sizeof(int64_t) ? \
+		u "int64_t" : sizeof(short) == sizeof(int32_t) ? \
+		u "int32_t" : u "int16_t")
+		if (flags & UNSIGNED) {
+			strcpy(type_name, SHORT_TYPE("u"));
+		} else {
+			strcpy(type_name, SHORT_TYPE(""));
+		}
+#undef SHORT_TYPE
+	} else if (flags & LONG) {
+#define LONG_TYPE(u) (sizeof(long) == sizeof(int64_t) ? \
+		u "int64_t" : u "int32_t")
+		if (flags & UNSIGNED) {
+			strcpy(type_name, LONG_TYPE("u"));
+		} else {
+			strcpy(type_name, LONG_TYPE(""));
+		}
+#undef LONG_TYPE
+	} else if (flags) {
+#define INT_TYPE(u) (sizeof(int) == sizeof(int64_t) ? \
+		u "int64_t" : sizeof(int) == sizeof(int32_t) ? \
+		u "int32_t" : u "int16_t")
+		if (flags & UNSIGNED) {
+			strcpy(type_name, INT_TYPE("u"));
+		} else {
+			strcpy(type_name, INT_TYPE(""));
+		}
+#undef INT_TYPE
+	} else {
+		strncpy(type_name, tok.str, tok.size);
+	}
+
+	return 0;
+}
+
+/* parse_attribute parses a token to see if it is an attribute. It may then
+ * parse some following tokens to decode the attribute setting the appropriate
+ * fields in ct. It will return 1 if the token was used (and possibly some
+ * more following it) or 0 if not. If the token was used, the next token must
+ * be retrieved using next_token/require_token. */
+static int parse_attribute(struct parser *P, struct token *tok,
+		struct cp_ctype *ct, struct parser *asmname)
+{
+	if (tok->type != TOK_TOKEN) {
+		return 0;
+	} else if (asmname && (IS_LITERAL(*tok, "__asm__")
+				|| IS_LITERAL(*tok, "__asm"))) {
+		check_token(P, TOK_OPEN_PAREN, NULL,
+				"unexpected token after __asm__ on line %d",
+				P->line);
+		*asmname = *P;
+
+		require_token(P, tok);
+		while (tok->type == TOK_STRING) {
+			require_token(P, tok);
+		}
+
+		if (tok->type != TOK_CLOSE_PAREN) {
+			cp_error("unexpected token after __asm__ on line %d",
+					P->line);
+		}
+		return 1;
+
+	} else if (IS_LITERAL(*tok, "__attribute__")
+			|| IS_LITERAL(*tok, "__declspec")) {
+		int parens = 1;
+		check_token(P, TOK_OPEN_PAREN, NULL,
+				"expected parenthesis after __attribute__ or "
+				"__declspec on line %d", P->line);
+
+		for (;;) {
+			require_token(P, tok);
+			if (tok->type == TOK_OPEN_PAREN) {
+				parens++;
+			} else if (tok->type == TOK_CLOSE_PAREN) {
+				if (--parens == 0) {
+					break;
+				}
+
+			} else if (tok->type != TOK_TOKEN) {
+				/* ignore unknown symbols within parentheses */
+
+			} else if (IS_LITERAL(*tok, "align") ||
+					IS_LITERAL(*tok, "aligned") ||
+					IS_LITERAL(*tok, "__aligned__")) {
+				unsigned align = 0;
+				require_token(P, tok);
+
+				switch (tok->type) {
+				case TOK_CLOSE_PAREN:
+					align = ALIGNED_DEFAULT;
+					put_back(P);
+					break;
+
+				case TOK_OPEN_PAREN:
+					require_token(P, tok);
+
+					if (tok->type != TOK_NUMBER) {
+						cp_error("expected align(#) "
+							"on line %d", P->line);
+					}
+
+					switch (tok->integer) {
+					case 1: align = 0; break;
+					case 2: align = 1; break;
+					case 4: align = 3; break;
+					case 8: align = 7; break;
+					case 16: align = 15; break;
+					default:
+						cp_error("unsupported align "
+							"size on line %d",
+							P->line);
+					}
+
+					check_token(P, TOK_CLOSE_PAREN, NULL,
+						"expected align(#) on line %d",
+						P->line);
+					break;
+
+				default:
+					cp_error("expected align(#) on line %d",
+							P->line);
+				}
+
+				/* __attribute__(aligned(#)) is only supposed
+				 * to increase alignment */
+				ct->align_mask = max(align, ct->align_mask);
+
+			} else if (IS_LITERAL(*tok, "packed")
+					|| IS_LITERAL(*tok, "__packed__")) {
+				ct->align_mask = 0;
+				ct->is_packed = 1;
+
+			} else if (IS_LITERAL(*tok, "mode")
+					|| IS_LITERAL(*tok, "__mode__")) {
+
+				check_token(P, TOK_OPEN_PAREN, NULL,
+					"expected mode(MODE) on line %d",
+					P->line);
+
+				require_token(P, tok);
+				if (tok->type != TOK_TOKEN) {
+					cp_error("expected mode(MODE) on line %d",
+							P->line);
+				}
+
+
+				struct {char ch; uint16_t v;} a16;
+				struct {char ch; uint32_t v;} a32;
+				struct {char ch; uint64_t v;} a64;
+
+				if (IS_LITERAL(*tok, "QI")
+						|| IS_LITERAL(*tok, "__QI__")
+						|| IS_LITERAL(*tok, "byte")
+						|| IS_LITERAL(*tok, "__byte__")
+				   ) {
+					ct->type = INT8_TYPE;
+					ct->base_size = sizeof(uint8_t);
+					ct->align_mask = 0;
+
+				} else if (IS_LITERAL(*tok, "HI")
+						|| IS_LITERAL(*tok, "__HI__")) {
+					ct->type = INT16_TYPE;
+					ct->base_size = sizeof(uint16_t);
+					ct->align_mask = ALIGNOF(a16);
+
+				} else if (IS_LITERAL(*tok, "SI")
+						|| IS_LITERAL(*tok, "__SI__")
+#if defined ARCH_X86 || defined ARCH_ARM
+						|| IS_LITERAL(*tok, "word")
+						|| IS_LITERAL(*tok, "__word__")
+						|| IS_LITERAL(*tok, "pointer")
+						|| IS_LITERAL(*tok, "__pointer__")
+#endif
+					  ) {
+					ct->type = INT32_TYPE;
+					ct->base_size = sizeof(uint32_t);
+					ct->align_mask = ALIGNOF(a32);
+
+				} else if (IS_LITERAL(*tok, "DI")
+						|| IS_LITERAL(*tok, "__DI__")
+#if defined ARCH_X64
+						|| IS_LITERAL(*tok, "word")
+						|| IS_LITERAL(*tok, "__word__")
+						|| IS_LITERAL(*tok, "pointer")
+						|| IS_LITERAL(*tok, "__pointer__")
+#endif
+					  ) {
+					ct->type = INT64_TYPE;
+					ct->base_size = sizeof(uint64_t);
+					ct->align_mask = ALIGNOF(a64);
+
+				} else {
+					cp_error("unexpected mode on line %d",
+							P->line);
+				}
+
+				check_token(P, TOK_CLOSE_PAREN, NULL,
+					"expected mode(MODE) on line %d", P->line);
+
+			} else if (IS_LITERAL(*tok, "cdecl")
+					|| IS_LITERAL(*tok, "__cdecl__")) {
+				ct->calling_convention = C_CALL;
+
+			} else if (IS_LITERAL(*tok, "fastcall")
+					|| IS_LITERAL(*tok, "__fastcall__")) {
+				ct->calling_convention = FAST_CALL;
+
+			} else if (IS_LITERAL(*tok, "stdcall")
+					|| IS_LITERAL(*tok, "__stdcall__")) {
+				ct->calling_convention = STD_CALL;
+			}
+			/* ignore unknown tokens within parentheses */
+		}
+		return 1;
+
+	} else if (IS_LITERAL(*tok, "__cdecl")) {
+		ct->calling_convention = C_CALL;
+		return 1;
+
+	} else if (IS_LITERAL(*tok, "__fastcall")) {
+		ct->calling_convention = FAST_CALL;
+		return 1;
+
+	} else if (IS_LITERAL(*tok, "__stdcall")) {
+		ct->calling_convention = STD_CALL;
+		return 1;
+
+	} else if (IS_LITERAL(*tok, "__extension__")
+			|| IS_LITERAL(*tok, "extern")) {
+		/* ignore */
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/* parses from after the opening paranthesis to after the closing parenthesis */
+static void parse_function_arguments(struct parser* P, struct cp_ctype* ct)
+{
+	struct token tok;
+	int args = 0;
+
+	for (;;) {
+		require_token(P, &tok);
+
+		if (tok.type == TOK_CLOSE_PAREN)
+			break;
+
+		if (args) {
+			if (tok.type != TOK_COMMA) {
+				cp_error("unexpected token in function "
+						"argument %d on line %d",
+						args, P->line);
+			}
+			require_token(P, &tok);
+		}
+
+		if (tok.type == TOK_VA_ARG) {
+			ct->has_var_arg = true;
+			check_token(P, TOK_CLOSE_PAREN, "",
+					"unexpected token after ... in "
+					"function on line %d",
+					P->line);
+			break;
+		} else if (tok.type == TOK_TOKEN) {
+			struct cp_ctype at;
+
+			put_back(P);
+			parse_type(P, &at);
+			parse_argument(P, &at, NULL, NULL);
+
+			/* array arguments are just treated as their
+			 * base pointer type */
+			at.is_array = 0;
+
+			/* check for the c style int func(void) and error
+			 * on other uses of arguments of type void */
+			if (at.type == VOID_TYPE && at.pointers == 0) {
+				if (args) {
+					cp_error("can't have argument of type "
+							"void on line %d",
+							P->line);
+				}
+
+				check_token(P, TOK_CLOSE_PAREN, "",
+					"unexpected void in function on line %d",
+					P->line);
+				break;
+			}
+			cp_push_ctype(&at);
+			args++;
+		} else {
+			cp_error("unexpected token in function argument %d "
+					"on line %d", args+1, P->line);
+		}
+	}
+}
+
+static int max_bitfield_size(int type)
+{
+	switch (type) {
+	case BOOL_TYPE:
+		return 1;
+	case INT8_TYPE:
+		return 8;
+	case INT16_TYPE:
+		return 16;
+	case INT32_TYPE:
+	case ENUM_TYPE:
+		return 32;
+	case INT64_TYPE:
+		return 64;
+	default:
+		return -1;
+	}
+}
+
+static struct cp_ctype *parse_argument2(struct parser *P, struct cp_ctype *ct,
+		struct token *name, struct parser *asmname);
+
+/* parses from after the first ( in a function declaration or function pointer
+ * can be one of:
+ * void foo(...) before ...
+ * void (foo)(...) before foo
+ * void (* <>)(...) before <> which is the inner type */
+static struct cp_ctype *parse_function(struct parser *P, struct cp_ctype *ct,
+				struct token *name, struct parser *asmname)
+{
+	/* We have a function pointer or a function. The usr table will
+	 * get replaced by the canonical one (if there is one) in
+	 * find_canonical_usr after all the arguments and returns have
+	 * been parsed. */
+	struct token tok;
+	struct cp_ctype *ret = ct;
+
+	cp_push_ctype(ct);
+
+	memset(ct, 0, sizeof(*ct));
+	ct->base_size = sizeof(void (*)());
+	ct->align_mask = min(FUNCTION_ALIGN_MASK, P->align_mask);
+	ct->type = FUNCTION_TYPE;
+	ct->is_defined = 1;
+
+	if (name->type == TOK_NIL) {
+		for (;;) {
+			require_token(P, &tok);
+
+			if (tok.type == TOK_STAR) {
+				if (ct->type == FUNCTION_TYPE) {
+					ct->type = FUNCTION_PTR_TYPE;
+				} else {
+					increase_ptr_deref_level(P, ct);
+				}
+			} else if (parse_attribute(P, &tok, ct, asmname)) {
+				/* parse_attribute sets the appropriate fields */
+			} else {
+				/* call parse_argument to handle the inner
+				 * contents e.g. the <> in "void (* <>)
+				 * (...)". Note that the inner contents can
+				 * itself be a function, a function ptr,
+				 * array, etc (e.g. "void (*signal(int sig,
+				 * void (*func)(int)))(int)" ). */
+				cp_error("TODO: inner function not supported for now.");
+				put_back(P);
+				ct = parse_argument2(P, ct, name, asmname);
+				break;
+			}
+		}
+
+		check_token(P, TOK_CLOSE_PAREN, NULL,
+			"unexpected token in function on line %d", P->line);
+		check_token(P, TOK_OPEN_PAREN, NULL,
+			"unexpected token in function on line %d", P->line);
+	}
+
+	parse_function_arguments(P, ct);
+
+	/*@TODO support for inner function  24.11 2013 (houqp)*/
+	/* if we have an inner function then set the outer function ptr as its
+	 * return type and return the inner function
+	 * e.g. for void (* <signal(int, void (*)(int))> )(int) inner is
+	 * surrounded by <>, return type is void (*)(int) */
+
+	return ret;
+}
+
+static struct cp_ctype *parse_argument2(struct parser *P, struct cp_ctype *ct,
+				struct token *name, struct parser *asmname)
+{
+	struct token tok;
+
+	for (;;) {
+		if (!next_token(P, &tok)) {
+			/* we've reached the end of the string */
+			break;
+		} else if (tok.type == TOK_STAR) {
+			increase_ptr_deref_level(P, ct);
+
+			/* __declspec(align(#)) may come before the type in a
+			 * member */
+			if (!ct->is_packed) {
+				ct->align_mask = max(min(PTR_ALIGN_MASK, P->align_mask),
+							ct->align_mask);
+			}
+		} else if (tok.type == TOK_REFERENCE) {
+			cp_error("NYI: c++ reference types");
+			return 0;
+		} else if (parse_attribute(P, &tok, ct, asmname)) {
+			/* parse attribute has filled out appropriate fields in type */
+
+		} else if (tok.type == TOK_OPEN_PAREN) {
+			ct = parse_function(P, ct, name, asmname);
+		} else if (tok.type == TOK_OPEN_SQUARE) {
+			/* array */
+			if (ct->pointers == POINTER_MAX) {
+				cp_error("maximum number of pointer derefs "
+					"reached - use a struct to break up "
+					"the pointers");
+			}
+			ct->is_array = 1;
+			ct->pointers++;
+			ct->const_mask <<= 1;
+			require_token(P, &tok);
+
+			if (ct->pointers == 1 && !ct->is_defined) {
+				cp_error("array of undefined type on line %d",
+						P->line);
+			}
+
+			if (ct->is_variable_struct || ct->is_variable_array) {
+				cp_error("can't have an array of a variably "
+					"sized type on line %d", P->line);
+			}
+
+			if (tok.type == TOK_QUESTION) {
+				ct->is_variable_array = 1;
+				ct->variable_increment = (ct->pointers > 1) ?
+						sizeof(void*) : ct->base_size;
+				check_token(P, TOK_CLOSE_SQUARE, "",
+					"invalid character in array on line %d",
+					P->line);
+
+			} else if (tok.type == TOK_CLOSE_SQUARE) {
+				ct->array_size = 0;
+
+			} else if (tok.type == TOK_TOKEN && IS_RESTRICT(tok)) {
+				/* odd gcc extension foo[__restrict] for arguments */
+				ct->array_size = 0;
+				check_token(P, TOK_CLOSE_SQUARE, "",
+					"invalid character in array on line %d",
+					P->line);
+			} else {
+				int64_t asize;
+				put_back(P);
+				asize = calculate_constant(P);
+				if (asize < 0) {
+					cp_error("array size can not be "
+						"negative on line %d", P->line);
+					return 0;
+				}
+				ct->array_size = (size_t) asize;
+				check_token(P, TOK_CLOSE_SQUARE, "",
+					"invalid character in array on line %d",
+					P->line);
+			}
+
+		} else if (tok.type == TOK_COLON) {
+			int64_t bsize = calculate_constant(P);
+
+			if (ct->pointers || bsize < 0
+					|| bsize > max_bitfield_size(ct->type)) {
+				cp_error("invalid bitfield on line %d", P->line);
+			}
+
+			ct->is_bitfield = 1;
+			ct->bit_size = (unsigned) bsize;
+
+		} else if (tok.type != TOK_TOKEN) {
+			/* we've reached the end of the declaration */
+			put_back(P);
+			break;
+
+		} else if (IS_CONST(tok)) {
+			ct->const_mask |= 1;
+
+		} else if (IS_VOLATILE(tok) || IS_RESTRICT(tok)) {
+			/* ignored for now */
+
+		} else {
+			*name = tok;
+		}
+	}
+
+	return ct;
+}
+
+
+
+/* parses after the main base type of a typedef, function argument or
+ * struct/union member
+ * eg for const void* bar[3] the base type is void with the subtype so far of
+ * const, this parses the "* bar[3]" and updates the type argument
+ *
+ * type must be as filled out by parse_type
+ *
+ * pushes the updated user value on the top of the stack
+ */
+void parse_argument(struct parser *P, struct cp_ctype *ct, struct token *pname,
+			struct parser *asmname)
+{
+	struct token tok, name;
+
+	memset(&name, 0, sizeof(name));
+	parse_argument2(P, ct, &name, asmname);
+
+	for (;;) {
+		if (!next_token(P, &tok)) {
+			break;
+		} else if (parse_attribute(P, &tok, ct, asmname)) {
+			/* parse_attribute sets the appropriate fields */
+		} else {
+			put_back(P);
+			break;
+		}
+	}
+
+	if (pname) {
+		*pname = name;
+	}
+}
+
+static void parse_typedef(struct parser *P)
+{
+	struct token tok;
+	struct cp_ctype base_type;
+	char typedef_name[MAX_TYPE_NAME_LEN];
+
+	parse_type(P, &base_type);
+
+	for (;;) {
+		struct cp_ctype arg_type = base_type;
+		struct token name;
+
+		memset(&name, 0, sizeof(name));
+
+		parse_argument(P, &arg_type, &name, NULL);
+
+		if (!name.size) {
+			cp_error("Can't have a typedef without a name on line %d",
+					P->line);
+		} else if (arg_type.is_variable_array) {
+			cp_error("Can't typedef a variable length array on line %d",
+					P->line);
+		}
+
+		memset(typedef_name, 0, sizeof(typedef_name));
+		strncpy(typedef_name, name.str, name.size);
+		/* link typedef name with ctype for parser */
+		cp_ctype_reg_type(typedef_name, &arg_type);
+
+		require_token(P, &tok);
+
+		if (tok.type == TOK_SEMICOLON) {
+			break;
+		} else if (tok.type != TOK_COMMA) {
+			cp_error("Unexpected character in typedef on line %d",
+					P->line);
+		}
+	}
+}
+
+#define END 0
+#define PRAGMA_POP 1
+
+static int parse_root(struct parser *P)
+{
+	struct token tok;
+
+	while (next_token(P, &tok)) {
+		/* we can have:
+		 * struct definition
+		 * enum definition
+		 * union definition
+		 * struct/enum/union declaration
+		 * typedef
+		 * function declaration
+		 * pragma pack
+		 */
+
+		if (tok.type == TOK_SEMICOLON) {
+			/* empty semicolon in root continue on */
+
+		} else if (tok.type == TOK_POUND) {
+
+			check_token(P, TOK_TOKEN, "pragma",
+				"unexpected pre processor directive on line %d",
+				P->line);
+			check_token(P, TOK_TOKEN, "pack",
+				"unexpected pre processor directive on line %d",
+				P->line);
+			check_token(P, TOK_OPEN_PAREN, "",
+				"invalid pack directive on line %d",
+				P->line);
+			require_token(P, &tok);
+
+			if (tok.type == TOK_NUMBER) {
+				if (tok.integer != 1 && tok.integer != 2
+						&& tok.integer != 4
+						&& tok.integer != 8
+						&& tok.integer != 16) {
+					cp_error("pack directive with invalid "
+							"pack size on line %d",
+							P->line);
+					return 0;
+				}
+
+				P->align_mask = (unsigned) (tok.integer - 1);
+				check_token(P, TOK_CLOSE_PAREN, "",
+					"invalid pack directive on line %d",
+					P->line);
+			} else if (tok.type == TOK_TOKEN && IS_LITERAL(tok, "push")) {
+				/*int line = P->line;*/
+				unsigned previous_alignment = P->align_mask;
+
+				check_token(P, TOK_CLOSE_PAREN, "",
+					"invalid pack directive on line %d",
+					P->line);
+
+				if (parse_root(P) != PRAGMA_POP) {
+					cp_error("reached end of string "
+						"without a pragma pop to "
+						"match the push on line %d",
+						P->line);
+					return 0;
+				}
+
+				P->align_mask = previous_alignment;
+
+			} else if (tok.type == TOK_TOKEN && IS_LITERAL(tok, "pop")) {
+				check_token(P, TOK_CLOSE_PAREN, "",
+					"invalid pack directive on line %d",
+						P->line);
+				return PRAGMA_POP;
+			} else {
+				cp_error("invalid pack directive on line %d",
+						P->line);
+				return 0;
+			}
+		} else if (tok.type != TOK_TOKEN) {
+			cp_error("unexpected character on line %d", P->line);
+			return 0;
+		} else if (IS_LITERAL(tok, "__extension__")) {
+			/* ignore */
+			continue;
+		} else if (IS_LITERAL(tok, "extern")) {
+			/* ignore extern as data and functions can only be
+			 * extern */
+			continue;
+		} else if (IS_LITERAL(tok, "typedef")) {
+			parse_typedef(P);
+		} else if (IS_LITERAL(tok, "static")) {
+			/*@TODO we haven't tested static so far */
+			cp_error("TODO: support static keyword.\n");
+		} else {
+			/* type declaration, type definition, or function
+			 * declaration */
+			struct cp_ctype type;
+			struct token name;
+			struct parser asmname;
+
+			memset(&name, 0, sizeof(name));
+			memset(&asmname, 0, sizeof(asmname));
+
+			put_back(P);
+			parse_type(P, &type);
+
+			for (;;) {
+				parse_argument(P, &type, &name, &asmname);
+
+				if (name.size) {
+					/* global/function declaration */
+					cp_symbol_build_func(&type, name.str, name.size);
+					/* @TODO asmname is not used for now
+					 * since we are not supporting __asm__
+					 * as this point.
+					 * might need to bind it with function
+					 * name later. */
+				} else {
+					/* type declaration/definition -
+					 * already been processed */
+				}
+				require_token(P, &tok);
+
+				if (tok.type == TOK_SEMICOLON) {
+					break;
+				} else if (tok.type != TOK_COMMA) {
+					cp_error("missing semicolon on line %d",
+							P->line);
+				}
+			}
+		}
+	}
+
+	return END;
+}
+
+static int64_t calculate_constant2(struct parser *P, struct token *tok);
+
+/* () */
+static int64_t calculate_constant1(struct parser *P, struct token *tok)
+{
+	int64_t ret;
+
+	if (tok->type == TOK_NUMBER) {
+		ret = tok->integer;
+		next_token(P, tok);
+		return ret;
+
+	} else if (tok->type == TOK_TOKEN) {
+		/* look up name in constants table */
+		cp_error("TODO: support name lookup in constant table\n");
+		next_token(P, tok);
+		return ret;
+
+	} else if (tok->type == TOK_OPEN_PAREN) {
+		struct parser before_cast = *P;
+		cp_error("TODO: handle open parent token in constant1\n");
+		*P = before_cast;
+		ret = calculate_constant(P);
+
+		require_token(P, tok);
+		if (tok->type != TOK_CLOSE_PAREN) {
+			cp_error("error whilst parsing constant at line %d",
+					P->line);
+		}
+
+		next_token(P, tok);
+		return ret;
+	} else {
+		cp_error("unexpected token whilst parsing constant at line %d",
+				P->line);
+		return 0;
+	}
+}
+
+/* ! and ~, unary + and -, and sizeof */
+static int64_t calculate_constant2(struct parser *P, struct token *tok)
+{
+	if (tok->type == TOK_LOGICAL_NOT) {
+		require_token(P, tok);
+		return !calculate_constant2(P, tok);
+
+	} else if (tok->type == TOK_BITWISE_NOT) {
+		require_token(P, tok);
+		return ~calculate_constant2(P, tok);
+
+	} else if (tok->type == TOK_PLUS) {
+		require_token(P, tok);
+		return calculate_constant2(P, tok);
+
+	} else if (tok->type == TOK_MINUS) {
+		require_token(P, tok);
+		return -calculate_constant2(P, tok);
+
+	} else if (tok->type == TOK_TOKEN &&
+			(IS_LITERAL(*tok, "sizeof")
+			 || IS_LITERAL(*tok, "alignof")
+			 || IS_LITERAL(*tok, "__alignof__")
+			 || IS_LITERAL(*tok, "__alignof"))) {
+		cp_error("TODO: support sizeof\n");
+		bool issize = IS_LITERAL(*tok, "sizeof");
+		struct cp_ctype type;
+
+		require_token(P, tok);
+		if (tok->type != TOK_OPEN_PAREN) {
+			cp_error("invalid sizeof at line %d", P->line);
+		}
+
+		parse_type(P, &type);
+		parse_argument(P, &type, NULL, NULL);
+
+		require_token(P, tok);
+		if (tok->type != TOK_CLOSE_PAREN) {
+			cp_error("invalid sizeof at line %d", P->line);
+		}
+
+		next_token(P, tok);
+
+		return issize ? ctype_size(&type) : type.align_mask + 1;
+
+	} else {
+		return calculate_constant1(P, tok);
+	}
+}
+
+/* binary * / and % (left associative) */
+static int64_t calculate_constant3(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant2(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_MULTIPLY) {
+			require_token(P, tok);
+			left *= calculate_constant2(P, tok);
+
+		} else if (tok->type == TOK_DIVIDE) {
+			require_token(P, tok);
+			left /= calculate_constant2(P, tok);
+
+		} else if (tok->type == TOK_MODULUS) {
+			require_token(P, tok);
+			left %= calculate_constant2(P, tok);
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary + and - (left associative) */
+static int64_t calculate_constant4(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant3(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_PLUS) {
+			require_token(P, tok);
+			left += calculate_constant3(P, tok);
+
+		} else if (tok->type == TOK_MINUS) {
+			require_token(P, tok);
+			left -= calculate_constant3(P, tok);
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary << and >> (left associative) */
+static int64_t calculate_constant5(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant4(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_LEFT_SHIFT) {
+			require_token(P, tok);
+			left <<= calculate_constant4(P, tok);
+
+		} else if (tok->type == TOK_RIGHT_SHIFT) {
+			require_token(P, tok);
+			left >>= calculate_constant4(P, tok);
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary <, <=, >, and >= (left associative) */
+static int64_t calculate_constant6(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant5(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_LESS) {
+			require_token(P, tok);
+			left = (left < calculate_constant5(P, tok));
+
+		} else if (tok->type == TOK_LESS_EQUAL) {
+			require_token(P, tok);
+			left = (left <= calculate_constant5(P, tok));
+
+		} else if (tok->type == TOK_GREATER) {
+			require_token(P, tok);
+			left = (left > calculate_constant5(P, tok));
+
+		} else if (tok->type == TOK_GREATER_EQUAL) {
+			require_token(P, tok);
+			left = (left >= calculate_constant5(P, tok));
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary ==, != (left associative) */
+static int64_t calculate_constant7(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant6(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_EQUAL) {
+			require_token(P, tok);
+			left = (left == calculate_constant6(P, tok));
+
+		} else if (tok->type == TOK_NOT_EQUAL) {
+			require_token(P, tok);
+			left = (left != calculate_constant6(P, tok));
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary & (left associative) */
+static int64_t calculate_constant8(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant7(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_BITWISE_AND) {
+			require_token(P, tok);
+			left = (left & calculate_constant7(P, tok));
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary ^ (left associative) */
+static int64_t calculate_constant9(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant8(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_BITWISE_XOR) {
+			require_token(P, tok);
+			left = (left ^ calculate_constant8(P, tok));
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary | (left associative) */
+static int64_t calculate_constant10(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant9(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_BITWISE_OR) {
+			require_token(P, tok);
+			left = (left | calculate_constant9(P, tok));
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary && (left associative) */
+static int64_t calculate_constant11(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant10(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_LOGICAL_AND) {
+			require_token(P, tok);
+			left = (left && calculate_constant10(P, tok));
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* binary || (left associative) */
+static int64_t calculate_constant12(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant11(P, tok);
+
+	for (;;) {
+		if (tok->type == TOK_LOGICAL_OR) {
+			require_token(P, tok);
+			left = (left || calculate_constant11(P, tok));
+
+		} else {
+			return left;
+		}
+	}
+}
+
+/* ternary ?: (right associative) */
+static int64_t calculate_constant13(struct parser *P, struct token *tok)
+{
+	int64_t left = calculate_constant12(P, tok);
+
+	if (tok->type == TOK_QUESTION) {
+		int64_t middle, right;
+		require_token(P, tok);
+		middle = calculate_constant13(P, tok);
+		if (tok->type != TOK_COLON) {
+			cp_error("invalid ternery (? :) in constant on line %d",
+					P->line);
+		}
+		require_token(P, tok);
+		right = calculate_constant13(P, tok);
+		return left ? middle : right;
+
+	} else {
+		return left;
+	}
+}
+
+int64_t calculate_constant(struct parser* P)
+{
+	struct token tok;
+	int64_t ret;
+	require_token(P, &tok);
+	ret = calculate_constant13(P, &tok);
+
+	if (tok.type != TOK_NIL) {
+		put_back(P);
+	}
+
+	return ret;
+}
+
+void cp_init_parser(struct parser *P, const char *s)
+{
+	memset(P, 0, sizeof(struct parser));
+	P->line = 1;
+	P->prev = P->next = s;
+	P->align_mask = DEFAULT_ALIGN_MASK;
+}
+
+/* used for ffi.cdef */
+int ffi_parse_cdef(const char *s)
+{
+	struct parser P;
+
+	cp_init_parser(&P, s);
+	if (parse_root(&P) == PRAGMA_POP) {
+		cp_error("pragma pop without an associated push on line %d",
+				P.line);
+	}
+
+	return 0;
+}
+
+/* used for ffi.new */
+void ffi_parse_new(const char *s, struct cp_ctype *ct)
+{
+	struct parser P;
+
+	cp_init_parser(&P, s);
+	parse_type(&P, ct);
+	parse_argument(&P, ct, NULL, NULL);
+	cp_update_csym_in_ctype(ct);
+}
+
+int ffi_lookup_csymbol_id_by_name(const char *s)
+{
+	struct parser P;
+	struct cp_ctype ct;
+
+	cp_init_parser(&P, s);
+	parse_type(&P, &ct);
+	cp_update_csym_in_ctype(&ct);
+	return ct.ffi_cs_id;
+}
+
+void ffi_cparser_init(void)
+{
+	cp_ctype_init();
+}
+
+void ffi_cparser_free(void)
+{
+	cp_ctype_free();
+}
diff --git a/tools/ktap/ffi/ctype.c b/tools/ktap/ffi/ctype.c
new file mode 100644
index 0000000..4e69b3e
--- /dev/null
+++ b/tools/ktap/ffi/ctype.c
@@ -0,0 +1,632 @@
+#include "../../include/ktap_types.h"
+#include "../../include/ktap_opcodes.h"
+#include "../ktapc.h"
+#include "../cparser.h"
+
+
+/* for ktap vm */
+cp_csymbol_state csym_state;
+
+#define cs_nr (csym_state.cs_nr)
+#define cs_arr_size (csym_state.cs_arr_size)
+#define cs_arr (csym_state.cs_arr)
+
+csymbol *cp_id_to_csym(int id)
+{
+	return &cs_arr[id];
+}
+
+
+typedef struct cp_ctype_entry {
+	char name[MAX_TYPE_NAME_LEN];
+	struct cp_ctype ct;
+} cp_ctype_entry;
+
+#define DEFAULT_CTYPE_ARR_SIZE 100
+static int cte_nr;
+static int cte_arr_size;
+static cp_ctype_entry *cte_arr;
+
+
+/* stack to help maintain state during parsing */
+typedef struct cp_ctype_stack {
+	int size;
+	int top;
+	cp_ctype_entry *stack;
+} ctype_stack;
+
+
+static ctype_stack cts;
+
+#define ct_stack(id) (&(cts.stack[id]))
+#define ct_stack_ct(id) (&(cts.stack[id].ct))
+
+
+
+csymbol_id cp_ctype_reg_csymbol(csymbol *cs);
+csymbol_id ctype_lookup_csymbol_id(const char *name);
+
+
+size_t ctype_size(const struct cp_ctype *ct)
+{
+	if (ct->pointers - ct->is_array) {
+		return sizeof(void*) * (ct->is_array ? ct->array_size : 1);
+
+	} else if (!ct->is_defined || ct->type == VOID_TYPE) {
+		cp_error("can't calculate size of an undefined type");
+		return 0;
+	} else if (ct->variable_size_known) {
+		assert(ct->is_variable_struct && !ct->is_array);
+		return ct->base_size + ct->variable_increment;
+	} else if (ct->is_variable_array || ct->is_variable_struct) {
+		cp_error("internal error: calc size of variable type with "
+				"unknown size");
+		return 0;
+	} else {
+		return ct->base_size * (ct->is_array ? ct->array_size : 1);
+	}
+}
+
+#define MAX_STACK_SIZE 100
+int ctype_stack_grow(int size)
+{
+	struct cp_ctype_entry *new_st;
+
+	assert(cts.size + size < MAX_STACK_SIZE);
+
+	new_st = realloc(cts.stack, (cts.size+size)*sizeof(cp_ctype_entry));
+	if (new_st)
+		cts.stack = new_st;
+	else
+		return -1;
+
+	cts.size += size;
+
+	return size;
+}
+
+int ctype_stack_free_space()
+{
+	return cts.size - cts.top;
+}
+
+int ctype_stack_top()
+{
+	return cts.top;
+}
+
+void ctype_stack_reset(int top)
+{
+	cts.top = top;
+}
+
+/* This function should be called before you would fetch
+ * ffi_cs_id from ctype */
+void cp_update_csym_in_ctype(struct cp_ctype *ct)
+{
+	int i;
+	struct cp_ctype *nct;
+
+	assert(ct->ffi_cs_id >= 0);
+	/* we have to check pointer here because cparser does type lookup by name
+	 * before parsing '*', and for pointers, ct will always be the
+	 * original type */
+	if (ct->pointers) {
+		for (i = 0; i < cte_nr; i++) {
+			nct = &(cte_arr[i].ct);
+			if (nct->type == ct->type &&
+					ct->ffi_base_cs_id == nct->ffi_base_cs_id &&
+					nct->pointers == ct->pointers) {
+				break;
+			}
+		}
+
+		if (i == cte_nr) {
+			/* pointer type not found
+			 * create a new pointer symbol for this type */
+			/* associate ctype with new csymbol */
+			ct->ffi_cs_id = cp_symbol_build_pointer(ct);
+			/* register wit new pointer name */
+			cp_ctype_reg_type(csym_name(ct_ffi_cs(ct)), ct);
+		} else {
+			/* pointer type already registered, reinstantiate ct */
+			ct->ffi_cs_id = cte_arr[i].ct.ffi_cs_id;
+		}
+	}
+}
+
+/* push ctype to stack, create new csymbol if needed */
+void cp_push_ctype_with_name(struct cp_ctype *ct, const char *name, int nlen)
+{
+	if (ctype_stack_free_space() < 1)
+		ctype_stack_grow(4);
+
+	cp_update_csym_in_ctype(ct);
+	memset(ct_stack(cts.top), 0, sizeof(cp_ctype_entry));
+	ct_stack(cts.top)->ct = *ct;
+	if (name)
+		strncpy(ct_stack(cts.top)->name, name, nlen);
+	cts.top++;
+}
+
+void cp_push_ctype(struct cp_ctype *ct)
+{
+	cp_push_ctype_with_name(ct, NULL, 0);
+}
+
+void cp_set_defined(struct cp_ctype *ct)
+{
+	ct->is_defined = 1;
+
+	/* @TODO: update ctypes and cdatas that were created before the
+	 * definition came in */
+}
+
+void cp_ctype_dump_stack()
+{
+	int i;
+	struct cp_ctype *ct;
+
+	printf("---------------------------\n");
+	printf("start of ctype stack (%d) dump: \n", cts.top);
+	for (i = 0; i < cts.top; i++) {
+		ct = ct_stack_ct(i);
+		printf("[%d] -> cp_ctype: %d, sym_type: %d, pointer: %d "
+			"symbol_id: %d, name: %s\n",
+			i, ct->type,
+			csym_type(ct_ffi_cs(ct)), ct->pointers, ct->ffi_cs_id,
+			ct_stack(i)->name);
+	}
+}
+
+int ctype_reg_table_grow()
+{
+	cp_ctype_entry *new_arr;
+
+	new_arr = realloc(cte_arr, sizeof(cp_ctype_entry)*cte_arr_size*2);
+	if (!new_arr)
+		cp_error("failed to allocate memory for ctype array\n");
+
+	cte_arr_size = cte_arr_size * 2;
+	return 0;
+}
+
+/* return index in csymbol array */
+csymbol_id cp_ctype_reg_csymbol(csymbol *cs)
+{
+	if (cs_nr >= cs_arr_size) {
+		cs_arr_size *= 2;
+		cs_arr = realloc(cs_arr, cs_arr_size*sizeof(csymbol));
+		if (!cs_arr)
+			cp_error("failed to extend csymbol array!\n");
+	}
+
+	cs_arr[cs_nr] = *cs;
+	cs_nr++;
+
+	return cs_nr-1;
+}
+
+/* start csymbol reg table */
+csymbol_id ctype_lookup_csymbol_id(const char *name)
+{
+	int i;
+	csymbol *ct;
+
+	for (i = 0; i < cs_nr; i++) {
+		ct = cp_id_to_csym(i);
+		if (!strcmp(name, ct->name))
+			return i;
+	}
+
+	return -1;
+}
+
+void __cp_symbol_dump_struct(csymbol *cs)
+{
+	int i;
+	csymbol *ncs;
+	csymbol_struct *stcs = csym_struct(cs);
+
+	printf("=== [%s] definition ==================\n", csym_name(cs));
+	for (i = 0; i < stcs->memb_nr; i++) {
+		printf("\t(%d) ", i);
+		printf("csym_id: %d, ", stcs->members[i].id);
+		ncs = cp_id_to_csym(stcs->members[i].id);
+		printf("name: %s, ffi_ctype: %d, %s\n",
+			stcs->members[i].name, ncs->type, csym_name(ncs));
+	}
+}
+
+void cp_symbol_dump_struct(int id)
+{
+	__cp_symbol_dump_struct(cp_id_to_csym(id));
+}
+
+int cp_symbol_build_record(const char *stname, int type, int start_top)
+{
+	int i, id, memb_size;
+	cp_ctype_entry *cte;
+	csymbol nst;
+	struct_member *st_membs;
+	csymbol_struct *stcs;
+	struct cp_ctype *ct;
+
+	if (cts.top <= start_top || !stname ||
+			(type != STRUCT_TYPE && type != UNION_TYPE)) {
+		cp_error("invalid struct/union definition.\n");
+	}
+
+	id = ctype_lookup_csymbol_id(stname);
+	if (id >= 0) {
+		assert(cp_id_to_csym(id)->type == FFI_STRUCT ||
+				cp_id_to_csym(id)->type == FFI_UNION);
+		assert(csym_struct(cp_id_to_csym(id))->memb_nr == -1);
+	}
+
+	memb_size = cts.top - start_top;
+	st_membs = malloc(memb_size*sizeof(struct_member));
+	if (!st_membs)
+		cp_error("failed to allocate memory for struct members.\n");
+	memset(st_membs, 0, memb_size*sizeof(struct_member));
+
+	if (type == STRUCT_TYPE)
+		nst.type = FFI_STRUCT;
+	else
+		nst.type = FFI_UNION;
+	strcpy(nst.name, stname);
+
+	stcs = csym_struct(&nst);
+	stcs->align = 0;
+	stcs->memb_nr = memb_size;
+	stcs->members = st_membs;
+
+	for (i = 0; i < memb_size; i++) {
+		cte = ct_stack(i + start_top);
+		if (cte->name)
+			strcpy(st_membs[i].name, cte->name);
+		ct = ct_stack_ct(i + start_top);
+		st_membs[i].id = ct->ffi_cs_id;
+		if (!ct->is_array)
+			st_membs[i].len = -1;
+		else
+			st_membs[i].len = ct->array_size;
+	}
+
+	if (id < 0)
+		id = cp_ctype_reg_csymbol(&nst);
+	else
+		cs_arr[id] = nst;
+
+	ctype_stack_reset(start_top);
+
+	return id;
+}
+
+int cp_symbol_build_fake_record(const char *stname, int type)
+{
+	int id;
+	csymbol nst;
+	csymbol_struct *stcs;
+
+	if (!stname || (type != STRUCT_TYPE && type != UNION_TYPE)) {
+		cp_error("invalid fake struct/union definition.\n");
+	}
+
+	id = ctype_lookup_csymbol_id(stname);
+	if (id >= 0)
+		return id;
+
+	if (type == STRUCT_TYPE)
+		nst.type = FFI_STRUCT;
+	else
+		nst.type = FFI_UNION;
+	strcpy(nst.name, stname);
+
+	stcs = csym_struct(&nst);
+	stcs->align = 0;
+	stcs->memb_nr = -1;
+	stcs->members = NULL;
+
+	id = cp_ctype_reg_csymbol(&nst);
+
+	return id;
+}
+
+
+/* build pointer symbol from given csymbol */
+int cp_symbol_build_pointer(struct cp_ctype *ct)
+{
+	int id, ret;
+	csymbol ncspt;
+	csymbol *ref_cs = ct_ffi_cs(ct);
+
+	/* TODO: Check correctness of multi-level pointer 24.11.2013(unihorn) */
+	memset(&ncspt, 0, sizeof(csymbol));
+	ncspt.type = FFI_PTR;
+	ret = sprintf(ncspt.name, "%s *", csym_name(ref_cs));
+	assert(ret < MAX_TYPE_NAME_LEN);
+
+	csym_set_ptr_deref_id(&ncspt, ct->ffi_cs_id);
+	id = cp_ctype_reg_csymbol(&ncspt);
+
+	return id;
+}
+
+void __cp_symbol_dump_func(csymbol *cs)
+{
+	int i;
+	csymbol *ncs;
+	csymbol_func *fcs = csym_func(cs);
+
+	printf("=== [%s] function definition =============\n", csym_name(cs));
+	ncs = cp_csymf_ret(fcs);
+	printf("address: %p\n", fcs->addr);
+	printf("return type: \n");
+	printf("\tcsym_id: %d, ffi_ctype: %d, %s\n",
+			fcs->ret_id, ncs->type, csym_name(ncs));
+	printf("args type (%d): \n", fcs->arg_nr);
+	for (i = 0; i < csymf_arg_nr(fcs); i++) {
+	    printf("\t (%d) ", i);
+	    printf("csym_id: %d, ", fcs->arg_ids[i]);
+	    ncs = cp_csymf_arg(fcs, i);
+	    printf("ffi_ctype: %d, %s\n", ncs->type, csym_name(ncs));
+	}
+}
+
+void cp_symbol_dump_func(int id)
+{
+	__cp_symbol_dump_func(cp_id_to_csym(id));
+}
+
+int cp_symbol_build_func(struct cp_ctype *type, const char *fname, int fn_size)
+{
+	int i = 1, arg_nr, id;
+	int *argsym_id_arr;
+	csymbol nfcs;
+	csymbol_func *fcs;
+
+	if (cts.top == 0 || fn_size < 0 || !fname) {
+		cp_error("invalid function definition.\n");
+	}
+
+	argsym_id_arr = NULL;
+	memset(&nfcs, 0, sizeof(csymbol));
+	csym_type(&nfcs) = FFI_FUNC;
+
+	strncpy(csym_name(&nfcs), fname, fn_size);
+
+	fcs = csym_func(&nfcs);
+	fcs->has_var_arg = type->has_var_arg;
+	/* Type needed for handling variable args handle */
+	if (fcs->has_var_arg && !ctype_lookup_type("void *"))
+		cp_symbol_build_pointer(ctype_lookup_type("void"));
+
+	/* Fetch start address of function  */
+	fcs->addr = (void *)find_kernel_symbol(csym_name(&nfcs));
+	if (!fcs->addr)
+		cp_error("wrong function address for %s\n", csym_name(&nfcs));
+
+	/* bottom of the stack is return type */
+	fcs->ret_id = ct_stack_ct(0)->ffi_cs_id;
+
+	/* the rest is argument type */
+	if (cts.top == 1) {
+		/* function takes no argument */
+		arg_nr = 0;
+	} else {
+		arg_nr = cts.top - 1;
+		argsym_id_arr = malloc(arg_nr * sizeof(int));
+		if (!argsym_id_arr)
+			cp_error("failed to allocate memory for function args.\n");
+		for (i = 0; i < arg_nr; i++) {
+			argsym_id_arr[i] = ct_stack_ct(i+1)->ffi_cs_id;
+		}
+	}
+	fcs->arg_nr = arg_nr;
+	fcs->arg_ids = argsym_id_arr;
+
+	id = cp_ctype_reg_csymbol(&nfcs);
+
+	/* clear stack since we have consumed all the ctypes */
+	ctype_stack_reset(0);
+
+	return id;
+}
+
+struct cp_ctype *cp_ctype_reg_type(char *name, struct cp_ctype *ct)
+{
+	if (cte_nr >= cte_arr_size)
+		ctype_reg_table_grow();
+
+	memset(cte_arr[cte_nr].name, 0, MAX_TYPE_NAME_LEN);
+	strcpy(cte_arr[cte_nr].name, name);
+
+	cte_arr[cte_nr].ct = *ct;
+	cte_nr++;
+
+	return &(cte_arr[cte_nr-1].ct);
+}
+
+#if 0
+/* TODO: used for size calculation */
+static ffi_type ffi_int_type(ktap_state *ks, int size, bool sign)
+{
+	switch(size) {
+	case 1:
+		if (!sign)
+			return FFI_UINT8;
+		else
+			return FFI_INT8;
+	case 2:
+		if (!sign)
+			return FFI_UINT16;
+		else
+			return FFI_INT16;
+	case 4:
+		if (!sign)
+			return FFI_UINT32;
+		else
+			return FFI_INT32;
+	case 8:
+		if (!sign)
+			return FFI_UINT64;
+		else
+			return FFI_INT64;
+	default:
+		kp_error(ks, "Error: Have not support int type of size %d\n", size);
+		return FFI_UNKNOWN;
+	}
+
+	/* NEVER reach here, silence compiler */
+	return -1;
+}
+#endif
+
+
+static inline void ct_set_type(struct cp_ctype *ct, int type, int is_unsigned)
+{
+	ct->type = type;
+	ct->is_unsigned = is_unsigned;
+}
+
+static void init_builtin_type(struct cp_ctype *ct, ffi_type ftype)
+{
+	csymbol cs;
+	int cs_id;
+
+	csym_type(&cs) = ftype;
+	strncpy(csym_name(&cs), ffi_type_name(ftype), CSYM_NAME_MAX_LEN);
+	cs_id = cp_ctype_reg_csymbol(&cs);
+
+	memset(ct, 0, sizeof(*ct));
+	ct->ffi_base_cs_id = ct->ffi_cs_id = cs_id;
+	switch (ftype) {
+	case FFI_VOID:		ct_set_type(ct, VOID_TYPE, 0); break;
+	case FFI_UINT8:		ct_set_type(ct, INT8_TYPE, 1); break;
+	case FFI_INT8:		ct_set_type(ct, INT8_TYPE, 0); break;
+	case FFI_UINT16:	ct_set_type(ct, INT16_TYPE, 1); break;
+	case FFI_INT16:		ct_set_type(ct, INT16_TYPE, 0); break;
+	case FFI_UINT32:	ct_set_type(ct, INT32_TYPE, 1); break;
+	case FFI_INT32:		ct_set_type(ct, INT32_TYPE, 0); break;
+	case FFI_UINT64:	ct_set_type(ct, INT64_TYPE, 1); break;
+	case FFI_INT64:		ct_set_type(ct, INT64_TYPE, 0); break;
+	default:		break;
+	}
+	ct->base_size = ffi_type_size(ftype);
+	ct->align_mask = ffi_type_align(ftype) - 1;
+	ct->is_defined = 1;
+}
+
+/*
+ * lookup and register builtin C type on demand
+ * You should ensure that the type with name doesn't appear in
+ * csymbol table before calling.
+ */
+struct cp_ctype *ctype_lookup_builtin_type(char *name)
+{
+	struct cp_ctype ct;
+
+	if (!strncmp(name, "void", sizeof("void"))) {
+		init_builtin_type(&ct, FFI_VOID);
+		return cp_ctype_reg_type("void", &ct);
+	} else if (!strncmp(name, "int8_t", sizeof("int8_t"))) {
+		init_builtin_type(&ct, FFI_INT8);
+		return cp_ctype_reg_type("int8_t", &ct);
+	} else if (!strncmp(name, "uint8_t", sizeof("uint8_t"))) {
+		init_builtin_type(&ct, FFI_UINT8);
+		return cp_ctype_reg_type("uint8_t", &ct);
+	} else if (!strncmp(name, "int16_t", sizeof("int16_t"))) {
+		init_builtin_type(&ct, FFI_INT16);
+		return cp_ctype_reg_type("int16_t", &ct);
+	} else if (!strncmp(name, "uint16_t", sizeof("uint16_t"))) {
+		init_builtin_type(&ct, FFI_UINT16);
+		return cp_ctype_reg_type("uint16_t", &ct);
+	} else if (!strncmp(name, "int32_t", sizeof("int32_t"))) {
+		init_builtin_type(&ct, FFI_INT32);
+		return cp_ctype_reg_type("int32_t", &ct);
+	} else if (!strncmp(name, "uint32_t", sizeof("uint32_t"))) {
+		init_builtin_type(&ct, FFI_UINT32);
+		return cp_ctype_reg_type("uint32_t", &ct);
+	} else if (!strncmp(name, "int64_t", sizeof("int64_t"))) {
+		init_builtin_type(&ct, FFI_INT64);
+		return cp_ctype_reg_type("int64_t", &ct);
+	} else if (!strncmp(name, "uint64_t", sizeof("uint64_t"))) {
+		init_builtin_type(&ct, FFI_UINT64);
+		return cp_ctype_reg_type("uint64_t", &ct);
+	} else {
+		/* no builtin type matched */
+		return NULL;
+	}
+}
+
+/* start ctype reg table */
+struct cp_ctype *ctype_lookup_type(char *name)
+{
+	int i;
+	struct cp_ctype *ct;
+
+	for (i = 0; i < cte_nr; i++) {
+		ct = &cte_arr[i].ct;
+		if (!strcmp(name, cte_arr[i].name))
+			return ct;
+	}
+
+	/* see if it's a builtin C type
+	 * return NULL if still no match */
+	return ctype_lookup_builtin_type(name);
+}
+
+cp_csymbol_state *ctype_get_csym_state(void)
+{
+	return &csym_state;
+}
+
+#define DEFAULT_STACK_SIZE 20
+#define DEFAULT_SYM_ARR_SIZE 20
+int cp_ctype_init()
+{
+	cts.size = DEFAULT_STACK_SIZE;
+	cts.top = 0;
+	cts.stack = malloc(sizeof(cp_ctype_entry)*DEFAULT_STACK_SIZE);
+
+	cs_nr = 0;
+	cs_arr_size = DEFAULT_SYM_ARR_SIZE;
+	cs_arr = malloc(sizeof(csymbol)*DEFAULT_SYM_ARR_SIZE);
+	memset(cs_arr, 0, sizeof(csymbol)*DEFAULT_SYM_ARR_SIZE);
+
+	cte_nr = 0;
+	cte_arr_size = DEFAULT_CTYPE_ARR_SIZE;
+	cte_arr = malloc(sizeof(cp_ctype_entry)*DEFAULT_CTYPE_ARR_SIZE);
+
+	return 0;
+}
+
+int cp_ctype_free()
+{
+	int i;
+	csymbol *cs;
+
+	if (cts.stack)
+		free(cts.stack);
+
+	if (cs_arr) {
+		for (i = 0; i < cs_nr; i++) {
+			cs = cp_id_to_csym(i);
+			if (csym_type(cs) == FFI_FUNC) {
+				if (csym_func(cs)->arg_ids)
+					free(csym_func(cs)->arg_ids);
+			} else if (csym_type(cs) == FFI_STRUCT) {
+				if (csym_struct(cs)->members)
+					free(csym_struct(cs)->members);
+			}
+		}
+		free(cs_arr);
+	}
+
+	if (cte_arr) {
+		free(cte_arr);
+	}
+
+	return 0;
+}
diff --git a/tools/ktap/kp_bcwrite.c b/tools/ktap/kp_bcwrite.c
new file mode 100644
index 0000000..65a6e36
--- /dev/null
+++ b/tools/ktap/kp_bcwrite.c
@@ -0,0 +1,376 @@
+/*
+ * Bytecode writer
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2012-2013 Jovi Zhangwei <jovi.zhangwei@gmail.com>.
+ *
+ * Copyright (C) 1994-2013 Lua.org, PUC-Rio.
+ *  - The part of code in this file is copied from lua initially.
+ *  - lua's MIT license is compatible with GPL.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <ktap/ktap_types.h>
+#include "cparser.h"
+#include "kp_util.h"
+
+/* Context for bytecode writer. */
+typedef struct BCWriteCtx {
+	SBuf sb;		/* Output buffer. */
+	ktap_proto_t *pt;	/* Root prototype. */
+	ktap_writer wfunc;	/* Writer callback. */
+	void *wdata;		/* Writer callback data. */
+	int strip;		/* Strip debug info. */
+	int status;		/* Status from writer callback. */
+} BCWriteCtx;
+
+
+static char *bcwrite_uint32(char *p, uint32_t v)
+{
+	memcpy(p, &v, sizeof(uint32_t));
+	p += sizeof(uint32_t);
+	return p;
+}
+
+/* -- Bytecode writer ----------------------------------------------------- */
+
+/* Write a single constant key/value of a template table. */
+static void bcwrite_ktabk(BCWriteCtx *ctx, const ktap_val_t *o, int narrow)
+{
+	char *p = kp_buf_more(&ctx->sb, 1+10);
+	if (is_string(o)) {
+		const ktap_str_t *str = rawtsvalue(o);
+		int len = str->len;
+		p = kp_buf_more(&ctx->sb, 5+len);
+		p = bcwrite_uint32(p, BCDUMP_KTAB_STR+len);
+		p = kp_buf_wmem(p, getstr(str), len);
+	} else if (is_number(o)) {
+		p = bcwrite_uint32(p, BCDUMP_KTAB_NUM);
+		p = kp_buf_wmem(p, &nvalue(o), sizeof(ktap_number));
+	} else {
+		kp_assert(tvispri(o));
+		p = bcwrite_uint32(p, BCDUMP_KTAB_NIL+~itype(o));
+	}
+	setsbufP(&ctx->sb, p);
+}
+
+/* Write a template table. */
+static void bcwrite_ktab(BCWriteCtx *ctx, char *p, const ktap_tab_t *t)
+{
+	int narray = 0, nhash = 0;
+	if (t->asize > 0) {  /* Determine max. length of array part. */
+		ptrdiff_t i;
+		ktap_val_t *array = t->array;
+		for (i = (ptrdiff_t)t->asize-1; i >= 0; i--)
+			if (!is_nil(&array[i]))
+				break;
+			narray = (int)(i+1);
+	}
+	if (t->hmask > 0) {  /* Count number of used hash slots. */
+		int i, hmask = t->hmask;
+		ktap_node_t *node = t->node;
+		for (i = 0; i <= hmask; i++)
+			nhash += !is_nil(&node[i].val);
+	}
+	/* Write number of array slots and hash slots. */
+	p = bcwrite_uint32(p, narray);
+	p = bcwrite_uint32(p, nhash);
+	setsbufP(&ctx->sb, p);
+	if (narray) {  /* Write array entries (may contain nil). */
+		int i;
+		ktap_val_t *o = t->array;
+		for (i = 0; i < narray; i++, o++)
+			bcwrite_ktabk(ctx, o, 1);
+	}
+	if (nhash) {  /* Write hash entries. */
+		int i = nhash;
+		ktap_node_t *node = t->node + t->hmask;
+		for (;; node--)
+			if (!is_nil(&node->val)) {
+				bcwrite_ktabk(ctx, &node->key, 0);
+				bcwrite_ktabk(ctx, &node->val, 1);
+				if (--i == 0)
+					break;
+			}
+	}
+}
+
+/* Write GC constants of a prototype. */
+static void bcwrite_kgc(BCWriteCtx *ctx, ktap_proto_t *pt)
+{
+	int i, sizekgc = pt->sizekgc;
+	ktap_obj_t **kr = (ktap_obj_t **)pt->k - (ptrdiff_t)sizekgc;
+
+	for (i = 0; i < sizekgc; i++, kr++) {
+		ktap_obj_t *o = *kr;
+		int tp, need = 1;
+		char *p;
+
+		/* Determine constant type and needed size. */
+		if (o->gch.gct == ~KTAP_TSTR) {
+			tp = BCDUMP_KGC_STR + ((ktap_str_t *)o)->len;
+			need = 5 + ((ktap_str_t *)o)->len;
+		} else if (o->gch.gct == ~KTAP_TPROTO) {
+			kp_assert((pt->flags & PROTO_CHILD));
+			tp = BCDUMP_KGC_CHILD;
+		} else {
+			kp_assert(o->gch.gct == ~KTAP_TTAB);
+			tp = BCDUMP_KGC_TAB;
+			need = 1+2*5;
+		}
+
+		/* Write constant type. */
+		p = kp_buf_more(&ctx->sb, need);
+		p = bcwrite_uint32(p, tp);
+		/* Write constant data (if any). */
+		if (tp >= BCDUMP_KGC_STR) {
+			p = kp_buf_wmem(p, getstr((ktap_str_t *)o),
+					((ktap_str_t *)o)->len);
+		} else if (tp == BCDUMP_KGC_TAB) {
+			bcwrite_ktab(ctx, p, (ktap_tab_t *)o);
+			continue;
+		}
+		setsbufP(&ctx->sb, p);
+	}
+}
+
+/* Write number constants of a prototype. */
+static void bcwrite_knum(BCWriteCtx *ctx, ktap_proto_t *pt)
+{
+	int i, sizekn = pt->sizekn;
+	const ktap_val_t *o = (ktap_val_t *)pt->k;
+	char *p = kp_buf_more(&ctx->sb, 10*sizekn);
+
+	for (i = 0; i < sizekn; i++, o++) {
+		if (is_number(o))
+			p = kp_buf_wmem(p, &nvalue(o), sizeof(ktap_number));
+	}
+	setsbufP(&ctx->sb, p);
+}
+
+/* Write bytecode instructions. */
+static char *bcwrite_bytecode(BCWriteCtx *ctx, char *p, ktap_proto_t *pt)
+{
+	int nbc = pt->sizebc-1;  /* Omit the [JI]FUNC* header. */
+
+	p = kp_buf_wmem(p, proto_bc(pt)+1, nbc*(int)sizeof(BCIns));
+	return p;
+}
+
+/* Write prototype. */
+static void bcwrite_proto(BCWriteCtx *ctx, ktap_proto_t *pt)
+{
+	int sizedbg = 0;
+	char *p;
+
+	/* Recursively write children of prototype. */
+	if (pt->flags & PROTO_CHILD) {
+		ptrdiff_t i, n = pt->sizekgc;
+		ktap_obj_t **kr = (ktap_obj_t **)pt->k - 1;
+		for (i = 0; i < n; i++, kr--) {
+			ktap_obj_t *o = *kr;
+			if (o->gch.gct == ~KTAP_TPROTO)
+				bcwrite_proto(ctx, (ktap_proto_t *)o);
+		}
+	}
+
+	/* Start writing the prototype info to a buffer. */
+	p = kp_buf_need(&ctx->sb,
+		5+4+6*5+(pt->sizebc-1)*(int)sizeof(BCIns)+pt->sizeuv*2);
+	p += 4;  /* Leave room for final size. */
+
+	/* Write prototype header. */
+	*p++ = (pt->flags & (PROTO_CHILD|PROTO_VARARG|PROTO_FFI));
+	*p++ = pt->numparams;
+	*p++ = pt->framesize;
+	*p++ = pt->sizeuv;
+	p = bcwrite_uint32(p, pt->sizekgc);
+	p = bcwrite_uint32(p, pt->sizekn);
+	p = bcwrite_uint32(p, pt->sizebc-1);
+	if (!ctx->strip) {
+		if (proto_lineinfo(pt))
+			sizedbg = pt->sizept -
+				(int)((char *)proto_lineinfo(pt) - (char *)pt);
+		p = bcwrite_uint32(p, sizedbg);
+		if (sizedbg) {
+			p = bcwrite_uint32(p, pt->firstline);
+			p = bcwrite_uint32(p, pt->numline);
+		}
+	}
+
+	/* Write bytecode instructions and upvalue refs. */
+	p = bcwrite_bytecode(ctx, p, pt);
+	p = kp_buf_wmem(p, proto_uv(pt), pt->sizeuv*2);
+	setsbufP(&ctx->sb, p);
+
+	/* Write constants. */
+	bcwrite_kgc(ctx, pt);
+	bcwrite_knum(ctx, pt);
+
+	/* Write debug info, if not stripped. */
+	if (sizedbg) {
+		p = kp_buf_more(&ctx->sb, sizedbg);
+		p = kp_buf_wmem(p, proto_lineinfo(pt), sizedbg);
+		setsbufP(&ctx->sb, p);
+	}
+
+	/* Pass buffer to writer function. */
+	if (ctx->status == 0) {
+		int n = sbuflen(&ctx->sb) - 4;
+		char *q = sbufB(&ctx->sb);
+		p = bcwrite_uint32(q, n);  /* Fill in final size. */
+		kp_assert(p == sbufB(&ctx->sb) + 4);
+		ctx->status = ctx->wfunc(q, n + 4, ctx->wdata);
+	}
+}
+
+/* Write header of bytecode dump. */
+static void bcwrite_header(BCWriteCtx *ctx)
+{
+	ktap_str_t *chunkname = proto_chunkname(ctx->pt);
+	const char *name = getstr(chunkname);
+	int len = chunkname->len;
+	char *p = kp_buf_need(&ctx->sb, 5+5+len);
+	*p++ = BCDUMP_HEAD1;
+	*p++ = BCDUMP_HEAD2;
+	*p++ = BCDUMP_HEAD3;
+	*p++ = BCDUMP_VERSION;
+	*p++ = (ctx->strip ? BCDUMP_F_STRIP : 0) + (KP_BE ? BCDUMP_F_BE : 0);
+
+	if (!ctx->strip) {
+		p = bcwrite_uint32(p, len);
+		p = kp_buf_wmem(p, name, len);
+	}
+	ctx->status = ctx->wfunc(sbufB(&ctx->sb),
+		(int)(p - sbufB(&ctx->sb)), ctx->wdata);
+}
+
+/* Write footer of bytecode dump. */
+static void bcwrite_footer(BCWriteCtx *ctx)
+{
+	if (ctx->status == 0) {
+		uint8_t zero = 0;
+		ctx->status = ctx->wfunc(&zero, 1, ctx->wdata);
+	}
+}
+
+/* Write bytecode for a prototype. */
+int kp_bcwrite(ktap_proto_t *pt, ktap_writer writer, void *data, int strip)
+{
+	BCWriteCtx ctx;
+
+	ctx.pt = pt;
+	ctx.wfunc = writer;
+	ctx.wdata = data;
+	ctx.strip = strip;
+	ctx.status = 0;
+
+	kp_buf_init(&ctx.sb);
+	kp_buf_need(&ctx.sb, 1024);  /* Avoids resize for most prototypes. */
+	bcwrite_header(&ctx);
+	bcwrite_proto(&ctx, ctx.pt);
+	bcwrite_footer(&ctx);
+
+	kp_buf_free(&ctx.sb);
+	return ctx.status;
+}
+
+/* -- Bytecode dump ----------------------------------------------------- */
+
+static const char * const bc_names[] = {
+#define BCNAME(name, ma, mb, mc, mt)       #name,
+	BCDEF(BCNAME)
+#undef BCNAME
+  NULL
+};
+
+static const uint16_t bc_mode[] = {
+	BCDEF(BCMODE)
+};
+
+static void dump_bytecode(ktap_proto_t *pt)
+{
+	int nbc = pt->sizebc - 1; /* Omit the FUNC* header. */
+	BCIns *ins = proto_bc(pt) + 1;
+	ktap_obj_t **kbase = pt->k;
+	int i;
+
+	printf("-- BYTECODE -- %s:%d-%d\n", getstr(pt->chunkname),
+		pt->firstline, pt->firstline + pt->numline);
+
+	for (i = 0; i < nbc; i++, ins++) {
+		int op = bc_op(*ins);
+
+		printf("%04d\t%s", i + 1, bc_names[op]);
+
+		printf("\t%d", bc_a(*ins));
+		if (bcmode_b(op) != BCMnone)
+			printf("\t%d", bc_b(*ins));
+
+		if (bcmode_hasd(op))
+			printf("\t%d", bc_d(*ins));
+		else
+			printf("\t%d", bc_c(*ins));
+
+		if (bcmode_b(op) == BCMstr || bcmode_c(op) == BCMstr) {
+			printf("\t  ; ");
+			if (bcmode_d(op) == BCMstr) {
+				int idx = ~bc_d(*ins);
+				printf("\"%s\"", getstr((ktap_str_t *)kbase[idx]));
+			}
+		}
+		printf("\n");
+	}
+}
+
+static int function_nr = 0;
+
+void kp_dump_proto(ktap_proto_t *pt)
+{
+	printf("\n----------------------------------------------------\n");
+	printf("function proto %d:\n", function_nr++);
+	printf("numparams: %d\n", pt->numparams);
+	printf("framesize: %d\n", pt->framesize);
+	printf("sizebc: %d\n", pt->sizebc);
+	printf("sizekgc: %d\n", pt->sizekgc);
+	printf("sizekn: %d\n", pt->sizekn);
+	printf("sizept: %d\n", pt->sizept);
+	printf("sizeuv: %d\n", pt->sizeuv);
+	printf("firstline: %d\n", pt->firstline);
+	printf("numline: %d\n", pt->numline);
+
+	printf("has child proto: %d\n", pt->flags & PROTO_CHILD);
+	printf("has vararg: %d\n", pt->flags & PROTO_VARARG);
+	printf("has ILOOP: %d\n", pt->flags & PROTO_ILOOP);
+
+	dump_bytecode(pt);
+
+	/* Recursively dump children of prototype. */
+	if (pt->flags & PROTO_CHILD) {
+		ptrdiff_t i, n = pt->sizekgc;
+		ktap_obj_t **kr = (ktap_obj_t **)pt->k - 1;
+		for (i = 0; i < n; i++, kr--) {
+			ktap_obj_t *o = *kr;
+			if (o->gch.gct == ~KTAP_TPROTO)
+				kp_dump_proto((ktap_proto_t *)o);		
+		}
+	}
+}
+
diff --git a/tools/ktap/kp_lex.c b/tools/ktap/kp_lex.c
new file mode 100644
index 0000000..4535223
--- /dev/null
+++ b/tools/ktap/kp_lex.c
@@ -0,0 +1,552 @@
+/*
+ * Lexical analyzer.
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2012-2014 Jovi Zhangwei <jovi.zhangwei@gmail.com>.
+ *
+ * Adapted from luajit and lua interpreter.
+ * Copyright (C) 2005-2014 Mike Pall.
+ * Copyright (C) 1994-2008 Lua.org, PUC-Rio.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <ktap/ktap_types.h>
+#include <ktap/ktap_err.h>
+#include "kp_util.h"
+#include "kp_lex.h"
+#include "kp_parse.h"
+
+/* lexer token names. */
+static const char *const tokennames[] = {
+#define TKSTR1(name)		#name,
+#define TKSTR2(name, sym)	#sym,
+TKDEF(TKSTR1, TKSTR2)
+#undef TKSTR1
+#undef TKSTR2
+  NULL
+};
+
+/* -- Buffer handling ----------------------------------------------------- */
+
+#define LEX_EOF			(-1)
+#define lex_iseol(ls)		(ls->c == '\n' || ls->c == '\r')
+
+/* Get next character. */
+static inline LexChar lex_next(LexState *ls)
+{
+	return (ls->c = ls->p < ls->pe ? (LexChar)(uint8_t)*ls->p++ : LEX_EOF);
+}
+
+/* Save character. */
+static inline void lex_save(LexState *ls, LexChar c)
+{
+	kp_buf_putb(&ls->sb, c);
+}
+
+/* Save previous character and get next character. */
+static inline LexChar lex_savenext(LexState *ls)
+{
+	lex_save(ls, ls->c);
+	return lex_next(ls);
+}
+
+/* Skip line break. Handles "\n", "\r", "\r\n" or "\n\r". */
+static void lex_newline(LexState *ls)
+{
+	LexChar old = ls->c;
+
+	kp_assert(lex_iseol(ls));
+	lex_next(ls);  /* Skip "\n" or "\r". */
+	if (lex_iseol(ls) && ls->c != old)
+		lex_next(ls);  /* Skip "\n\r" or "\r\n". */
+	if (++ls->linenumber >= KP_MAX_LINE)
+		kp_lex_error(ls, ls->tok, KP_ERR_XLINES);
+}
+
+/* -- Scanner for terminals ----------------------------------------------- */
+
+static int kp_str2d(const char *s, size_t len, ktap_number *result)
+{
+	char *endptr;
+
+	if (strpbrk(s, "nN"))  /* reject 'inf' and 'nan' */
+		return 0;
+	else
+		*result = (long)strtoul(s, &endptr, 0);
+
+	if (endptr == s)
+		return 0;  /* nothing recognized */
+	while (kp_char_isspace((unsigned char)(*endptr)))
+		endptr++;
+	return (endptr == s + len);  /* OK if no trailing characters */
+}
+
+
+/* Parse a number literal. */
+static void lex_number(LexState *ls, ktap_val_t *tv)
+{
+	LexChar c, xp = 'e';
+	ktap_number n = 0;
+
+	kp_assert(kp_char_isdigit(ls->c));
+	if ((c = ls->c) == '0' && (lex_savenext(ls) | 0x20) == 'x')
+		xp = 'p';
+	while (kp_char_isident(ls->c) || ls->c == '.' ||
+		((ls->c == '-' || ls->c == '+') && (c | 0x20) == xp)) {
+		c = ls->c;
+		lex_savenext(ls);
+	}
+	lex_save(ls, '\0');
+	if (!kp_str2d(sbufB(&ls->sb), sbuflen(&ls->sb) - 1, &n))
+			kp_lex_error(ls, ls->tok, KP_ERR_XNUMBER);
+	set_number(tv, n);
+}
+
+/* Skip equal signs for "[=...=[" and "]=...=]" and return their count. */
+static int lex_skipeq(LexState *ls)
+{
+	int count = 0;
+	LexChar s = ls->c;
+
+	kp_assert(s == '[' || s == ']');
+	while (lex_savenext(ls) == '=')
+		count++;
+	return (ls->c == s) ? count : (-count) - 1;
+}
+
+/* Parse a long string or long comment (tv set to NULL). */
+static void lex_longstring(LexState *ls, ktap_val_t *tv, int sep)
+{
+	lex_savenext(ls);  /* Skip second '['. */
+	if (lex_iseol(ls))  /* Skip initial newline. */
+		lex_newline(ls);
+	for (;;) {
+		switch (ls->c) {
+		case LEX_EOF:
+			kp_lex_error(ls, TK_eof,
+					tv ? KP_ERR_XLSTR : KP_ERR_XLCOM);
+			break;
+		case ']':
+			if (lex_skipeq(ls) == sep) {
+				lex_savenext(ls);  /* Skip second ']'. */
+				goto endloop;
+			}
+			break;
+		case '\n':
+		case '\r':
+			lex_save(ls, '\n');
+			lex_newline(ls);
+			if (!tv) /* Don't waste space for comments. */
+				kp_buf_reset(&ls->sb);
+			break;
+		default:
+			lex_savenext(ls);
+			break;
+		}
+	}
+ endloop:
+	if (tv) {
+		ktap_str_t *str = kp_parse_keepstr(ls,
+					sbufB(&ls->sb) + (2 + (int)sep),
+					sbuflen(&ls->sb) - 2*(2 + (int)sep));
+		set_string(tv, str);
+	}
+}
+
+/* Parse a string. */
+static void lex_string(LexState *ls, ktap_val_t *tv)
+{
+	LexChar delim = ls->c;  /* Delimiter is '\'' or '"'. */
+
+	lex_savenext(ls);
+	while (ls->c != delim) {
+		switch (ls->c) {
+		case LEX_EOF:
+			kp_lex_error(ls, TK_eof, KP_ERR_XSTR);
+			continue;
+		case '\n':
+		case '\r':
+			kp_lex_error(ls, TK_string, KP_ERR_XSTR);
+			continue;
+		case '\\': {
+			LexChar c = lex_next(ls);  /* Skip the '\\'. */
+			switch (c) {
+			case 'a': c = '\a'; break;
+			case 'b': c = '\b'; break;
+			case 'f': c = '\f'; break;
+			case 'n': c = '\n'; break;
+			case 'r': c = '\r'; break;
+			case 't': c = '\t'; break;
+			case 'v': c = '\v'; break;
+			case 'x':  /* Hexadecimal escape '\xXX'. */
+				c = (lex_next(ls) & 15u) << 4;
+				if (!kp_char_isdigit(ls->c)) {
+					if (!kp_char_isxdigit(ls->c))
+						goto err_xesc;
+					c += 9 << 4;
+				}
+				c += (lex_next(ls) & 15u);
+				if (!kp_char_isdigit(ls->c)) {
+					if (!kp_char_isxdigit(ls->c))
+						goto err_xesc;
+					c += 9;
+				}
+				break;
+			case 'z':  /* Skip whitespace. */
+				lex_next(ls);
+				while (kp_char_isspace(ls->c))
+					if (lex_iseol(ls))
+						lex_newline(ls);
+					else
+						lex_next(ls);
+					continue;
+			case '\n': case '\r':
+				lex_save(ls, '\n');
+				lex_newline(ls);
+				continue;
+			case '\\': case '\"': case '\'':
+				break;
+			case LEX_EOF:
+				continue;
+			default:
+				if (!kp_char_isdigit(c))
+					goto err_xesc;
+				c -= '0';  /* Decimal escape '\ddd'. */
+				if (kp_char_isdigit(lex_next(ls))) {
+					c = c*10 + (ls->c - '0');
+					if (kp_char_isdigit(lex_next(ls))) {
+						c = c*10 + (ls->c - '0');
+						if (c > 255) {
+ err_xesc:
+							kp_lex_error(ls,
+								TK_string,
+								KP_ERR_XESC);
+						}
+						lex_next(ls);
+					}
+				}
+				lex_save(ls, c);
+				continue;
+			}
+			lex_save(ls, c);
+			lex_next(ls);
+			continue;
+		}
+		default:
+			lex_savenext(ls);
+			break;
+		}
+	}
+	lex_savenext(ls);  /* Skip trailing delimiter. */
+	set_string(tv,
+		kp_parse_keepstr(ls, sbufB(&ls->sb)+1, sbuflen(&ls->sb)-2));
+}
+
+/* lex helper for parse_trace and parse_timer */
+void kp_lex_read_string_until(LexState *ls, int c)
+{
+	ktap_str_t *ts;
+
+	kp_buf_reset(&ls->sb);
+
+	while (ls->c == ' ')
+		lex_next(ls);
+
+	do {
+		lex_savenext(ls);
+	} while (ls->c != c && ls->c != LEX_EOF);
+
+	if (ls->c != c)
+		kp_lex_error(ls, ls->tok, KP_ERR_XTOKEN, c);
+
+	ts = kp_parse_keepstr(ls, sbufB(&ls->sb), sbuflen(&ls->sb));
+	ls->tok = TK_string;
+	set_string(&ls->tokval, ts);
+}
+
+
+/* -- Main lexical scanner ------------------------------------------------ */
+
+/* Get next lexical token. */
+static LexToken lex_scan(LexState *ls, ktap_val_t *tv)
+{
+	kp_buf_reset(&ls->sb);
+	for (;;) {
+		if (kp_char_isident(ls->c)) {
+			ktap_str_t *s;
+			if (kp_char_isdigit(ls->c)) {  /* Numeric literal. */
+				lex_number(ls, tv);
+				return TK_number;
+			}
+			/* Identifier or reserved word. */
+			do {
+				lex_savenext(ls);
+			} while (kp_char_isident(ls->c));
+			s = kp_parse_keepstr(ls, sbufB(&ls->sb),
+						sbuflen(&ls->sb));
+			set_string(tv, s);
+			if (s->reserved > 0)  /* Reserved word? */
+				return TK_OFS + s->reserved;
+			return TK_name;
+		}
+
+		switch (ls->c) {
+		case '\n':
+		case '\r':
+			lex_newline(ls);
+			continue;
+		case ' ':
+		case '\t':
+		case '\v':
+		case '\f':
+			lex_next(ls);
+			continue;
+
+		case '#':
+			while (!lex_iseol(ls) && ls->c != LEX_EOF)
+				lex_next(ls);
+			break;
+		case '-':
+			lex_next(ls);
+			if (ls->c != '-')
+				return '-';
+			lex_next(ls);
+			if (ls->c == '[') { /* Long comment "--[=*[...]=*]". */
+				int sep = lex_skipeq(ls);
+				/* `lex_skipeq' may dirty the buffer */
+				kp_buf_reset(&ls->sb);
+				if (sep >= 0) {
+					lex_longstring(ls, NULL, sep);
+					kp_buf_reset(&ls->sb);
+					continue;
+				}
+			}
+			/* Short comment "--.*\n". */
+			while (!lex_iseol(ls) && ls->c != LEX_EOF)
+				lex_next(ls);
+			continue;
+		case '[': {
+			int sep = lex_skipeq(ls);
+			if (sep >= 0) {
+				lex_longstring(ls, tv, sep);
+				return TK_string;
+			} else if (sep == -1) {
+				return '[';
+			} else {
+				kp_lex_error(ls, TK_string, KP_ERR_XLDELIM);
+				continue;
+			}
+		}
+		case '+': {
+			lex_next(ls);
+			if (ls->c != '=')
+				return '+';
+			else {
+				lex_next(ls);
+				return TK_incr;
+			}
+		}
+		case '=':
+			lex_next(ls);
+			if (ls->c != '=')
+				return '=';
+			else {
+				lex_next(ls);
+				return TK_eq;
+			}
+		case '<':
+			lex_next(ls);
+			if (ls->c != '=')
+				return '<';
+			else {
+				lex_next(ls);
+				return TK_le;
+			}
+		case '>':
+			lex_next(ls);
+			if (ls->c != '=')
+				return '>';
+			else {
+				lex_next(ls);
+				return TK_ge;
+			}
+		case '!':
+      			lex_next(ls);
+			if (ls->c != '=')
+				return TK_not;
+			else {
+				lex_next(ls);
+				return TK_ne;
+			}
+		case ':':
+			lex_next(ls);
+			if (ls->c != ':')
+				return ':';
+			else {
+				lex_next(ls);
+				return TK_label;
+			}
+		case '"':
+		case '\'':
+			lex_string(ls, tv);
+			return TK_string;
+		case '.':
+			if (lex_savenext(ls) == '.') {
+				lex_next(ls);
+				if (ls->c == '.') {
+					lex_next(ls);
+					return TK_dots;   /* ... */
+				}
+				return TK_concat;   /* .. */
+			} else if (!kp_char_isdigit(ls->c)) {
+				return '.';
+			} else {
+				lex_number(ls, tv);
+				return TK_number;
+			}
+		case LEX_EOF:
+			return TK_eof;
+		case '&':
+			lex_next(ls);
+			if (ls->c != '&')
+				return '&';
+			else {
+				lex_next(ls);
+				return TK_and;
+			}
+		case '|':
+			lex_next(ls);
+			if (ls->c != '|')
+				return '|';
+			else {
+				lex_next(ls);
+				return TK_or;
+			}
+		default: {
+			LexChar c = ls->c;
+			lex_next(ls);
+			return c;  /* Single-char tokens (+ - / ...). */
+		}
+		}
+	}
+}
+
+/* -- Lexer API ----------------------------------------------------------- */
+
+/* Setup lexer state. */
+int kp_lex_setup(LexState *ls, const char *str)
+{
+	ls->fs = NULL;
+	ls->pe = ls->p = NULL;
+	ls->p = str;
+	ls->pe = str + strlen(str);
+	ls->vstack = NULL;
+	ls->sizevstack = 0;
+	ls->vtop = 0;
+	ls->bcstack = NULL;
+	ls->sizebcstack = 0;
+	ls->lookahead = TK_eof;  /* No look-ahead token. */
+	ls->linenumber = 1;
+	ls->lastline = 1;
+	lex_next(ls);  /* Read-ahead first char. */
+	if (ls->c == 0xef && ls->p + 2 <= ls->pe &&
+		(uint8_t)ls->p[0] == 0xbb &&
+		(uint8_t)ls->p[1] == 0xbf) {/* Skip UTF-8 BOM (if buffered). */
+		ls->p += 2;
+		lex_next(ls);
+	}
+	if (ls->c == '#') {  /* Skip POSIX #! header line. */
+		do {
+			lex_next(ls);
+			if (ls->c == LEX_EOF)
+				return 0;
+		} while (!lex_iseol(ls));
+		lex_newline(ls);
+	}
+	return 0;
+}
+
+/* Cleanup lexer state. */
+void kp_lex_cleanup(LexState *ls)
+{
+	free(ls->bcstack);
+	free(ls->vstack);
+	kp_buf_free(&ls->sb);
+}
+
+/* Return next lexical token. */
+void kp_lex_next(LexState *ls)
+{
+	ls->lastline = ls->linenumber;
+	if (ls->lookahead == TK_eof) {  /* No lookahead token? */
+		ls->tok = lex_scan(ls, &ls->tokval);  /* Get next token. */
+	} else {  /* Otherwise return lookahead token. */
+		ls->tok = ls->lookahead;
+		ls->lookahead = TK_eof;
+		ls->tokval = ls->lookaheadval;
+	}
+}
+
+/* Look ahead for the next token. */
+LexToken kp_lex_lookahead(LexState *ls)
+{
+	kp_assert(ls->lookahead == TK_eof);
+	ls->lookahead = lex_scan(ls, &ls->lookaheadval);
+	return ls->lookahead;
+}
+
+/* Convert token to string. */
+const char *kp_lex_token2str(LexState *ls, LexToken tok)
+{
+	if (tok > TK_OFS)
+		return tokennames[tok-TK_OFS-1];
+	else if (!kp_char_iscntrl(tok))
+		return kp_sprintf("%c", tok);
+	else
+		return kp_sprintf("char(%d)", tok);
+}
+
+/* Lexer error. */
+void kp_lex_error(LexState *ls, LexToken tok, ErrMsg em, ...)
+{
+	const char *tokstr;
+	va_list argp;
+
+	if (tok == 0) {
+		tokstr = NULL;
+	} else if (tok == TK_name || tok == TK_string || tok == TK_number) {
+		lex_save(ls, '\0');
+		tokstr = sbufB(&ls->sb);
+	} else {
+		tokstr = kp_lex_token2str(ls, tok);
+	}
+
+	va_start(argp, em);
+	kp_err_lex(ls->chunkname, tokstr, ls->linenumber, em, argp);
+	va_end(argp);
+}
+
+/* Initialize strings for reserved words. */
+void kp_lex_init()
+{
+	uint32_t i;
+
+	for (i = 0; i < TK_RESERVED; i++) {
+		ktap_str_t *s = kp_str_newz(tokennames[i]);
+		s->reserved = (uint8_t)(i+1);
+	}
+}
+
diff --git a/tools/ktap/kp_lex.h b/tools/ktap/kp_lex.h
new file mode 100644
index 0000000..bd48210
--- /dev/null
+++ b/tools/ktap/kp_lex.h
@@ -0,0 +1,94 @@
+/*
+ * Lexical analyzer.
+ *
+ * Copyright (C) 2012-2014 Jovi Zhangwei <jovi.zhangwei@gmail.com>.
+ *
+ * Adapted from luajit and lua interpreter.
+ * Copyright (C) 2005-2014 Mike Pall.
+ * Copyright (C) 1994-2008 Lua.org, PUC-Rio.
+ */
+
+#ifndef _KTAP_LEX_H
+#define _KTAP_LEX_H
+
+#include <stdarg.h>
+#include <ktap/ktap_err.h>
+#include <ktap/ktap_bc.h>
+#include "kp_util.h"
+
+/* ktap lexer tokens. */
+#define TKDEF(_, __) \
+	_(trace) _(trace_end) _(argstr) _(probename) _(ffi) \
+	_(arg0)_(arg1) _(arg2) _(arg3) _(arg4) _(arg5) _(arg6) _(arg7) \
+	_(arg8) _(arg9) _(profile) _(tick) \
+	_(pid) _(tid) _(uid) _(cpu) _(execname) __(incr, +=) \
+	__(and, &&) _(break) _(do) _(else) _(elseif) _(end) _(false) \
+	_(for) _(function) _(goto) _(if) _(in) __(local, var) _(nil) \
+	__(not, !) __(or, ||) \
+	_(repeat) _(return) _(then) _(true) _(until) _(while) \
+	__(concat, ..) __(dots, ...) __(eq, ==) __(ge, >=) __(le, <=) \
+	__(ne, !=) __(label, ::) __(number, <number>) __(name, <name>) \
+	__(string, <string>) __(eof, <eof>)
+
+enum {
+	TK_OFS = 256,
+#define TKENUM1(name)		TK_##name,
+#define TKENUM2(name, sym)	TK_##name,
+	TKDEF(TKENUM1, TKENUM2)
+#undef TKENUM1
+#undef TKENUM2
+	TK_RESERVED = TK_while - TK_OFS
+};
+
+typedef int LexChar;	/* Lexical character. Unsigned ext. from char. */
+typedef int LexToken;	/* Lexical token. */
+
+/* Combined bytecode ins/line. Only used during bytecode generation. */
+typedef struct BCInsLine {
+	BCIns ins;		/* Bytecode instruction. */
+	BCLine line;		/* Line number for this bytecode. */
+} BCInsLine;
+
+/* Info for local variables. Only used during bytecode generation. */
+typedef struct VarInfo {
+	ktap_str_t *name;	/* Local variable name or goto/label name. */
+	BCPos startpc;	/* First point where the local variable is active. */
+	BCPos endpc;	/* First point where the local variable is dead. */
+	uint8_t slot;	/* Variable slot. */
+	uint8_t info;	/* Variable/goto/label info. */
+} VarInfo;
+
+/* lexer state. */
+typedef struct LexState {
+	struct FuncState *fs;	/* Current FuncState. Defined in kp_parse.c. */
+	ktap_val_t tokval;	/* Current token value. */
+	ktap_val_t lookaheadval;/* Lookahead token value. */
+	const char *p;	/* Current position in input buffer. */
+	const char *pe;	/* End of input buffer. */
+	LexChar c;		/* Current character. */
+	LexToken tok;		/* Current token. */
+	LexToken lookahead;	/* Lookahead token. */
+	SBuf sb;		/* String buffer for tokens. */
+	BCLine linenumber;	/* Input line counter. */
+	BCLine lastline;	/* Line of last token. */
+	ktap_str_t *chunkname;/* Current chunk name (interned string). */
+	const char *chunkarg;	/* Chunk name argument. */
+	const char *mode;/* Allow loading bytecode (b) and/or source text (t) */
+	VarInfo *vstack;/* Stack for names and extents of local variables. */
+	int sizevstack;	/* Size of variable stack. */
+	int vtop;	/* Top of variable stack. */
+	BCInsLine *bcstack;/* Stack for bytecode instructions/line numbers. */
+	int sizebcstack;/* Size of bytecode stack. */
+	uint32_t level;	/* Syntactical nesting level. */
+} LexState;
+
+int kp_lex_setup(LexState *ls, const char *str);
+void kp_lex_cleanup(LexState *ls);
+void kp_lex_next(LexState *ls);
+void kp_lex_read_string_until(LexState *ls, int c);
+LexToken kp_lex_lookahead(LexState *ls);
+const char *kp_lex_token2str(LexState *ls, LexToken tok);
+void kp_lex_error(LexState *ls, LexToken tok, ErrMsg em, ...);
+void kp_lex_init(void);
+
+#endif
diff --git a/tools/ktap/kp_main.c b/tools/ktap/kp_main.c
new file mode 100644
index 0000000..fbf170e
--- /dev/null
+++ b/tools/ktap/kp_main.c
@@ -0,0 +1,455 @@
+/*
+ * main.c - ktap compiler and loader entry
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2012-2013 Jovi Zhangwei <jovi.zhangwei@gmail.com>.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sched.h>
+#include <string.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <math.h>
+#include <linux/errno.h>
+
+#include <ktap/ktap_types.h>
+#include "kp_lex.h"
+#include "kp_parse.h"
+#include "kp_symbol.h"
+#include "cparser.h"
+
+static void usage(const char *msg_fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, msg_fmt);
+	vfprintf(stderr, msg_fmt, ap);
+	va_end(ap);
+
+	fprintf(stderr,
+"Usage: ktap [options] file [script args] -- cmd [args]\n"
+"   or: ktap [options] -e one-liner  -- cmd [args]\n"
+"\n"
+"Options and arguments:\n"
+"  -o file        : send script output to file, instead of stderr\n"
+"  -p pid         : specific tracing pid\n"
+"  -C cpu         : cpu to monitor in system-wide\n"
+"  -T             : show timestamp for event\n"
+"  -V             : show version\n"
+"  -v             : enable verbose mode\n"
+"  -q             : suppress start tracing message\n"
+"  -d             : dry run mode(register NULL callback to perf events)\n"
+"  -s             : simple event tracing\n"
+"  -b             : list byte codes\n"
+"  -le [glob]     : list pre-defined events in system\n"
+#ifndef NO_LIBELF
+"  -lf DSO        : list available functions from DSO\n"
+"  -lm DSO        : list available sdt notes from DSO\n"
+#endif
+"  file           : program read from script file\n"
+"  -- cmd [args]  : workload to tracing\n");
+
+	exit(EXIT_FAILURE);
+}
+
+#define handle_error(str) do { perror(str); exit(-1); } while(0)
+
+ktap_option_t uparm;
+static int ktap_trunk_mem_size = 1024;
+
+static int kp_writer(const void* p, size_t sz, void* ud)
+{
+	if (uparm.trunk_len + sz > ktap_trunk_mem_size) {
+		int new_size = (uparm.trunk_len + sz) * 2;
+		uparm.trunk = realloc(uparm.trunk, new_size);
+		ktap_trunk_mem_size = new_size;
+	}
+
+	memcpy(uparm.trunk + uparm.trunk_len, p, sz);
+	uparm.trunk_len += sz;
+
+	return 0;
+}
+
+
+static int forks;
+static char **workload_argv;
+
+static int fork_workload(int ktap_fd)
+{
+	int pid;
+
+	pid = fork();
+	if (pid < 0)
+		handle_error("failed to fork");
+
+	if (pid > 0)
+		return pid;
+
+	signal(SIGTERM, SIG_DFL);
+
+	execvp("", workload_argv);
+
+	/*
+	 * waiting ktapvm prepare all tracing event
+	 * make it more robust in future.
+	 */
+	pause();
+
+	execvp(workload_argv[0], workload_argv);
+
+	perror(workload_argv[0]);
+	exit(-1);
+
+	return -1;
+}
+
+#define KTAPVM_PATH "/sys/kernel/debug/ktap/ktapvm"
+
+static char *output_filename;
+
+static int run_ktapvm()
+{
+        int ktapvm_fd, ktap_fd;
+	int ret;
+
+	ktapvm_fd = open(KTAPVM_PATH, O_RDONLY);
+	if (ktapvm_fd < 0)
+		handle_error("open " KTAPVM_PATH " failed");
+
+	ktap_fd = ioctl(ktapvm_fd, 0, NULL);
+	if (ktap_fd < 0)
+		handle_error("ioctl ktapvm failed");
+
+	kp_create_reader(output_filename);
+
+	if (forks) {
+		uparm.trace_pid = fork_workload(ktap_fd);
+		uparm.workload = 1;
+	}
+
+	ret = ioctl(ktap_fd, KTAP_CMD_IOC_RUN, &uparm);
+	switch (ret) {
+	case -EPERM:
+	case -EACCES:
+		fprintf(stderr, "You may not have permission to run ktap\n");
+		break;
+	}
+
+	close(ktap_fd);
+	close(ktapvm_fd);
+
+	return ret;
+}
+
+int verbose;
+static int quiet;
+static int dry_run;
+static int dump_bytecode;
+static char oneline_src[1024];
+static int trace_pid = -1;
+static int trace_cpu = -1;
+static int print_timestamp;
+
+#define SIMPLE_ONE_LINER_FMT	\
+	"trace %s { print(cpu(), tid(), execname(), argstr) }"
+
+static const char *script_file;
+static int script_args_start;
+static int script_args_end;
+
+#ifndef NO_LIBELF
+struct binary_base
+{
+	int type;
+	const char *binary;
+};
+static int print_symbol(const char *name, vaddr_t addr, void *arg)
+{
+	struct binary_base *base = (struct binary_base *)arg;
+	const char *type = base->type == FIND_SYMBOL ?
+		"probe" : "sdt";
+
+	printf("%s:%s:%s\n", type, base->binary, name);
+	return 0;
+}
+#endif
+
+static void parse_option(int argc, char **argv)
+{
+	char pid[32] = {0};
+	char cpu_str[32] = {0};
+	char *next_arg;
+	int i, j;
+
+	for (i = 1; i < argc; i++) {
+		if (argv[i][0] != '-') {
+			script_file = argv[i];
+			if (!script_file)
+				usage("");
+
+			script_args_start = i + 1;
+			script_args_end = argc;
+
+			for (j = i + 1; j < argc; j++) {
+				if (argv[j][0] == '-' && argv[j][1] == '-')
+					goto found_cmd;
+			}
+
+			return;
+		}
+
+		if (argv[i][0] == '-' && argv[i][1] == '-') {
+			j = i;
+			goto found_cmd;
+		}
+
+		next_arg = argv[i + 1];
+
+		switch (argv[i][1]) {
+		case 'o':
+			output_filename = malloc(strlen(next_arg) + 1);
+			if (!output_filename)
+				return;
+
+			strncpy(output_filename, next_arg, strlen(next_arg));
+			i++;
+			break;
+		case 'e':
+			strncpy(oneline_src, next_arg, strlen(next_arg));
+			i++;
+			break;
+		case 'p':
+			strncpy(pid, next_arg, strlen(next_arg));
+			trace_pid = atoi(pid);
+			i++;
+			break;
+		case 'C':
+			strncpy(cpu_str, next_arg, strlen(next_arg));
+			trace_cpu = atoi(cpu_str);
+			i++;
+			break;
+		case 'T':
+			print_timestamp = 1;
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		case 'q':
+			quiet = 1;
+			break;
+		case 'd':
+			dry_run = 1;
+			break;
+		case 's':
+			sprintf(oneline_src, SIMPLE_ONE_LINER_FMT, next_arg);
+			i++;
+			break;
+		case 'b':
+			dump_bytecode = 1;
+			break;
+		case 'l': /* list available events */
+			switch (argv[i][2]) {
+			case 'e': /* tracepoints */
+				list_available_events(next_arg);
+				exit(EXIT_SUCCESS);
+#ifndef NO_LIBELF
+			case 'f': /* functions in DSO */
+			case 'm': /* static marks in DSO */ {
+				const char *binary = next_arg;
+				int type = argv[i][2] == 'f' ?
+						FIND_SYMBOL : FIND_STAPSDT_NOTE;
+				struct binary_base base = {
+					.type = type,
+					.binary = binary,
+				};
+				int ret;
+
+				ret = parse_dso_symbols(binary, type,
+							print_symbol,
+							(void *)&base);
+				if (ret <= 0) {
+					fprintf(stderr,
+					"error: no symbols in binary %s\n",
+						binary);
+					exit(EXIT_FAILURE);
+				}
+				exit(EXIT_SUCCESS);
+			}
+#endif
+			default:
+				exit(EXIT_FAILURE);
+			}
+			break;
+		case 'V':
+#ifdef CONFIG_KTAP_FFI
+			usage("%s (with FFI)\n\n", KTAP_VERSION);
+#else
+			usage("%s\n\n", KTAP_VERSION);
+#endif
+			break;
+		case '?':
+		case 'h':
+			usage("");
+			break;
+		default:
+			usage("wrong argument\n");
+			break;
+		}
+	}
+
+	return;
+
+ found_cmd:
+	script_args_end = j;
+	forks = 1;
+	workload_argv = &argv[j + 1];
+}
+
+static ktap_proto_t *parse(const char *chunkname, const char *src)
+{
+	LexState ls;
+
+	ls.chunkarg = chunkname ? chunkname : "?";
+	kp_lex_init();
+	kp_buf_init(&ls.sb);
+	kp_lex_setup(&ls, src);
+	return kp_parse(&ls);
+}
+
+static void compile(const char *input)
+{
+	ktap_proto_t *pt;
+	char *buff;
+	struct stat sb;
+	int fdin;
+
+	kp_str_resize();
+
+	if (oneline_src[0] != '\0') {
+		ffi_cparser_init();
+		pt = parse(input, oneline_src);
+		goto dump;
+	}
+
+	fdin = open(input, O_RDONLY);
+	if (fdin < 0) {
+		fprintf(stderr, "open file %s failed\n", input);
+		exit(-1);
+	}
+
+	if (fstat(fdin, &sb) == -1)
+		handle_error("fstat failed");
+
+	buff = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fdin, 0);
+	if (buff == MAP_FAILED)
+		handle_error("mmap failed");
+
+	ffi_cparser_init();
+	pt = parse(input, buff);
+
+	munmap(buff, sb.st_size);
+	close(fdin);
+
+ dump:
+	if (dump_bytecode) {
+#ifdef CONFIG_KTAP_FFI
+		kp_dump_csymbols();
+#endif
+		kp_dump_proto(pt);
+		exit(0);
+	}
+
+	/* bcwrite */
+	uparm.trunk = malloc(ktap_trunk_mem_size);
+	if (!uparm.trunk)
+		handle_error("malloc failed");
+
+	kp_bcwrite(pt, kp_writer, NULL, 0);
+	ffi_cparser_free();
+}
+
+int main(int argc, char **argv)
+{
+	char **ktapvm_argv;
+	int new_index, i;
+	int ret;
+
+	if (argc == 1)
+		usage("");
+
+	parse_option(argc, argv);
+
+	if (oneline_src[0] != '\0')
+		script_file = "(command line)";
+
+	compile(script_file);
+
+	ktapvm_argv = (char **)malloc(sizeof(char *)*(script_args_end -
+					script_args_start + 1));
+	if (!ktapvm_argv) {
+		fprintf(stderr, "canno allocate ktapvm_argv\n");
+		return -1;
+	}
+
+	ktapvm_argv[0] = malloc(strlen(script_file) + 1);
+	if (!ktapvm_argv[0]) {
+		fprintf(stderr, "canno allocate memory\n");
+		return -1;
+	}
+	strcpy(ktapvm_argv[0], script_file);
+	ktapvm_argv[0][strlen(script_file)] = '\0';
+
+	/* pass rest argv into ktapvm */
+	new_index = 1;
+	for (i = script_args_start; i < script_args_end; i++) {
+		ktapvm_argv[new_index] = malloc(strlen(argv[i]) + 1);
+		if (!ktapvm_argv[new_index]) {
+			fprintf(stderr, "canno allocate memory\n");
+			free(ktapvm_argv);
+			return -1;
+		}
+		strcpy(ktapvm_argv[new_index], argv[i]);
+		ktapvm_argv[new_index][strlen(argv[i])] = '\0';
+		new_index++;
+	}
+
+	uparm.argv = ktapvm_argv;
+	uparm.argc = new_index;
+	uparm.verbose = verbose;
+	uparm.trace_pid = trace_pid;
+	uparm.trace_cpu = trace_cpu;
+	uparm.print_timestamp = print_timestamp;
+	uparm.quiet = quiet;
+	uparm.dry_run = dry_run;
+
+	/* start running into kernel ktapvm */
+	ret = run_ktapvm();
+
+	cleanup_event_resources();
+	return ret;
+}
+
+
diff --git a/tools/ktap/kp_parse.c b/tools/ktap/kp_parse.c
new file mode 100644
index 0000000..8c212b5
--- /dev/null
+++ b/tools/ktap/kp_parse.c
@@ -0,0 +1,3139 @@
+/*
+ * ktap parser (source code -> bytecode).
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2012-2014 Jovi Zhangwei <jovi.zhangwei@gmail.com>.
+ *
+ * Adapted from luajit and lua interpreter.
+ * Copyright (C) 2005-2014 Mike Pall.
+ * Copyright (C) 1994-2008 Lua.org, PUC-Rio.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <ktap/ktap_types.h>
+#include <ktap/ktap_err.h>
+#include "kp_util.h"
+#include "kp_lex.h"
+
+/* Fixed internal variable names. */
+#define VARNAMEDEF(_) \
+	_(FOR_IDX, "(for index)") \
+	_(FOR_STOP, "(for limit)") \
+	_(FOR_STEP, "(for step)") \
+	_(FOR_GEN, "(for generator)") \
+	_(FOR_STATE, "(for state)") \
+	_(FOR_CTL, "(for control)")
+
+enum {
+	VARNAME_END,
+#define VARNAMEENUM(name, str)  VARNAME_##name,
+	VARNAMEDEF(VARNAMEENUM)
+#undef VARNAMEENUM
+	VARNAME__MAX
+};
+
+/* -- Parser structures and definitions ----------------------------------- */
+
+/* Expression kinds. */
+typedef enum {
+	/* Constant expressions must be first and in this order: */
+	VKNIL,
+	VKFALSE,
+	VKTRUE,
+	VKSTR,	/* sval = string value */
+	VKNUM,	/* nval = number value */
+	VKLAST = VKNUM,
+	VKCDATA, /* nval = cdata value, not treated as a constant expression */
+	/* Non-constant expressions follow: */
+	VLOCAL,	/* info = local register, aux = vstack index */
+	VUPVAL,	/* info = upvalue index, aux = vstack index */
+	VGLOBAL,/* sval = string value */
+	VINDEXED,/* info = table register, aux = index reg/byte/string const */
+	VJMP,	/* info = instruction PC */
+	VRELOCABLE, /* info = instruction PC */
+	VNONRELOC, /* info = result register */
+	VCALL,	/* info = instruction PC, aux = base */
+	VVOID,
+
+	VARGN,
+	VARGSTR,
+	VARGNAME,
+	VPID,
+	VTID,
+	VUID,
+	VCPU,
+	VEXECNAME,
+	VMAX
+} ExpKind;
+
+/* Expression descriptor. */
+typedef struct ExpDesc {
+	union {
+		struct {
+			uint32_t info;	/* Primary info. */
+			uint32_t aux;	/* Secondary info. */
+		} s;
+		ktap_val_t nval;	/* Number value. */
+		ktap_str_t *sval;	/* String value. */
+	} u;
+	ExpKind k;
+	BCPos t;	/* True condition jump list. */
+	BCPos f;	/* False condition jump list. */
+} ExpDesc;
+
+/* Macros for expressions. */
+#define expr_hasjump(e)		((e)->t != (e)->f)
+
+#define expr_isk(e)		((e)->k <= VKLAST)
+#define expr_isk_nojump(e)	(expr_isk(e) && !expr_hasjump(e))
+#define expr_isnumk(e)		((e)->k == VKNUM)
+#define expr_isnumk_nojump(e)	(expr_isnumk(e) && !expr_hasjump(e))
+#define expr_isstrk(e)		((e)->k == VKSTR)
+
+#define expr_numtv(e)		(&(e)->u.nval)
+#define expr_numberV(e)		nvalue(expr_numtv((e)))
+
+/* Initialize expression. */
+static inline void expr_init(ExpDesc *e, ExpKind k, uint32_t info)
+{
+	e->k = k;
+	e->u.s.info = info;
+	e->f = e->t = NO_JMP;
+}
+
+/* Check number constant for +-0. */
+static int expr_numiszero(ExpDesc *e)
+{
+	ktap_val_t *o = expr_numtv(e);
+	return (nvalue(o) == 0);
+}
+
+/* Per-function linked list of scope blocks. */
+typedef struct FuncScope {
+	struct FuncScope *prev;	/* Link to outer scope. */
+	int vstart;		/* Start of block-local variables. */
+	uint8_t nactvar;	/* Number of active vars outside the scope. */
+	uint8_t flags;		/* Scope flags. */
+} FuncScope;
+
+#define FSCOPE_LOOP		0x01	/* Scope is a (breakable) loop. */
+#define FSCOPE_BREAK		0x02	/* Break used in scope. */
+#define FSCOPE_GOLA		0x04	/* Goto or label used in scope. */
+#define FSCOPE_UPVAL		0x08	/* Upvalue in scope. */
+#define FSCOPE_NOCLOSE		0x10	/* Do not close upvalues. */
+
+#define NAME_BREAK		((ktap_str_t *)(uintptr_t)1)
+
+/* Index into variable stack. */
+typedef uint16_t VarIndex;
+#define KP_MAX_VSTACK		(65536 - KP_MAX_UPVAL)
+
+/* Variable/goto/label info. */
+#define VSTACK_VAR_RW		0x01	/* R/W variable. */
+#define VSTACK_GOTO		0x02	/* Pending goto. */
+#define VSTACK_LABEL		0x04	/* Label. */
+
+/* Per-function state. */
+typedef struct FuncState {
+	ktap_tab_t *kt;		/* Hash table for constants. */
+	LexState *ls;		/* Lexer state. */
+	FuncScope *bl;		/* Current scope. */
+	struct FuncState *prev;	/* Enclosing function. */
+	BCPos pc;		/* Next bytecode position. */
+	BCPos lasttarget;	/* Bytecode position of last jump target. */
+	BCPos jpc;		/* Pending jump list to next bytecode. */
+	BCReg freereg;		/* First free register. */
+	BCReg nactvar;		/* Number of active local variables. */
+	BCReg nkn, nkgc;        /* Number of ktap_number/ktap_obj_t constants*/
+	BCLine linedefined;	/* First line of the function definition. */
+	BCInsLine *bcbase;	/* Base of bytecode stack. */
+	BCPos bclim;		/* Limit of bytecode stack. */
+	int vbase;		/* Base of variable stack for this function. */
+	uint8_t flags;		/* Prototype flags. */
+	uint8_t numparams;	/* Number of parameters. */
+	uint8_t framesize;	/* Fixed frame size. */
+	uint8_t nuv;		/* Number of upvalues */
+	VarIndex varmap[KP_MAX_LOCVAR];/* Map from register to variable idx. */
+	VarIndex uvmap[KP_MAX_UPVAL];	/* Map from upvalue to variable idx. */
+	VarIndex uvtmp[KP_MAX_UPVAL];	/* Temporary upvalue map. */
+} FuncState;
+
+/* Binary and unary operators. ORDER OPR */
+typedef enum BinOpr {
+	OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW, /* ORDER ARITH */
+	OPR_CONCAT,
+	OPR_NE, OPR_EQ,
+	OPR_LT, OPR_GE, OPR_LE, OPR_GT,
+	OPR_AND, OPR_OR,
+	OPR_NOBINOPR
+} BinOpr;
+
+KP_STATIC_ASSERT((int)BC_ISGE-(int)BC_ISLT == (int)OPR_GE-(int)OPR_LT);
+KP_STATIC_ASSERT((int)BC_ISLE-(int)BC_ISLT == (int)OPR_LE-(int)OPR_LT);
+KP_STATIC_ASSERT((int)BC_ISGT-(int)BC_ISLT == (int)OPR_GT-(int)OPR_LT);
+KP_STATIC_ASSERT((int)BC_SUBVV-(int)BC_ADDVV == (int)OPR_SUB-(int)OPR_ADD);
+KP_STATIC_ASSERT((int)BC_MULVV-(int)BC_ADDVV == (int)OPR_MUL-(int)OPR_ADD);
+KP_STATIC_ASSERT((int)BC_DIVVV-(int)BC_ADDVV == (int)OPR_DIV-(int)OPR_ADD);
+KP_STATIC_ASSERT((int)BC_MODVV-(int)BC_ADDVV == (int)OPR_MOD-(int)OPR_ADD);
+
+/* -- Error handling ------------------------------------------------------ */
+
+static void err_syntax(LexState *ls, ErrMsg em)
+{
+	kp_lex_error(ls, ls->tok, em);
+}
+
+static void err_token(LexState *ls, LexToken tok)
+{
+	kp_lex_error(ls, ls->tok, KP_ERR_XTOKEN, kp_lex_token2str(ls, tok));
+}
+
+static void err_limit(FuncState *fs, uint32_t limit, const char *what)
+{
+	if (fs->linedefined == 0)
+		kp_lex_error(fs->ls, 0, KP_ERR_XLIMM, limit, what);
+	else
+		kp_lex_error(fs->ls, 0, KP_ERR_XLIMF, fs->linedefined,
+				limit, what);
+}
+
+#define checklimit(fs, v, l, m)		if ((v) >= (l)) err_limit(fs, l, m)
+#define checklimitgt(fs, v, l, m)	if ((v) > (l)) err_limit(fs, l, m)
+#define checkcond(ls, c, em)		{ if (!(c)) err_syntax(ls, em); }
+
+/* -- Management of constants --------------------------------------------- */
+
+/* Return bytecode encoding for primitive constant. */
+#define const_pri(e)	((e)->k)
+
+#define tvhaskslot(o)	(is_number(o))
+#define tvkslot(o)	(nvalue(o))
+
+/* Add a number constant. */
+static BCReg const_num(FuncState *fs, ExpDesc *e)
+{
+	ktap_val_t *o;
+
+	kp_assert(expr_isnumk(e));
+	o = kp_tab_set(fs->kt, &e->u.nval);
+	if (tvhaskslot(o))
+		return tvkslot(o);
+	set_number(o, fs->nkn);
+	return fs->nkn++;
+}
+
+/* Add a GC object constant. */
+static BCReg const_gc(FuncState *fs, ktap_obj_t *gc, uint32_t itype)
+{
+	ktap_val_t key, *o;
+
+	setitype(&key, itype);
+	key.val.gc = gc;
+	o = kp_tab_set(fs->kt, &key);
+	if (tvhaskslot(o))
+		return tvkslot(o);
+	set_number(o, fs->nkgc);
+	return fs->nkgc++;
+}
+
+/* Add a string constant. */
+static BCReg const_str(FuncState *fs, ExpDesc *e)
+{
+	kp_assert(expr_isstrk(e) || e->k == VGLOBAL);
+	return const_gc(fs, obj2gco(e->u.sval), KTAP_TSTR);
+}
+
+/* Anchor string constant. */
+ktap_str_t *kp_parse_keepstr(LexState *ls, const char *str, size_t len)
+{
+	ktap_val_t v;
+	ktap_str_t *s = kp_str_new(str, len);
+
+	set_string(&v, s);
+	ktap_val_t *tv = kp_tab_set(ls->fs->kt, &v);
+	if (is_nil(tv))
+		set_bool(tv, 1);
+	return s;
+}
+
+/* -- Jump list handling -------------------------------------------------- */
+
+/* Get next element in jump list. */
+static BCPos jmp_next(FuncState *fs, BCPos pc)
+{
+	ptrdiff_t delta = bc_j(fs->bcbase[pc].ins);
+	if ((BCPos)delta == NO_JMP)
+		return NO_JMP;
+	else
+		return (BCPos)(((ptrdiff_t)pc+1)+delta);
+}
+
+/* Check if any of the instructions on the jump list produce no value. */
+static int jmp_novalue(FuncState *fs, BCPos list)
+{
+	for (; list != NO_JMP; list = jmp_next(fs, list)) {
+		BCIns p = fs->bcbase[list >= 1 ? list-1 : list].ins;
+		if (!(bc_op(p) == BC_ISTC || bc_op(p) == BC_ISFC ||
+			bc_a(p) == NO_REG))
+		return 1;
+	}
+	return 0;
+}
+
+/* Patch register of test instructions. */
+static int jmp_patchtestreg(FuncState *fs, BCPos pc, BCReg reg)
+{
+	BCInsLine *ilp = &fs->bcbase[pc >= 1 ? pc-1 : pc];
+	BCOp op = bc_op(ilp->ins);
+
+	if (op == BC_ISTC || op == BC_ISFC) {
+		if (reg != NO_REG && reg != bc_d(ilp->ins)) {
+			setbc_a(&ilp->ins, reg);
+		} else {/* Nothing to store or already in the right register */
+			setbc_op(&ilp->ins, op+(BC_IST-BC_ISTC));
+			setbc_a(&ilp->ins, 0);
+		}
+	} else if (bc_a(ilp->ins) == NO_REG) {
+		if (reg == NO_REG) {
+			ilp->ins =
+				BCINS_AJ(BC_JMP, bc_a(fs->bcbase[pc].ins), 0);
+		} else {
+			setbc_a(&ilp->ins, reg);
+			if (reg >= bc_a(ilp[1].ins))
+				setbc_a(&ilp[1].ins, reg+1);
+		}
+	} else {
+		return 0;  /* Cannot patch other instructions. */
+	}
+	return 1;
+}
+
+/* Drop values for all instructions on jump list. */
+static void jmp_dropval(FuncState *fs, BCPos list)
+{
+	for (; list != NO_JMP; list = jmp_next(fs, list))
+		jmp_patchtestreg(fs, list, NO_REG);
+}
+
+/* Patch jump instruction to target. */
+static void jmp_patchins(FuncState *fs, BCPos pc, BCPos dest)
+{
+	BCIns *jmp = &fs->bcbase[pc].ins;
+	BCPos offset = dest-(pc+1)+BCBIAS_J;
+
+	kp_assert(dest != NO_JMP);
+	if (offset > BCMAX_D)
+		err_syntax(fs->ls, KP_ERR_XJUMP);
+	setbc_d(jmp, offset);
+}
+
+/* Append to jump list. */
+static void jmp_append(FuncState *fs, BCPos *l1, BCPos l2)
+{
+	if (l2 == NO_JMP) {
+		return;
+	} else if (*l1 == NO_JMP) {
+		*l1 = l2;
+	} else {
+		BCPos list = *l1;
+		BCPos next;
+		/* Find last element. */
+		while ((next = jmp_next(fs, list)) != NO_JMP)
+			list = next;
+		jmp_patchins(fs, list, l2);
+	}
+}
+
+/* Patch jump list and preserve produced values. */
+static void jmp_patchval(FuncState *fs, BCPos list, BCPos vtarget,
+			 BCReg reg, BCPos dtarget)
+{
+	while (list != NO_JMP) {
+		BCPos next = jmp_next(fs, list);
+		if (jmp_patchtestreg(fs, list, reg)) {
+			/* Jump to target with value. */
+			jmp_patchins(fs, list, vtarget);
+		} else {
+			/* Jump to default target. */
+			jmp_patchins(fs, list, dtarget);
+		}
+		list = next;
+	}
+}
+
+/* Jump to following instruction. Append to list of pending jumps. */
+static void jmp_tohere(FuncState *fs, BCPos list)
+{
+	fs->lasttarget = fs->pc;
+	jmp_append(fs, &fs->jpc, list);
+}
+
+/* Patch jump list to target. */
+static void jmp_patch(FuncState *fs, BCPos list, BCPos target)
+{
+	if (target == fs->pc) {
+		jmp_tohere(fs, list);
+	} else {
+		kp_assert(target < fs->pc);
+		jmp_patchval(fs, list, target, NO_REG, target);
+	}
+}
+
+/* -- Bytecode register allocator ----------------------------------------- */
+
+/* Bump frame size. */
+static void bcreg_bump(FuncState *fs, BCReg n)
+{
+	BCReg sz = fs->freereg + n;
+
+	if (sz > fs->framesize) {
+		if (sz >= KP_MAX_SLOTS)
+			err_syntax(fs->ls, KP_ERR_XSLOTS);
+		fs->framesize = (uint8_t)sz;
+	}
+}
+
+/* Reserve registers. */
+static void bcreg_reserve(FuncState *fs, BCReg n)
+{
+	bcreg_bump(fs, n);
+	fs->freereg += n;
+}
+
+/* Free register. */
+static void bcreg_free(FuncState *fs, BCReg reg)
+{
+	if (reg >= fs->nactvar) {
+		fs->freereg--;
+		kp_assert(reg == fs->freereg);
+	}
+}
+
+/* Free register for expression. */
+static void expr_free(FuncState *fs, ExpDesc *e)
+{
+	if (e->k == VNONRELOC)
+		bcreg_free(fs, e->u.s.info);
+}
+
+/* -- Bytecode emitter ---------------------------------------------------- */
+
+/* Emit bytecode instruction. */
+static BCPos bcemit_INS(FuncState *fs, BCIns ins)
+{
+	BCPos pc = fs->pc;
+	LexState *ls = fs->ls;
+
+	jmp_patchval(fs, fs->jpc, pc, NO_REG, pc);
+	fs->jpc = NO_JMP;
+	if (pc >= fs->bclim) {
+		ptrdiff_t base = fs->bcbase - ls->bcstack;
+		checklimit(fs, ls->sizebcstack, KP_MAX_BCINS,
+				"bytecode instructions");
+		if (!ls->bcstack) {
+			ls->bcstack = malloc(sizeof(BCInsLine) * 20);
+			ls->sizebcstack = 20;
+		} else {
+			ls->bcstack = realloc(ls->bcstack,
+				ls->sizebcstack * sizeof(BCInsLine) * 2);
+			ls->sizebcstack = ls->sizebcstack * 2;
+		}
+		fs->bclim = (BCPos)(ls->sizebcstack - base);
+		fs->bcbase = ls->bcstack + base;
+	}
+	fs->bcbase[pc].ins = ins;
+	fs->bcbase[pc].line = ls->lastline;
+	fs->pc = pc+1;
+	return pc;
+}
+
+#define bcemit_ABC(fs, o, a, b, c)	bcemit_INS(fs, BCINS_ABC(o, a, b, c))
+#define bcemit_AD(fs, o, a, d)		bcemit_INS(fs, BCINS_AD(o, a, d))
+#define bcemit_AJ(fs, o, a, j)		bcemit_INS(fs, BCINS_AJ(o, a, j))
+
+#define bcptr(fs, e)			(&(fs)->bcbase[(e)->u.s.info].ins)
+
+/* -- Bytecode emitter for expressions ------------------------------------ */
+
+/* Discharge non-constant expression to any register. */
+static void expr_discharge(FuncState *fs, ExpDesc *e)
+{
+	BCIns ins;
+
+	if (e->k == VUPVAL) {
+		ins = BCINS_AD(BC_UGET, 0, e->u.s.info);
+	} else if (e->k == VGLOBAL) {
+		ins = BCINS_AD(BC_GGET, 0, const_str(fs, e));
+	} else if (e->k == VINDEXED) {
+		BCReg rc = e->u.s.aux;
+		if ((int32_t)rc < 0) {
+			ins = BCINS_ABC(BC_TGETS, 0, e->u.s.info, ~rc);
+		} else if (rc > BCMAX_C) {
+			ins = BCINS_ABC(BC_TGETB, 0, e->u.s.info,
+					rc-(BCMAX_C+1));
+		} else {
+			bcreg_free(fs, rc);
+			ins = BCINS_ABC(BC_TGETV, 0, e->u.s.info, rc);
+		}
+		bcreg_free(fs, e->u.s.info);
+	} else if (e->k == VCALL) {
+		e->u.s.info = e->u.s.aux;
+		e->k = VNONRELOC;
+		return;
+	} else if (e->k == VLOCAL) {
+		e->k = VNONRELOC;
+		return;
+	} else {
+		return;
+	}
+
+	e->u.s.info = bcemit_INS(fs, ins);
+	e->k = VRELOCABLE;
+}
+
+/* Emit bytecode to set a range of registers to nil. */
+static void bcemit_nil(FuncState *fs, BCReg from, BCReg n)
+{
+	if (fs->pc > fs->lasttarget) {  /* No jumps to current position? */
+		BCIns *ip = &fs->bcbase[fs->pc-1].ins;
+		BCReg pto, pfrom = bc_a(*ip);
+		/* Try to merge with the previous instruction. */
+		switch (bc_op(*ip)) {
+		case BC_KPRI:
+			if (bc_d(*ip) != ~KTAP_TNIL) break;
+			if (from == pfrom) {
+				if (n == 1)
+					return;
+			} else if (from == pfrom+1) {
+				from = pfrom;
+				n++;
+			} else {
+				break;
+			}
+			/* Replace KPRI. */
+			*ip = BCINS_AD(BC_KNIL, from, from+n-1);
+			return;
+		case BC_KNIL:
+			pto = bc_d(*ip);
+			/* Can we connect both ranges? */
+			if (pfrom <= from && from <= pto+1) {
+				if (from+n-1 > pto) {
+					/* Patch previous instruction range. */
+					setbc_d(ip, from+n-1);
+				}
+				return;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* Emit new instruction or replace old instruction. */
+	bcemit_INS(fs, n == 1 ? BCINS_AD(BC_KPRI, from, VKNIL) :
+				BCINS_AD(BC_KNIL, from, from+n-1));
+}
+
+/* Discharge an expression to a specific register. Ignore branches. */
+static void expr_toreg_nobranch(FuncState *fs, ExpDesc *e, BCReg reg)
+{
+	BCIns ins;
+
+	expr_discharge(fs, e);
+	if (e->k == VKSTR) {
+		ins = BCINS_AD(BC_KSTR, reg, const_str(fs, e));
+	} else if (e->k == VKNUM) {
+		ktap_number n = expr_numberV(e);
+		if (n >= 0 && n <= 0xffff) {
+			ins = BCINS_AD(BC_KSHORT, reg, (BCReg)(uint16_t)n);
+		} else
+			ins = BCINS_AD(BC_KNUM, reg, const_num(fs, e));
+	} else if (e->k == VRELOCABLE) {
+		setbc_a(bcptr(fs, e), reg);
+		goto noins;
+	} else if (e->k == VNONRELOC) {
+		if (reg == e->u.s.info)
+			goto noins;
+		ins = BCINS_AD(BC_MOV, reg, e->u.s.info);
+	} else if (e->k == VKNIL) {
+		bcemit_nil(fs, reg, 1);
+		goto noins;
+	} else if (e->k <= VKTRUE) {
+		ins = BCINS_AD(BC_KPRI, reg, const_pri(e));
+	} else if (e->k == VARGN) {
+		ins = BCINS_AD(BC_VARGN, reg, e->u.s.info);
+	} else if (e->k > VARGN && e->k < VMAX) {
+		ins = BCINS_AD(e->k - VARGN + BC_VARGN, reg, 0);
+	} else {
+		kp_assert(e->k == VVOID || e->k == VJMP);
+		return;
+	}
+	bcemit_INS(fs, ins);
+ noins:
+	e->u.s.info = reg;
+	e->k = VNONRELOC;
+}
+
+/* Forward declaration. */
+static BCPos bcemit_jmp(FuncState *fs);
+
+/* Discharge an expression to a specific register. */
+static void expr_toreg(FuncState *fs, ExpDesc *e, BCReg reg)
+{
+	expr_toreg_nobranch(fs, e, reg);
+	if (e->k == VJMP) {
+		/* Add it to the true jump list. */
+		jmp_append(fs, &e->t, e->u.s.info);
+	}
+	if (expr_hasjump(e)) {  /* Discharge expression with branches. */
+		BCPos jend, jfalse = NO_JMP, jtrue = NO_JMP;
+		if (jmp_novalue(fs, e->t) || jmp_novalue(fs, e->f)) {
+			BCPos jval = (e->k == VJMP) ? NO_JMP : bcemit_jmp(fs);
+			jfalse = bcemit_AD(fs, BC_KPRI, reg, VKFALSE);
+			bcemit_AJ(fs, BC_JMP, fs->freereg, 1);
+			jtrue = bcemit_AD(fs, BC_KPRI, reg, VKTRUE);
+			jmp_tohere(fs, jval);
+		}
+		jend = fs->pc;
+		fs->lasttarget = jend;
+		jmp_patchval(fs, e->f, jend, reg, jfalse);
+		jmp_patchval(fs, e->t, jend, reg, jtrue);
+	}
+	e->f = e->t = NO_JMP;
+	e->u.s.info = reg;
+	e->k = VNONRELOC;
+}
+
+/* Discharge an expression to the next free register. */
+static void expr_tonextreg(FuncState *fs, ExpDesc *e)
+{
+	expr_discharge(fs, e);
+	expr_free(fs, e);
+	bcreg_reserve(fs, 1);
+	expr_toreg(fs, e, fs->freereg - 1);
+}
+
+/* Discharge an expression to any register. */
+static BCReg expr_toanyreg(FuncState *fs, ExpDesc *e)
+{
+	expr_discharge(fs, e);
+	if (e->k == VNONRELOC) {
+		if (!expr_hasjump(e))
+			return e->u.s.info;  /* Already in a register. */
+		if (e->u.s.info >= fs->nactvar) {
+			/* Discharge to temp. register. */
+			expr_toreg(fs, e, e->u.s.info);
+			return e->u.s.info;
+		}
+	}
+	expr_tonextreg(fs, e);  /* Discharge to next register. */
+	return e->u.s.info;
+}
+
+/* Partially discharge expression to a value. */
+static void expr_toval(FuncState *fs, ExpDesc *e)
+{
+	if (expr_hasjump(e))
+		expr_toanyreg(fs, e);
+	else
+		expr_discharge(fs, e);
+}
+
+/* Emit store for LHS expression. */
+static void bcemit_store(FuncState *fs, ExpDesc *var, ExpDesc *e)
+{
+	BCIns ins;
+
+	if (var->k == VLOCAL) {
+		fs->ls->vstack[var->u.s.aux].info |= VSTACK_VAR_RW;
+		expr_free(fs, e);
+		expr_toreg(fs, e, var->u.s.info);
+		return;
+	} else if (var->k == VUPVAL) {
+		fs->ls->vstack[var->u.s.aux].info |= VSTACK_VAR_RW;
+		expr_toval(fs, e);
+		if (e->k <= VKTRUE)
+			ins = BCINS_AD(BC_USETP, var->u.s.info, const_pri(e));
+		else if (e->k == VKSTR)
+			ins = BCINS_AD(BC_USETS, var->u.s.info,
+					const_str(fs, e));
+		else if (e->k == VKNUM)
+			ins = BCINS_AD(BC_USETN, var->u.s.info,
+					const_num(fs, e));
+		else
+			ins = BCINS_AD(BC_USETV, var->u.s.info,
+					expr_toanyreg(fs, e));
+	} else if (var->k == VGLOBAL) {
+		BCReg ra = expr_toanyreg(fs, e);
+		ins = BCINS_AD(BC_GSET, ra, const_str(fs, var));
+	} else {
+		BCReg ra, rc;
+		kp_assert(var->k == VINDEXED);
+		ra = expr_toanyreg(fs, e);
+		rc = var->u.s.aux;
+		if ((int32_t)rc < 0) {
+			ins = BCINS_ABC(BC_TSETS, ra, var->u.s.info, ~rc);
+		} else if (rc > BCMAX_C) {
+			ins = BCINS_ABC(BC_TSETB, ra, var->u.s.info,
+				rc-(BCMAX_C+1));
+		} else {
+			/* 
+			 * Free late alloced key reg to avoid assert on
+			 * free of value reg. This can only happen when
+			 * called from expr_table(). 
+			 */
+			kp_assert(e->k != VNONRELOC || ra < fs->nactvar ||
+					rc < ra || (bcreg_free(fs, rc),1));
+			ins = BCINS_ABC(BC_TSETV, ra, var->u.s.info, rc);
+		}
+	}
+	bcemit_INS(fs, ins);
+	expr_free(fs, e);
+}
+
+/* Emit store for '+=' expression. */
+static void bcemit_store_incr(FuncState *fs, ExpDesc *var, ExpDesc *e)
+{
+	BCIns ins;
+
+	if (var->k == VLOCAL) {
+		/* don't need to do like "var a=0; a+=1", just use 'a=a+1' */
+		err_syntax(fs->ls, KP_ERR_XSYMBOL);
+		return;
+	} else if (var->k == VUPVAL) {
+		fs->ls->vstack[var->u.s.aux].info |= VSTACK_VAR_RW;
+		expr_toval(fs, e);
+		if (e->k == VKNUM) {
+			ins = BCINS_AD(BC_UINCN, var->u.s.info,
+					const_num(fs, e));
+		} else if (e->k <= VKTRUE || e->k == VKSTR) {
+			err_syntax(fs->ls, KP_ERR_XSYMBOL);
+			return;
+		} else
+			ins = BCINS_AD(BC_UINCV, var->u.s.info,
+					expr_toanyreg(fs, e));
+	} else if (var->k == VGLOBAL) {
+		BCReg ra = expr_toanyreg(fs, e);
+		ins = BCINS_AD(BC_GINC, ra, const_str(fs, var));
+	} else {
+		BCReg ra, rc;
+		kp_assert(var->k == VINDEXED);
+		ra = expr_toanyreg(fs, e);
+		rc = var->u.s.aux;
+		if ((int32_t)rc < 0) {
+			ins = BCINS_ABC(BC_TINCS, ra, var->u.s.info, ~rc);
+		} else if (rc > BCMAX_C) {
+			ins = BCINS_ABC(BC_TINCB, ra, var->u.s.info,
+				rc-(BCMAX_C+1));
+		} else {
+			/* 
+			 * Free late alloced key reg to avoid assert on
+			 * free of value reg. This can only happen when
+			 * called from expr_table(). 
+			 */
+			kp_assert(e->k != VNONRELOC || ra < fs->nactvar ||
+					rc < ra || (bcreg_free(fs, rc),1));
+			ins = BCINS_ABC(BC_TINCV, ra, var->u.s.info, rc);
+		}
+	}
+	bcemit_INS(fs, ins);
+	expr_free(fs, e);
+}
+
+
+/* Emit method lookup expression. */
+static void bcemit_method(FuncState *fs, ExpDesc *e, ExpDesc *key)
+{
+	BCReg idx, func, obj = expr_toanyreg(fs, e);
+
+	expr_free(fs, e);
+	func = fs->freereg;
+	bcemit_AD(fs, BC_MOV, func+1, obj);/* Copy object to first argument. */
+	kp_assert(expr_isstrk(key));
+	idx = const_str(fs, key);
+	if (idx <= BCMAX_C) {
+		bcreg_reserve(fs, 2);
+		bcemit_ABC(fs, BC_TGETS, func, obj, idx);
+	} else {
+		bcreg_reserve(fs, 3);
+		bcemit_AD(fs, BC_KSTR, func+2, idx);
+		bcemit_ABC(fs, BC_TGETV, func, obj, func+2);
+		fs->freereg--;
+	}
+	e->u.s.info = func;
+	e->k = VNONRELOC;
+}
+
+/* -- Bytecode emitter for branches --------------------------------------- */
+
+/* Emit unconditional branch. */
+static BCPos bcemit_jmp(FuncState *fs)
+{
+	BCPos jpc = fs->jpc;
+	BCPos j = fs->pc - 1;
+	BCIns *ip = &fs->bcbase[j].ins;
+
+	fs->jpc = NO_JMP;
+	if ((int32_t)j >= (int32_t)fs->lasttarget && bc_op(*ip) == BC_UCLO)
+		setbc_j(ip, NO_JMP);
+	else
+		j = bcemit_AJ(fs, BC_JMP, fs->freereg, NO_JMP);
+	jmp_append(fs, &j, jpc);
+	return j;
+}
+
+/* Invert branch condition of bytecode instruction. */
+static void invertcond(FuncState *fs, ExpDesc *e)
+{
+	BCIns *ip = &fs->bcbase[e->u.s.info - 1].ins;
+	setbc_op(ip, bc_op(*ip)^1);
+}
+
+/* Emit conditional branch. */
+static BCPos bcemit_branch(FuncState *fs, ExpDesc *e, int cond)
+{
+	BCPos pc;
+
+	if (e->k == VRELOCABLE) {
+		BCIns *ip = bcptr(fs, e);
+		if (bc_op(*ip) == BC_NOT) {
+			*ip = BCINS_AD(cond ? BC_ISF : BC_IST, 0, bc_d(*ip));
+			return bcemit_jmp(fs);
+		}
+	}
+	if (e->k != VNONRELOC) {
+		bcreg_reserve(fs, 1);
+		expr_toreg_nobranch(fs, e, fs->freereg-1);
+	}
+	bcemit_AD(fs, cond ? BC_ISTC : BC_ISFC, NO_REG, e->u.s.info);
+	pc = bcemit_jmp(fs);
+	expr_free(fs, e);
+	return pc;
+}
+
+/* Emit branch on true condition. */
+static void bcemit_branch_t(FuncState *fs, ExpDesc *e)
+{
+	BCPos pc;
+
+	expr_discharge(fs, e);
+	if (e->k == VKSTR || e->k == VKNUM || e->k == VKTRUE)
+		pc = NO_JMP;  /* Never jump. */
+	else if (e->k == VJMP)
+		invertcond(fs, e), pc = e->u.s.info;
+	else if (e->k == VKFALSE || e->k == VKNIL)
+		expr_toreg_nobranch(fs, e, NO_REG), pc = bcemit_jmp(fs);
+	else
+		pc = bcemit_branch(fs, e, 0);
+	jmp_append(fs, &e->f, pc);
+	jmp_tohere(fs, e->t);
+	e->t = NO_JMP;
+}
+
+/* Emit branch on false condition. */
+static void bcemit_branch_f(FuncState *fs, ExpDesc *e)
+{
+	BCPos pc;
+
+	expr_discharge(fs, e);
+	if (e->k == VKNIL || e->k == VKFALSE)
+		pc = NO_JMP;  /* Never jump. */
+	else if (e->k == VJMP)
+		pc = e->u.s.info;
+	else if (e->k == VKSTR || e->k == VKNUM || e->k == VKTRUE)
+		expr_toreg_nobranch(fs, e, NO_REG), pc = bcemit_jmp(fs);
+	else
+		pc = bcemit_branch(fs, e, 1);
+	jmp_append(fs, &e->t, pc);
+	jmp_tohere(fs, e->f);
+	e->f = NO_JMP;
+}
+
+/* -- Bytecode emitter for operators -------------------------------------- */
+
+static ktap_number number_foldarith(ktap_number x, ktap_number y, int op)
+{
+	switch (op) {
+	case OPR_ADD - OPR_ADD: return x + y;
+	case OPR_SUB - OPR_ADD: return x - y;
+	case OPR_MUL - OPR_ADD: return x * y;
+	case OPR_DIV - OPR_ADD: return x / y;
+	default: return x;
+	}
+}
+
+/* Try constant-folding of arithmetic operators. */
+static int foldarith(BinOpr opr, ExpDesc *e1, ExpDesc *e2)
+{
+	ktap_val_t o;
+	ktap_number n;
+
+	if (!expr_isnumk_nojump(e1) || !expr_isnumk_nojump(e2))
+		return 0;
+
+	if (opr == OPR_DIV && expr_numberV(e2) == 0)
+		return 0; /* do not attempt to divide by 0 */
+
+	if (opr == OPR_MOD)
+		return 0; /* ktap current do not suppor pow arith */
+
+	n = number_foldarith(expr_numberV(e1), expr_numberV(e2),
+				(int)opr-OPR_ADD);
+	set_number(&o, n);
+	set_number(&e1->u.nval, n);
+	return 1;
+}
+
+/* Emit arithmetic operator. */
+static void bcemit_arith(FuncState *fs, BinOpr opr, ExpDesc *e1, ExpDesc *e2)
+{
+	BCReg rb, rc, t;
+	uint32_t op;
+
+	if (foldarith(opr, e1, e2))
+		return;
+	if (opr == OPR_POW) {
+		op = BC_POW;
+		rc = expr_toanyreg(fs, e2);
+		rb = expr_toanyreg(fs, e1);
+	} else {
+		op = opr-OPR_ADD+BC_ADDVV;
+		/*
+		 * Must discharge 2nd operand first since VINDEXED
+		 * might free regs.
+		 */
+		expr_toval(fs, e2);
+		if (expr_isnumk(e2) && (rc = const_num(fs, e2)) <= BCMAX_C)
+			op -= BC_ADDVV-BC_ADDVN;
+		else
+			rc = expr_toanyreg(fs, e2);
+		/* 1st operand discharged by bcemit_binop_left,
+		 * but need KNUM/KSHORT. */
+		kp_assert(expr_isnumk(e1) || e1->k == VNONRELOC);
+		expr_toval(fs, e1);
+		/* Avoid two consts to satisfy bytecode constraints. */
+		if (expr_isnumk(e1) && !expr_isnumk(e2) &&
+			(t = const_num(fs, e1)) <= BCMAX_B) {
+			rb = rc; rc = t; op -= BC_ADDVV-BC_ADDNV;
+		} else {
+			rb = expr_toanyreg(fs, e1);
+		}
+	}
+	/* Using expr_free might cause asserts if the order is wrong. */
+	if (e1->k == VNONRELOC && e1->u.s.info >= fs->nactvar)
+		fs->freereg--;
+	if (e2->k == VNONRELOC && e2->u.s.info >= fs->nactvar)
+		fs->freereg--;
+	e1->u.s.info = bcemit_ABC(fs, op, 0, rb, rc);
+	e1->k = VRELOCABLE;
+}
+
+/* Emit comparison operator. */
+static void bcemit_comp(FuncState *fs, BinOpr opr, ExpDesc *e1, ExpDesc *e2)
+{
+	ExpDesc *eret = e1;
+	BCIns ins;
+
+	expr_toval(fs, e1);
+	if (opr == OPR_EQ || opr == OPR_NE) {
+		BCOp op = opr == OPR_EQ ? BC_ISEQV : BC_ISNEV;
+		BCReg ra;
+
+		if (expr_isk(e1)) { /* Need constant in 2nd arg. */
+			e1 = e2;
+			e2 = eret;
+		}
+		ra = expr_toanyreg(fs, e1);  /* First arg must be in a reg. */
+		expr_toval(fs, e2);
+		switch (e2->k) {
+		case VKNIL: case VKFALSE: case VKTRUE:
+			ins = BCINS_AD(op+(BC_ISEQP-BC_ISEQV), ra,
+					const_pri(e2));
+			break;
+		case VKSTR:
+			ins = BCINS_AD(op+(BC_ISEQS-BC_ISEQV), ra,
+					const_str(fs, e2));
+			break;
+		case VKNUM:
+			ins = BCINS_AD(op+(BC_ISEQN-BC_ISEQV), ra,
+					const_num(fs, e2));
+			break;
+		default:
+			ins = BCINS_AD(op, ra, expr_toanyreg(fs, e2));
+			break;
+		}
+	} else {
+		uint32_t op = opr-OPR_LT+BC_ISLT;
+		BCReg ra, rd;
+		if ((op-BC_ISLT) & 1) {  /* GT -> LT, GE -> LE */
+			e1 = e2; e2 = eret;  /* Swap operands. */
+			op = ((op-BC_ISLT)^3)+BC_ISLT;
+			expr_toval(fs, e1);
+		}
+		rd = expr_toanyreg(fs, e2);
+		ra = expr_toanyreg(fs, e1);
+		ins = BCINS_AD(op, ra, rd);
+	}
+	/* Using expr_free might cause asserts if the order is wrong. */
+	if (e1->k == VNONRELOC && e1->u.s.info >= fs->nactvar)
+		fs->freereg--;
+	if (e2->k == VNONRELOC && e2->u.s.info >= fs->nactvar)
+		fs->freereg--;
+	bcemit_INS(fs, ins);
+	eret->u.s.info = bcemit_jmp(fs);
+	eret->k = VJMP;
+}
+
+/* Fixup left side of binary operator. */
+static void bcemit_binop_left(FuncState *fs, BinOpr op, ExpDesc *e)
+{
+	if (op == OPR_AND) {
+		bcemit_branch_t(fs, e);
+	} else if (op == OPR_OR) {
+		bcemit_branch_f(fs, e);
+	} else if (op == OPR_CONCAT) {
+		expr_tonextreg(fs, e);
+	} else if (op == OPR_EQ || op == OPR_NE) {
+		if (!expr_isk_nojump(e))
+			expr_toanyreg(fs, e);
+	} else {
+		if (!expr_isnumk_nojump(e))
+			expr_toanyreg(fs, e);
+	}
+}
+
+/* Emit binary operator. */
+static void bcemit_binop(FuncState *fs, BinOpr op, ExpDesc *e1, ExpDesc *e2)
+{
+	if (op <= OPR_POW) {
+		bcemit_arith(fs, op, e1, e2);
+	} else if (op == OPR_AND) {
+		kp_assert(e1->t == NO_JMP);  /* List must be closed. */
+		expr_discharge(fs, e2);
+		jmp_append(fs, &e2->f, e1->f);
+		*e1 = *e2;
+	} else if (op == OPR_OR) {
+		kp_assert(e1->f == NO_JMP);  /* List must be closed. */
+		expr_discharge(fs, e2);
+		jmp_append(fs, &e2->t, e1->t);
+		*e1 = *e2;
+	} else if (op == OPR_CONCAT) {
+		expr_toval(fs, e2);
+		if (e2->k == VRELOCABLE && bc_op(*bcptr(fs, e2)) == BC_CAT) {
+			kp_assert(e1->u.s.info == bc_b(*bcptr(fs, e2))-1);
+			expr_free(fs, e1);
+			setbc_b(bcptr(fs, e2), e1->u.s.info);
+			e1->u.s.info = e2->u.s.info;
+		} else {
+			expr_tonextreg(fs, e2);
+			expr_free(fs, e2);
+			expr_free(fs, e1);
+			e1->u.s.info = bcemit_ABC(fs, BC_CAT, 0, e1->u.s.info,
+								 e2->u.s.info);
+		}
+		e1->k = VRELOCABLE;
+	} else {
+		kp_assert(op == OPR_NE || op == OPR_EQ || op == OPR_LT ||
+			  op == OPR_GE || op == OPR_LE || op == OPR_GT);
+		bcemit_comp(fs, op, e1, e2);
+	}
+}
+
+/* Emit unary operator. */
+static void bcemit_unop(FuncState *fs, BCOp op, ExpDesc *e)
+{
+	if (op == BC_NOT) {
+		/* Swap true and false lists. */
+		{ BCPos temp = e->f; e->f = e->t; e->t = temp; }
+		jmp_dropval(fs, e->f);
+		jmp_dropval(fs, e->t);
+		expr_discharge(fs, e);
+		if (e->k == VKNIL || e->k == VKFALSE) {
+			e->k = VKTRUE;
+			return;
+		} else if (expr_isk(e)) {
+			e->k = VKFALSE;
+			return;
+		} else if (e->k == VJMP) {
+			invertcond(fs, e);
+			return;
+		} else if (e->k == VRELOCABLE) {
+			bcreg_reserve(fs, 1);
+			setbc_a(bcptr(fs, e), fs->freereg-1);
+			e->u.s.info = fs->freereg-1;
+			e->k = VNONRELOC;
+		} else {
+			kp_assert(e->k == VNONRELOC);
+		}
+	} else {
+		kp_assert(op == BC_UNM || op == BC_LEN);
+		/* Constant-fold negations. */
+		if (op == BC_UNM && !expr_hasjump(e)) {
+			/* Avoid folding to -0. */
+			if (expr_isnumk(e) && !expr_numiszero(e)) {
+				ktap_val_t *o = expr_numtv(e);
+				if (is_number(o))
+					set_number(o, -nvalue(o));
+				return;
+			}
+		}
+		expr_toanyreg(fs, e);
+	}
+	expr_free(fs, e);
+	e->u.s.info = bcemit_AD(fs, op, 0, e->u.s.info);
+	e->k = VRELOCABLE;
+}
+
+/* -- Lexer support ------------------------------------------------------- */
+
+/* Check and consume optional token. */
+static int lex_opt(LexState *ls, LexToken tok)
+{
+	if (ls->tok == tok) {
+		kp_lex_next(ls);
+		return 1;
+	}
+	return 0;
+}
+
+/* Check and consume token. */
+static void lex_check(LexState *ls, LexToken tok)
+{
+	if (ls->tok != tok)
+		err_token(ls, tok);
+	kp_lex_next(ls);
+}
+
+/* Check for matching token. */
+static void lex_match(LexState *ls, LexToken what, LexToken who, BCLine line)
+{
+	if (!lex_opt(ls, what)) {
+		if (line == ls->linenumber) {
+			err_token(ls, what);
+		} else {
+			const char *swhat = kp_lex_token2str(ls, what);
+			const char *swho = kp_lex_token2str(ls, who);
+			kp_lex_error(ls, ls->tok, KP_ERR_XMATCH, swhat, swho,
+								line);
+		}
+	}
+}
+
+/* Check for string token. */
+static ktap_str_t *lex_str(LexState *ls)
+{
+	ktap_str_t *s;
+
+	if (ls->tok != TK_name)
+		err_token(ls, TK_name);
+	s = rawtsvalue(&ls->tokval);
+	kp_lex_next(ls);
+	return s;
+}
+
+/* -- Variable handling --------------------------------------------------- */
+
+#define var_get(ls, fs, i)	((ls)->vstack[(fs)->varmap[(i)]])
+
+/* Define a new local variable. */
+static void var_new(LexState *ls, BCReg n, ktap_str_t *name)
+{
+	FuncState *fs = ls->fs;
+	int vtop = ls->vtop;
+
+	checklimit(fs, fs->nactvar+n, KP_MAX_LOCVAR, "local variables");
+	if (vtop >= ls->sizevstack) {
+		if (ls->sizevstack >= KP_MAX_VSTACK)
+			kp_lex_error(ls, 0, KP_ERR_XLIMC, KP_MAX_VSTACK);
+		if (!ls->vstack) {
+			ls->vstack = malloc(sizeof(VarInfo) * 20);
+			ls->sizevstack = 20;
+		} else {
+			ls->vstack = realloc(ls->vstack,
+				ls->sizevstack * sizeof(VarInfo) * 2);
+			ls->sizevstack = ls->sizevstack * 2;
+		}
+	}
+	kp_assert((uintptr_t)name < VARNAME__MAX ||
+			kp_tab_getstr(fs->kt, name) != NULL);
+	ls->vstack[vtop].name = name;
+	fs->varmap[fs->nactvar+n] = (uint16_t)vtop;
+	ls->vtop = vtop+1;
+}
+
+#define var_new_lit(ls, n, v) \
+	var_new(ls, (n), kp_parse_keepstr(ls, "" v, sizeof(v)-1))
+
+#define var_new_fixed(ls, n, vn) \
+	var_new(ls, (n), (ktap_str_t *)(uintptr_t)(vn))
+
+/* Add local variables. */
+static void var_add(LexState *ls, BCReg nvars)
+{
+	FuncState *fs = ls->fs;
+	BCReg nactvar = fs->nactvar;
+
+	while (nvars--) {
+		VarInfo *v = &var_get(ls, fs, nactvar);
+		v->startpc = fs->pc;
+		v->slot = nactvar++;
+		v->info = 0;
+	}
+	fs->nactvar = nactvar;
+}
+
+/* Remove local variables. */
+static void var_remove(LexState *ls, BCReg tolevel)
+{
+	FuncState *fs = ls->fs;
+	while (fs->nactvar > tolevel)
+		var_get(ls, fs, --fs->nactvar).endpc = fs->pc;
+}
+
+/* Lookup local variable name. */
+static BCReg var_lookup_local(FuncState *fs, ktap_str_t *n)
+{
+	int i;
+	
+	for (i = fs->nactvar-1; i >= 0; i--) {
+		if (n == var_get(fs->ls, fs, i).name)
+			return (BCReg)i;
+	}
+	return (BCReg)-1;  /* Not found. */
+}
+
+/* Lookup or add upvalue index. */
+static int var_lookup_uv(FuncState *fs, int vidx, ExpDesc *e)
+{
+	int i, n = fs->nuv;
+
+	for (i = 0; i < n; i++)
+		if (fs->uvmap[i] == vidx)
+			return i;  /* Already exists. */
+
+	/* Otherwise create a new one. */
+	checklimit(fs, fs->nuv, KP_MAX_UPVAL, "upvalues");
+	kp_assert(e->k == VLOCAL || e->k == VUPVAL);
+	fs->uvmap[n] = (uint16_t)vidx;
+	fs->uvtmp[n] = (uint16_t)(e->k == VLOCAL ? vidx :
+			KP_MAX_VSTACK+e->u.s.info);
+	fs->nuv = n+1;
+	return n;
+}
+
+/* Forward declaration. */
+static void fscope_uvmark(FuncState *fs, BCReg level);
+
+/* Recursively lookup variables in enclosing functions. */
+static int var_lookup_(FuncState *fs, ktap_str_t *name, ExpDesc *e,
+			 int first)
+{
+	if (fs) {
+		BCReg reg = var_lookup_local(fs, name);
+		if ((int32_t)reg >= 0) {  /* Local in this function? */
+			expr_init(e, VLOCAL, reg);
+			if (!first) {
+				/* Scope now has an upvalue. */
+				fscope_uvmark(fs, reg);
+			}
+			return (int)(e->u.s.aux = (uint32_t)fs->varmap[reg]);
+		} else {
+			/* Var in outer func? */
+			int vidx = var_lookup_(fs->prev, name, e, 0);
+			if ((int32_t)vidx >= 0) {
+				/* Yes, make it an upvalue here. */
+				e->u.s.info =
+					(uint8_t)var_lookup_uv(fs, vidx, e);
+				e->k = VUPVAL;
+				return vidx;
+			}
+		}
+	} else {  /* Not found in any function, must be a global. */
+		expr_init(e, VGLOBAL, 0);
+		e->u.sval = name;
+	}
+	return (int)-1;  /* Global. */
+}
+
+/* Lookup variable name. */
+#define var_lookup(ls, e) \
+	var_lookup_((ls)->fs, lex_str(ls), (e), 1)
+
+/* -- Goto an label handling ---------------------------------------------- */
+
+/* Add a new goto or label. */
+static int gola_new(LexState *ls, ktap_str_t *name, uint8_t info, BCPos pc)
+{
+	FuncState *fs = ls->fs;
+	int vtop = ls->vtop;
+
+	if (vtop >= ls->sizevstack) {
+		if (ls->sizevstack >= KP_MAX_VSTACK)
+			kp_lex_error(ls, 0, KP_ERR_XLIMC, KP_MAX_VSTACK);
+		if (!ls->vstack) {
+			ls->vstack = malloc(sizeof(VarInfo) * 20);
+			ls->sizevstack = 20;
+		} else {
+			ls->vstack = realloc(ls->vstack,
+					ls->sizevstack * sizeof(VarInfo) * 2);
+			ls->sizevstack = ls->sizevstack * 2;
+		}
+	}
+	kp_assert(name == NAME_BREAK ||
+		  kp_tab_getstr(fs->kt, name) != NULL);
+	ls->vstack[vtop].name = name;
+	ls->vstack[vtop].startpc = pc;
+	ls->vstack[vtop].slot = (uint8_t)fs->nactvar;
+	ls->vstack[vtop].info = info;
+	ls->vtop = vtop+1;
+	return vtop;
+}
+
+#define gola_isgoto(v)		((v)->info & VSTACK_GOTO)
+#define gola_islabel(v)		((v)->info & VSTACK_LABEL)
+#define gola_isgotolabel(v)	((v)->info & (VSTACK_GOTO|VSTACK_LABEL))
+
+/* Patch goto to jump to label. */
+static void gola_patch(LexState *ls, VarInfo *vg, VarInfo *vl)
+{
+	FuncState *fs = ls->fs;
+	BCPos pc = vg->startpc;
+
+	vg->name = NULL; /* Invalidate pending goto. */
+	setbc_a(&fs->bcbase[pc].ins, vl->slot);
+	jmp_patch(fs, pc, vl->startpc);
+}
+
+/* Patch goto to close upvalues. */
+static void gola_close(LexState *ls, VarInfo *vg)
+{
+	FuncState *fs = ls->fs;
+	BCPos pc = vg->startpc;
+	BCIns *ip = &fs->bcbase[pc].ins;
+	kp_assert(gola_isgoto(vg));
+	kp_assert(bc_op(*ip) == BC_JMP || bc_op(*ip) == BC_UCLO);
+	setbc_a(ip, vg->slot);
+	if (bc_op(*ip) == BC_JMP) {
+		BCPos next = jmp_next(fs, pc);
+		if (next != NO_JMP)
+			jmp_patch(fs, next, pc);  /* Jump to UCLO. */
+		setbc_op(ip, BC_UCLO);  /* Turn into UCLO. */
+		setbc_j(ip, NO_JMP);
+	}
+}
+
+/* Resolve pending forward gotos for label. */
+static void gola_resolve(LexState *ls, FuncScope *bl, int idx)
+{
+	VarInfo *vg = ls->vstack + bl->vstart;
+	VarInfo *vl = ls->vstack + idx;
+	for (; vg < vl; vg++)
+		if (vg->name == vl->name && gola_isgoto(vg)) {
+			if (vg->slot < vl->slot) {
+				ktap_str_t *name =
+					var_get(ls, ls->fs, vg->slot).name;
+				kp_assert((uintptr_t)name >= VARNAME__MAX);
+				ls->linenumber =
+					ls->fs->bcbase[vg->startpc].line;
+				kp_assert(vg->name != NAME_BREAK);
+				kp_lex_error(ls, 0, KP_ERR_XGSCOPE,
+				getstr(vg->name), getstr(name));
+			}
+			gola_patch(ls, vg, vl);
+		}
+}
+
+/* Fixup remaining gotos and labels for scope. */
+static void gola_fixup(LexState *ls, FuncScope *bl)
+{
+	VarInfo *v = ls->vstack + bl->vstart;
+	VarInfo *ve = ls->vstack + ls->vtop;
+
+	for (; v < ve; v++) {
+		ktap_str_t *name = v->name;
+		/* Only consider remaining valid gotos/labels. */
+		if (name != NULL) {
+			if (gola_islabel(v)) {
+				VarInfo *vg;
+				/* Invalidate label that goes out of scope. */
+				v->name = NULL;
+				/* Resolve pending backward gotos. */
+				for (vg = v+1; vg < ve; vg++)
+					if (vg->name == name &&
+						gola_isgoto(vg)) {
+						if ((bl->flags&FSCOPE_UPVAL) &&
+							 vg->slot > v->slot)
+							gola_close(ls, vg);
+						gola_patch(ls, vg, v);
+					}
+			} else if (gola_isgoto(v)) {
+				/* Propagate goto or break to outer scope. */
+				if (bl->prev) {
+					bl->prev->flags |= name == NAME_BREAK ? 						FSCOPE_BREAK : FSCOPE_GOLA;
+					v->slot = bl->nactvar;
+					if ((bl->flags & FSCOPE_UPVAL))
+						gola_close(ls, v);
+				} else {
+					ls->linenumber =
+					ls->fs->bcbase[v->startpc].line;
+					if (name == NAME_BREAK)
+						kp_lex_error(ls, 0, KP_ERR_XBREAK);
+					else
+						kp_lex_error(ls, 0, KP_ERR_XLUNDEF, getstr(name));
+				}
+			}
+		}
+	}
+}
+
+/* Find existing label. */
+static VarInfo *gola_findlabel(LexState *ls, ktap_str_t *name)
+{
+	VarInfo *v = ls->vstack + ls->fs->bl->vstart;
+	VarInfo *ve = ls->vstack + ls->vtop;
+
+	for (; v < ve; v++)
+		if (v->name == name && gola_islabel(v))
+			return v;
+	return NULL;
+}
+
+/* -- Scope handling ------------------------------------------------------ */
+
+/* Begin a scope. */
+static void fscope_begin(FuncState *fs, FuncScope *bl, int flags)
+{
+	bl->nactvar = (uint8_t)fs->nactvar;
+	bl->flags = flags;
+	bl->vstart = fs->ls->vtop;
+	bl->prev = fs->bl;
+	fs->bl = bl;
+	kp_assert(fs->freereg == fs->nactvar);
+}
+
+/* End a scope. */
+static void fscope_end(FuncState *fs)
+{
+	FuncScope *bl = fs->bl;
+	LexState *ls = fs->ls;
+
+	fs->bl = bl->prev;
+	var_remove(ls, bl->nactvar);
+	fs->freereg = fs->nactvar;
+	kp_assert(bl->nactvar == fs->nactvar);
+	if ((bl->flags & (FSCOPE_UPVAL|FSCOPE_NOCLOSE)) == FSCOPE_UPVAL)
+		bcemit_AJ(fs, BC_UCLO, bl->nactvar, 0);
+	if ((bl->flags & FSCOPE_BREAK)) {
+		if ((bl->flags & FSCOPE_LOOP)) {
+			int idx = gola_new(ls, NAME_BREAK, VSTACK_LABEL,
+						fs->pc);
+			ls->vtop = idx;  /* Drop break label immediately. */
+			gola_resolve(ls, bl, idx);
+			return;
+		}  /* else: need the fixup step to propagate the breaks. */
+	} else if (!(bl->flags & FSCOPE_GOLA)) {
+		return;
+	}
+	gola_fixup(ls, bl);
+}
+
+/* Mark scope as having an upvalue. */
+static void fscope_uvmark(FuncState *fs, BCReg level)
+{
+	FuncScope *bl;
+
+	for (bl = fs->bl; bl && bl->nactvar > level; bl = bl->prev);
+	if (bl)
+		bl->flags |= FSCOPE_UPVAL;
+}
+
+/* -- Function state management ------------------------------------------- */
+
+/* Fixup bytecode for prototype. */
+static void fs_fixup_bc(FuncState *fs, ktap_proto_t *pt, BCIns *bc, int n)
+{
+	BCInsLine *base = fs->bcbase;
+	int i;
+
+	pt->sizebc = n;
+	bc[0] = BCINS_AD((fs->flags & PROTO_VARARG) ? BC_FUNCV : BC_FUNCF,
+			 fs->framesize, 0);
+	for (i = 1; i < n; i++)
+		bc[i] = base[i].ins;
+}
+
+/* Fixup upvalues for child prototype, step #2. */
+static void fs_fixup_uv2(FuncState *fs, ktap_proto_t *pt)
+{
+	VarInfo *vstack = fs->ls->vstack;
+	uint16_t *uv = pt->uv;
+	int i, n = pt->sizeuv;
+
+	for (i = 0; i < n; i++) {
+		VarIndex vidx = uv[i];
+		if (vidx >= KP_MAX_VSTACK)
+			uv[i] = vidx - KP_MAX_VSTACK;
+		else if ((vstack[vidx].info & VSTACK_VAR_RW))
+			uv[i] = vstack[vidx].slot | PROTO_UV_LOCAL;
+		else
+			uv[i] = vstack[vidx].slot | PROTO_UV_LOCAL |
+					PROTO_UV_IMMUTABLE;
+	}
+}
+
+/* Fixup constants for prototype. */
+static void fs_fixup_k(FuncState *fs, ktap_proto_t *pt, void *kptr)
+{
+	ktap_tab_t *kt;
+	ktap_node_t *node;
+	int i, hmask;
+
+	checklimitgt(fs, fs->nkn, BCMAX_D+1, "constants");
+	checklimitgt(fs, fs->nkgc, BCMAX_D+1, "constants");
+
+	pt->k = kptr;
+	pt->sizekn = fs->nkn;
+	pt->sizekgc = fs->nkgc;
+	kt = fs->kt;
+	node = kt->node;
+	hmask = kt->hmask;
+	for (i = 0; i <= hmask; i++) {
+		ktap_node_t *n = &node[i];
+
+		if (tvhaskslot(&n->val)) {
+			ptrdiff_t kidx = (ptrdiff_t)tvkslot(&n->val);
+			kp_assert(!is_number(&n->key));
+			if (is_number(&n->key)) {
+				ktap_val_t *tv = &((ktap_val_t *)kptr)[kidx];
+				*tv = n->key;
+			} else {
+				ktap_obj_t *o = n->key.val.gc;
+				ktap_obj_t **v = (ktap_obj_t **)kptr;
+				v[~kidx] = o;
+				if (is_proto(&n->key))
+					fs_fixup_uv2(fs, (ktap_proto_t *)o);
+			}
+		}
+	}
+}
+
+/* Fixup upvalues for prototype, step #1. */
+static void fs_fixup_uv1(FuncState *fs, ktap_proto_t *pt, uint16_t *uv)
+{
+	pt->uv = uv;
+	pt->sizeuv = fs->nuv;
+	memcpy(uv, fs->uvtmp, fs->nuv*sizeof(VarIndex));
+}
+
+#ifndef KTAP_DISABLE_LINEINFO
+/* Prepare lineinfo for prototype. */
+static size_t fs_prep_line(FuncState *fs, BCLine numline)
+{
+	return (fs->pc-1) << (numline < 256 ? 0 : numline < 65536 ? 1 : 2);
+}
+
+/* Fixup lineinfo for prototype. */
+static void fs_fixup_line(FuncState *fs, ktap_proto_t *pt,
+			  void *lineinfo, BCLine numline)
+{
+	BCInsLine *base = fs->bcbase + 1;
+	BCLine first = fs->linedefined;
+	int i = 0, n = fs->pc-1;
+
+	pt->firstline = fs->linedefined;
+	pt->numline = numline;
+	pt->lineinfo = lineinfo;
+	if (numline < 256) {
+		uint8_t *li = (uint8_t *)lineinfo;
+		do {
+			BCLine delta = base[i].line - first;
+			kp_assert(delta >= 0 && delta < 256);
+			li[i] = (uint8_t)delta;
+		} while (++i < n);
+	} else if (numline < 65536) {
+		uint16_t *li = (uint16_t *)lineinfo;
+		do {
+			BCLine delta = base[i].line - first;
+			kp_assert(delta >= 0 && delta < 65536);
+			li[i] = (uint16_t)delta;
+		} while (++i < n);
+	} else {
+		uint32_t *li = (uint32_t *)lineinfo;
+		do {
+			BCLine delta = base[i].line - first;
+			kp_assert(delta >= 0);
+			li[i] = (uint32_t)delta;
+		} while (++i < n);
+	}
+}
+
+/* Prepare variable info for prototype. */
+static size_t fs_prep_var(LexState *ls, FuncState *fs, size_t *ofsvar)
+{
+	VarInfo *vs =ls->vstack, *ve;
+	int i, n;
+	BCPos lastpc;
+
+	kp_buf_reset(&ls->sb);  /* Copy to temp. string buffer. */
+	/* Store upvalue names. */
+	for (i = 0, n = fs->nuv; i < n; i++) {
+		ktap_str_t *s = vs[fs->uvmap[i]].name;
+		int len = s->len+1;
+		char *p = kp_buf_more(&ls->sb, len);
+		p = kp_buf_wmem(p, getstr(s), len);
+		setsbufP(&ls->sb, p);
+	}
+
+	*ofsvar = sbuflen(&ls->sb);
+	lastpc = 0;
+	/* Store local variable names and compressed ranges. */
+	for (ve = vs + ls->vtop, vs += fs->vbase; vs < ve; vs++) {
+		if (!gola_isgotolabel(vs)) {
+			ktap_str_t *s = vs->name;
+			BCPos startpc;
+			char *p;
+			if ((uintptr_t)s < VARNAME__MAX) {
+				p = kp_buf_more(&ls->sb, 1 + 2*5);
+				*p++ = (char)(uintptr_t)s;
+			} else {
+				int len = s->len+1;
+				p = kp_buf_more(&ls->sb, len + 2*5);
+				p = kp_buf_wmem(p, getstr(s), len);
+			}
+			startpc = vs->startpc;
+			p = strfmt_wuleb128(p, startpc-lastpc);
+			p = strfmt_wuleb128(p, vs->endpc-startpc);
+			setsbufP(&ls->sb, p);
+			lastpc = startpc;
+		}
+	}
+
+	kp_buf_putb(&ls->sb, '\0');  /* Terminator for varinfo. */
+	return sbuflen(&ls->sb);
+}
+
+/* Fixup variable info for prototype. */
+static void fs_fixup_var(LexState *ls, ktap_proto_t *pt, uint8_t *p,
+			 size_t ofsvar)
+{
+	pt->uvinfo = p;
+	pt->varinfo = (char *)p + ofsvar;
+	/* Copy from temp. buffer. */
+	memcpy(p, sbufB(&ls->sb), sbuflen(&ls->sb));
+}
+#else
+
+/* Initialize with empty debug info, if disabled. */
+#define fs_prep_line(fs, numline)		(UNUSED(numline), 0)
+#define fs_fixup_line(fs, pt, li, numline) \
+  pt->firstline = pt->numline = 0, (pt)->lineinfo = NULL
+#define fs_prep_var(ls, fs, ofsvar)		(UNUSED(ofsvar), 0)
+#define fs_fixup_var(ls, pt, p, ofsvar) \
+  (pt)->uvinfo = NULL, (pt)->varinfo = NULL
+
+#endif
+
+/* Check if bytecode op returns. */
+static int bcopisret(BCOp op)
+{
+	switch (op) {
+	case BC_CALLMT: case BC_CALLT:
+	case BC_RETM: case BC_RET: case BC_RET0: case BC_RET1:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/* Fixup return instruction for prototype. */
+static void fs_fixup_ret(FuncState *fs)
+{
+	BCPos lastpc = fs->pc;
+
+	if (lastpc <= fs->lasttarget ||
+		!bcopisret(bc_op(fs->bcbase[lastpc-1].ins))) {
+		if ((fs->bl->flags & FSCOPE_UPVAL))
+			bcemit_AJ(fs, BC_UCLO, 0, 0);
+		bcemit_AD(fs, BC_RET0, 0, 1);  /* Need final return. */
+	}
+	fs->bl->flags |= FSCOPE_NOCLOSE;  /* Handled above. */
+	fscope_end(fs);
+	kp_assert(fs->bl == NULL);
+	/* May need to fixup returns encoded before first function
+	 * was created. */
+	if (fs->flags & PROTO_FIXUP_RETURN) {
+		BCPos pc;
+		for (pc = 1; pc < lastpc; pc++) {
+			BCIns ins = fs->bcbase[pc].ins;
+			BCPos offset;
+			switch (bc_op(ins)) {
+			case BC_CALLMT: case BC_CALLT:
+			case BC_RETM: case BC_RET: case BC_RET0: case BC_RET1:
+				/* Copy original instruction. */
+				offset = bcemit_INS(fs, ins);
+				fs->bcbase[offset].line = fs->bcbase[pc].line;
+				offset = offset-(pc+1)+BCBIAS_J;
+				if (offset > BCMAX_D)
+					err_syntax(fs->ls, KP_ERR_XFIXUP);
+				/* Replace with UCLO plus branch. */
+				fs->bcbase[pc].ins = BCINS_AD(BC_UCLO, 0,
+								offset);
+				break;
+			case BC_UCLO:
+				return;  /* We're done. */
+			default:
+				break;
+			}
+		}
+	}
+}
+
+/* Finish a FuncState and return the new prototype. */
+static ktap_proto_t *fs_finish(LexState *ls, BCLine line)
+{
+	FuncState *fs = ls->fs;
+	BCLine numline = line - fs->linedefined;
+	size_t sizept, ofsk, ofsuv, ofsli, ofsdbg, ofsvar;
+	ktap_proto_t *pt;
+
+	/* Apply final fixups. */
+	fs_fixup_ret(fs);
+
+	/* Calculate total size of prototype including all colocated arrays. */
+	sizept = sizeof(ktap_proto_t) + fs->pc*sizeof(BCIns) +
+			fs->nkgc*sizeof(ktap_obj_t *);
+	sizept = (sizept + sizeof(ktap_val_t)-1) & ~(sizeof(ktap_val_t)-1);
+	ofsk = sizept; sizept += fs->nkn*sizeof(ktap_val_t);
+	ofsuv = sizept; sizept += ((fs->nuv+1)&~1)*2;
+	ofsli = sizept; sizept += fs_prep_line(fs, numline);
+	ofsdbg = sizept; sizept += fs_prep_var(ls, fs, &ofsvar);
+
+	/* Allocate prototype and initialize its fields. */
+	pt = (ktap_proto_t *)malloc((int)sizept);
+	pt->gct = ~KTAP_TPROTO;
+	pt->sizept = (int)sizept;
+	pt->flags =
+		(uint8_t)(fs->flags & ~(PROTO_HAS_RETURN|PROTO_FIXUP_RETURN));
+	pt->numparams = fs->numparams;
+	pt->framesize = fs->framesize;
+	pt->chunkname = ls->chunkname;
+
+	/* Close potentially uninitialized gap between bc and kgc. */
+	*(uint32_t *)((char *)pt + ofsk - sizeof(ktap_obj_t *)*(fs->nkgc+1)) = 0;
+	fs_fixup_bc(fs, pt, (BCIns *)((char *)pt + sizeof(ktap_proto_t)), fs->pc);
+	fs_fixup_k(fs, pt, (void *)((char *)pt + ofsk));
+	fs_fixup_uv1(fs, pt, (uint16_t *)((char *)pt + ofsuv));
+	fs_fixup_line(fs, pt, (void *)((char *)pt + ofsli), numline);
+	fs_fixup_var(ls, pt, (uint8_t *)((char *)pt + ofsdbg), ofsvar);
+
+	ls->vtop = fs->vbase;  /* Reset variable stack. */
+	ls->fs = fs->prev;
+	kp_assert(ls->fs != NULL || ls->tok == TK_eof);
+	return pt;
+}
+
+/* Initialize a new FuncState. */
+static void fs_init(LexState *ls, FuncState *fs)
+{
+	fs->prev = ls->fs; ls->fs = fs;  /* Append to list. */
+	fs->ls = ls;
+	fs->vbase = ls->vtop;
+	fs->pc = 0;
+	fs->lasttarget = 0;
+	fs->jpc = NO_JMP;
+	fs->freereg = 0;
+	fs->nkgc = 0;
+	fs->nkn = 0;
+	fs->nactvar = 0;
+	fs->nuv = 0;
+	fs->bl = NULL;
+	fs->flags = 0;
+	fs->framesize = 1;  /* Minimum frame size. */
+	fs->kt = kp_tab_new();
+}
+
+/* -- Expressions --------------------------------------------------------- */
+
+/* Forward declaration. */
+static void expr(LexState *ls, ExpDesc *v);
+
+/* Return string expression. */
+static void expr_str(LexState *ls, ExpDesc *e)
+{
+	expr_init(e, VKSTR, 0);
+	e->u.sval = lex_str(ls);
+}
+
+#define checku8(x)     ((x) == (int32_t)(uint8_t)(x))
+
+/* Return index expression. */
+static void expr_index(FuncState *fs, ExpDesc *t, ExpDesc *e)
+{
+	/* Already called: expr_toval(fs, e). */
+	t->k = VINDEXED;
+	if (expr_isnumk(e)) {
+		ktap_number n = expr_numberV(e);
+		int32_t k = (int)n;
+		if (checku8(k) && n == (ktap_number)k) {
+			/* 256..511: const byte key */
+			t->u.s.aux = BCMAX_C+1+(uint32_t)k;
+			return;
+		}
+	} else if (expr_isstrk(e)) {
+		BCReg idx = const_str(fs, e);
+		if (idx <= BCMAX_C) {
+			/* -256..-1: const string key */
+			t->u.s.aux = ~idx;
+			return;
+		}
+	}
+	t->u.s.aux = expr_toanyreg(fs, e);  /* 0..255: register */
+}
+
+/* Parse index expression with named field. */
+static void expr_field(LexState *ls, ExpDesc *v)
+{
+	FuncState *fs = ls->fs;
+	ExpDesc key;
+
+	expr_toanyreg(fs, v);
+	kp_lex_next(ls);  /* Skip dot or colon. */
+	expr_str(ls, &key);
+	expr_index(fs, v, &key);
+}
+
+/* Parse index expression with brackets. */
+static void expr_bracket(LexState *ls, ExpDesc *v)
+{
+	kp_lex_next(ls);  /* Skip '['. */
+	expr(ls, v);
+	expr_toval(ls->fs, v);
+	lex_check(ls, ']');
+}
+
+/* Get value of constant expression. */
+static void expr_kvalue(ktap_val_t *v, ExpDesc *e)
+{
+	if (e->k <= VKTRUE) {
+		setitype(v, ~(uint32_t)e->k);
+	} else if (e->k == VKSTR) {
+		set_string(v, e->u.sval);
+	} else {
+		kp_assert(tvisnumber(expr_numtv(e)));
+		*v = *expr_numtv(e);
+	}
+}
+
+#define FLS(x)       ((uint32_t)(__builtin_clz(x)^31))
+#define hsize2hbits(s) ((s) ? ((s)==1 ? 1 : 1+FLS((uint32_t)((s)-1))) : 0)
+
+
+/* Parse table constructor expression. */
+static void expr_table(LexState *ls, ExpDesc *e)
+{
+	FuncState *fs = ls->fs;
+	BCLine line = ls->linenumber;
+	ktap_tab_t *t = NULL;
+	int vcall = 0, needarr = 0, fixt = 0;
+	uint32_t narr = 1;  /* First array index. */
+	uint32_t nhash = 0;  /* Number of hash entries. */
+	BCReg freg = fs->freereg;
+	BCPos pc = bcemit_AD(fs, BC_TNEW, freg, 0);
+
+	expr_init(e, VNONRELOC, freg);
+	bcreg_reserve(fs, 1);
+	freg++;
+	lex_check(ls, '{');
+	while (ls->tok != '}') {
+		ExpDesc key, val;
+		vcall = 0;
+		if (ls->tok == '[') {
+			expr_bracket(ls, &key);/* Already calls expr_toval. */
+			if (!expr_isk(&key))
+				expr_index(fs, e, &key);
+			if (expr_isnumk(&key) && expr_numiszero(&key))
+				needarr = 1;
+			else
+				nhash++;
+			lex_check(ls, '=');
+		} else if ((ls->tok == TK_name) &&
+				kp_lex_lookahead(ls) == '=') {
+			expr_str(ls, &key);
+			lex_check(ls, '=');
+			nhash++;
+		} else {
+			expr_init(&key, VKNUM, 0);
+			set_number(&key.u.nval, (int)narr);
+			narr++;
+			needarr = vcall = 1;
+		}
+		expr(ls, &val);
+		if (expr_isk(&key) && key.k != VKNIL &&
+			(key.k == VKSTR || expr_isk_nojump(&val))) {
+			ktap_val_t k, *v;
+			if (!t) {  /* Create template table on demand. */
+				BCReg kidx;
+				t = kp_tab_new();
+				kidx = const_gc(fs, obj2gco(t), KTAP_TTAB);
+				fs->bcbase[pc].ins = BCINS_AD(BC_TDUP, freg-1,
+								 kidx);
+			}
+			vcall = 0;
+			expr_kvalue(&k, &key);
+			v = kp_tab_set(t, &k);
+			/* Add const key/value to template table. */
+			if (expr_isk_nojump(&val)) {
+				expr_kvalue(v, &val);
+			} else {
+				/* Otherwise create dummy string key (avoids kp_tab_newkey). */
+				set_table(v, t);  /* Preserve key with table itself as value. */
+				fixt = 1;/* Fix this later, after all resizes. */
+				goto nonconst;
+			}
+		} else {
+ nonconst:
+			if (val.k != VCALL) {
+				expr_toanyreg(fs, &val);
+				vcall = 0;
+			}
+			if (expr_isk(&key))
+				expr_index(fs, e, &key);
+			bcemit_store(fs, e, &val);
+		}
+		fs->freereg = freg;
+		if (!lex_opt(ls, ',') && !lex_opt(ls, ';'))
+			break;
+	}
+	lex_match(ls, '}', '{', line);
+	if (vcall) {
+		BCInsLine *ilp = &fs->bcbase[fs->pc-1];
+		ExpDesc en;
+		kp_assert(bc_a(ilp->ins) == freg &&
+			bc_op(ilp->ins) == (narr > 256 ? BC_TSETV : BC_TSETB));
+		expr_init(&en, VKNUM, 0);
+		set_number(&en.u.nval, narr - 1);
+		if (narr > 256) { fs->pc--; ilp--; }
+		ilp->ins = BCINS_AD(BC_TSETM, freg, const_num(fs, &en));
+		setbc_b(&ilp[-1].ins, 0);
+	}
+	if (pc == fs->pc-1) {  /* Make expr relocable if possible. */
+		e->u.s.info = pc;
+		fs->freereg--;
+		e->k = VRELOCABLE;
+	} else {
+		e->k = VNONRELOC;  /* May have been changed by expr_index. */
+	}
+	if (!t) {  /* Construct TNEW RD: hhhhhaaaaaaaaaaa. */
+		BCIns *ip = &fs->bcbase[pc].ins;
+		if (!needarr) narr = 0;
+		else if (narr < 3) narr = 3;
+		else if (narr > 0x7ff) narr = 0x7ff;
+		setbc_d(ip, narr|(hsize2hbits(nhash)<<11));
+	} else {
+		if (fixt) {  /* Fix value for dummy keys in template table. */
+			ktap_node_t *node = t->node;
+			uint32_t i, hmask = t->hmask;
+			for (i = 0; i <= hmask; i++) {
+				ktap_node_t *n = &node[i];
+				if (is_table(&n->val)) {
+					kp_assert(tabV(&n->val) == t);
+					/* Turn value into nil. */
+					set_nil(&n->val);
+				}
+			}
+		}
+	}
+}
+
+/* Parse function parameters. */
+static BCReg parse_params(LexState *ls, int needself)
+{
+	FuncState *fs = ls->fs;
+	BCReg nparams = 0;
+	lex_check(ls, '(');
+	if (needself)
+		var_new_lit(ls, nparams++, "self");
+	if (ls->tok != ')') {
+		do {
+			if (ls->tok == TK_name) {
+				var_new(ls, nparams++, lex_str(ls));
+			} else if (ls->tok == TK_dots) {
+				kp_lex_next(ls);
+				fs->flags |= PROTO_VARARG;
+				break;
+			} else {
+				err_syntax(ls, KP_ERR_XPARAM);
+			}
+		} while (lex_opt(ls, ','));
+	}
+	var_add(ls, nparams);
+	kp_assert(fs->nactvar == nparams);
+	bcreg_reserve(fs, nparams);
+	lex_check(ls, ')');
+	return nparams;
+}
+
+/* Forward declaration. */
+static void parse_chunk(LexState *ls);
+
+/* Parse body of a function. */
+static void parse_body(LexState *ls, ExpDesc *e, int needself, BCLine line)
+{
+	FuncState fs, *pfs = ls->fs;
+	FuncScope bl;
+	ktap_proto_t *pt;
+	ptrdiff_t oldbase = pfs->bcbase - ls->bcstack;
+
+	fs_init(ls, &fs);
+	fscope_begin(&fs, &bl, 0);
+	fs.linedefined = line;
+	fs.numparams = (uint8_t)parse_params(ls, needself);
+	fs.bcbase = pfs->bcbase + pfs->pc;
+	fs.bclim = pfs->bclim - pfs->pc;
+	bcemit_AD(&fs, BC_FUNCF, 0, 0);  /* Placeholder. */
+	lex_check(ls, '{');
+	parse_chunk(ls);
+	lex_check(ls, '}');
+	pt = fs_finish(ls, (ls->lastline = ls->linenumber));
+	pfs->bcbase = ls->bcstack + oldbase;  /* May have been reallocated. */
+	pfs->bclim = (BCPos)(ls->sizebcstack - oldbase);
+	/* Store new prototype in the constant array of the parent. */
+	expr_init(e, VRELOCABLE,
+		bcemit_AD(pfs, BC_FNEW, 0,
+			  const_gc(pfs, (ktap_obj_t *)pt, KTAP_TPROTO)));
+	if (!(pfs->flags & PROTO_CHILD)) {
+		if (pfs->flags & PROTO_HAS_RETURN)
+			pfs->flags |= PROTO_FIXUP_RETURN;
+		pfs->flags |= PROTO_CHILD;
+	}
+	//kp_lex_next(ls);
+}
+
+/* Parse body of a function, for 'trace/trace_end/profile/tick' closure */
+static void parse_body_no_args(LexState *ls, ExpDesc *e, int needself,
+				BCLine line)
+{
+	FuncState fs, *pfs = ls->fs;
+	FuncScope bl;
+	ktap_proto_t *pt;
+	ptrdiff_t oldbase = pfs->bcbase - ls->bcstack;
+
+	fs_init(ls, &fs);
+	fscope_begin(&fs, &bl, 0);
+	fs.linedefined = line;
+	fs.numparams = 0;
+	fs.bcbase = pfs->bcbase + pfs->pc;
+	fs.bclim = pfs->bclim - pfs->pc;
+	bcemit_AD(&fs, BC_FUNCF, 0, 0);  /* Placeholder. */
+	lex_check(ls, '{');
+	parse_chunk(ls);
+	lex_check(ls, '}');
+	pt = fs_finish(ls, (ls->lastline = ls->linenumber));
+	pfs->bcbase = ls->bcstack + oldbase;  /* May have been reallocated. */
+	pfs->bclim = (BCPos)(ls->sizebcstack - oldbase);
+	/* Store new prototype in the constant array of the parent. */
+	expr_init(e, VRELOCABLE,
+		bcemit_AD(pfs, BC_FNEW, 0,
+			  const_gc(pfs, (ktap_obj_t *)pt, KTAP_TPROTO)));
+	if (!(pfs->flags & PROTO_CHILD)) {
+		if (pfs->flags & PROTO_HAS_RETURN)
+			pfs->flags |= PROTO_FIXUP_RETURN;
+		pfs->flags |= PROTO_CHILD;
+	}
+	//kp_lex_next(ls);
+}
+
+
+/* Parse expression list. Last expression is left open. */
+static BCReg expr_list(LexState *ls, ExpDesc *v)
+{
+	BCReg n = 1;
+
+	expr(ls, v);
+	while (lex_opt(ls, ',')) {
+		expr_tonextreg(ls->fs, v);
+		expr(ls, v);
+		n++;
+	}
+	return n;
+}
+
+/* Parse function argument list. */
+static void parse_args(LexState *ls, ExpDesc *e)
+{
+	FuncState *fs = ls->fs;
+	ExpDesc args;
+	BCIns ins;
+	BCReg base;
+	BCLine line = ls->linenumber;
+
+	if (ls->tok == '(') {
+		if (line != ls->lastline)
+			err_syntax(ls, KP_ERR_XAMBIG);
+		kp_lex_next(ls);
+		if (ls->tok == ')') {  /* f(). */
+			args.k = VVOID;
+		} else {
+			expr_list(ls, &args);
+			/* f(a, b, g()) or f(a, b, ...). */
+			if (args.k == VCALL) {
+				/* Pass on multiple results. */
+				setbc_b(bcptr(fs, &args), 0);
+			}
+		}
+		lex_match(ls, ')', '(', line);
+	} else if (ls->tok == '{') {
+		expr_table(ls, &args);
+	} else if (ls->tok == TK_string) {
+		expr_init(&args, VKSTR, 0);
+		args.u.sval = rawtsvalue(&ls->tokval);
+		kp_lex_next(ls);
+	} else {
+		err_syntax(ls, KP_ERR_XFUNARG);
+		return;  /* Silence compiler. */
+	}
+
+	kp_assert(e->k == VNONRELOC);
+	base = e->u.s.info;  /* Base register for call. */
+	if (args.k == VCALL) {
+		ins = BCINS_ABC(BC_CALLM, base, 2, args.u.s.aux - base - 1);
+	} else {
+		if (args.k != VVOID)
+			expr_tonextreg(fs, &args);
+		ins = BCINS_ABC(BC_CALL, base, 2, fs->freereg - base);
+	}
+	expr_init(e, VCALL, bcemit_INS(fs, ins));
+	e->u.s.aux = base;
+	fs->bcbase[fs->pc - 1].line = line;
+	fs->freereg = base+1;  /* Leave one result by default. */
+}
+
+/* Parse primary expression. */
+static void expr_primary(LexState *ls, ExpDesc *v)
+{
+	FuncState *fs = ls->fs;
+
+	/* Parse prefix expression. */
+	if (ls->tok == '(') {
+		BCLine line = ls->linenumber;
+		kp_lex_next(ls);
+		expr(ls, v);
+		lex_match(ls, ')', '(', line);
+		expr_discharge(ls->fs, v);
+	} else if (ls->tok == TK_name) {
+		var_lookup(ls, v);
+	} else {
+		err_syntax(ls, KP_ERR_XSYMBOL);
+	}
+
+	for (;;) {  /* Parse multiple expression suffixes. */
+		if (ls->tok == '.') {
+			expr_field(ls, v);
+		} else if (ls->tok == '[') {
+			ExpDesc key;
+			expr_toanyreg(fs, v);
+			expr_bracket(ls, &key);
+			expr_index(fs, v, &key);
+		} else if (ls->tok == ':') {
+			ExpDesc key;
+			kp_lex_next(ls);
+			expr_str(ls, &key);
+			bcemit_method(fs, v, &key);
+			parse_args(ls, v);
+		} else if (ls->tok == '(' || ls->tok == TK_string ||
+				ls->tok == '{') {
+			expr_tonextreg(fs, v);
+			parse_args(ls, v);
+		} else {
+			break;
+		}
+	}
+}
+
+/* Parse simple expression. */
+static void expr_simple(LexState *ls, ExpDesc *v)
+{
+	switch (ls->tok) {
+	case TK_number:
+		expr_init(v, VKNUM, 0);
+		set_obj(&v->u.nval, &ls->tokval);
+		break;
+	case TK_string:
+		expr_init(v, VKSTR, 0);
+		v->u.sval = rawtsvalue(&ls->tokval);
+		break;
+	case TK_nil:
+		expr_init(v, VKNIL, 0);
+		break;
+	case TK_true:
+		expr_init(v, VKTRUE, 0);
+		break;
+	case TK_false:
+		expr_init(v, VKFALSE, 0);
+		break;
+	case TK_dots: {  /* Vararg. */
+		FuncState *fs = ls->fs;
+		BCReg base;
+		checkcond(ls, fs->flags & PROTO_VARARG, KP_ERR_XDOTS);
+		bcreg_reserve(fs, 1);
+		base = fs->freereg-1;
+		expr_init(v, VCALL, bcemit_ABC(fs, BC_VARG, base, 2,
+		fs->numparams));
+		v->u.s.aux = base;
+		break;
+	}
+	case '{':  /* Table constructor. */
+		expr_table(ls, v);
+		return;
+	case TK_function:
+		kp_lex_next(ls);
+		parse_body(ls, v, 0, ls->linenumber);
+		return;
+	case TK_argstr:
+		expr_init(v, VARGSTR, 0);
+		break;
+	case TK_probename:
+		expr_init(v, VARGNAME, 0);
+		break;
+	case TK_arg0: case TK_arg1: case TK_arg2: case TK_arg3: case TK_arg4:
+	case TK_arg5: case TK_arg6: case TK_arg7: case TK_arg8: case TK_arg9:
+		expr_init(v, VARGN, ls->tok - TK_arg0);
+		break;
+	case TK_pid:
+		expr_init(v, VPID, 0);
+		break;
+	case TK_tid:
+		expr_init(v, VTID, 0);
+		break;
+	case TK_uid:
+		expr_init(v, VUID, 0);
+		break;
+	case TK_cpu:
+		expr_init(v, VCPU, 0);
+		break;
+	case TK_execname:
+		expr_init(v, VEXECNAME, 0);
+		break;
+	default:
+		expr_primary(ls, v);
+		return;
+	}
+	kp_lex_next(ls);
+}
+
+/* Manage syntactic levels to avoid blowing up the stack. */
+static void synlevel_begin(LexState *ls)
+{
+	if (++ls->level >= KP_MAX_XLEVEL)
+		kp_lex_error(ls, 0, KP_ERR_XLEVELS);
+}
+
+#define synlevel_end(ls)	((ls)->level--)
+
+/* Convert token to binary operator. */
+static BinOpr token2binop(LexToken tok)
+{
+	switch (tok) {
+	case '+':	return OPR_ADD;
+	case '-':	return OPR_SUB;
+	case '*':	return OPR_MUL;
+	case '/':	return OPR_DIV;
+	case '%':	return OPR_MOD;
+	case '^':	return OPR_POW;
+	case TK_concat: return OPR_CONCAT;
+	case TK_ne:	return OPR_NE;
+	case TK_eq:	return OPR_EQ;
+	case '<':	return OPR_LT;
+	case TK_le:	return OPR_LE;
+	case '>':	return OPR_GT;
+	case TK_ge:	return OPR_GE;
+	case TK_and:	return OPR_AND;
+	case TK_or:	return OPR_OR;
+	default:	return OPR_NOBINOPR;
+	}
+}
+
+/* Priorities for each binary operator. ORDER OPR. */
+static const struct {
+	uint8_t left;	/* Left priority. */
+	uint8_t right;	/* Right priority. */
+} priority[] = {
+	{6,6}, {6,6}, {7,7}, {7,7}, {7,7},	/* ADD SUB MUL DIV MOD */
+	{10,9}, {5,4},			/* POW CONCAT (right associative) */
+	{3,3}, {3,3},				/* EQ NE */
+	{3,3}, {3,3}, {3,3}, {3,3},		/* LT GE GT LE */
+	{2,2}, {1,1}				/* AND OR */
+};
+
+#define UNARY_PRIORITY		8  /* Priority for unary operators. */
+
+/* Forward declaration. */
+static BinOpr expr_binop(LexState *ls, ExpDesc *v, uint32_t limit);
+
+/* Parse unary expression. */
+static void expr_unop(LexState *ls, ExpDesc *v)
+{
+	BCOp op;
+	if (ls->tok == TK_not) {
+		op = BC_NOT;
+	} else if (ls->tok == '-') {
+		op = BC_UNM;
+#if 0 /* ktap don't support lua length operator '#' */
+	} else if (ls->tok == '#') {
+		op = BC_LEN;
+#endif
+	} else {
+		expr_simple(ls, v);
+		return;
+	}
+	kp_lex_next(ls);
+	expr_binop(ls, v, UNARY_PRIORITY);
+	bcemit_unop(ls->fs, op, v);
+}
+
+/* Parse binary expressions with priority higher than the limit. */
+static BinOpr expr_binop(LexState *ls, ExpDesc *v, uint32_t limit)
+{
+	BinOpr op;
+
+	synlevel_begin(ls);
+	expr_unop(ls, v);
+	op = token2binop(ls->tok);
+	while (op != OPR_NOBINOPR && priority[op].left > limit) {
+		ExpDesc v2;
+		BinOpr nextop;
+		kp_lex_next(ls);
+		bcemit_binop_left(ls->fs, op, v);
+		/* Parse binary expression with higher priority. */
+		nextop = expr_binop(ls, &v2, priority[op].right);
+		bcemit_binop(ls->fs, op, v, &v2);
+		op = nextop;
+	}
+	synlevel_end(ls);
+	return op;  /* Return unconsumed binary operator (if any). */
+}
+
+/* Parse expression. */
+static void expr(LexState *ls, ExpDesc *v)
+{
+	expr_binop(ls, v, 0);  /* Priority 0: parse whole expression. */
+}
+
+/* Assign expression to the next register. */
+static void expr_next(LexState *ls)
+{
+	ExpDesc e;
+	expr(ls, &e);
+	expr_tonextreg(ls->fs, &e);
+}
+
+/* Parse conditional expression. */
+static BCPos expr_cond(LexState *ls)
+{
+	ExpDesc v;
+
+	lex_check(ls, '(');
+	expr(ls, &v);
+	if (v.k == VKNIL)
+		v.k = VKFALSE;
+	bcemit_branch_t(ls->fs, &v);
+	lex_check(ls, ')');
+	return v.f;
+}
+
+/* -- Assignments --------------------------------------------------------- */
+
+/* List of LHS variables. */
+typedef struct LHSVarList {
+	ExpDesc v;			/* LHS variable. */
+	struct LHSVarList *prev;	/* Link to previous LHS variable. */
+} LHSVarList;
+
+/* Eliminate write-after-read hazards for local variable assignment. */
+static void assign_hazard(LexState *ls, LHSVarList *lh, const ExpDesc *v)
+{
+	FuncState *fs = ls->fs;
+	BCReg reg = v->u.s.info; /* Check against this variable. */
+	BCReg tmp = fs->freereg; /* Rename to this temp. register(if needed) */
+	int hazard = 0;
+
+	for (; lh; lh = lh->prev) {
+		if (lh->v.k == VINDEXED) {
+			if (lh->v.u.s.info == reg) {  /* t[i], t = 1, 2 */
+				hazard = 1;
+				lh->v.u.s.info = tmp;
+			}
+			if (lh->v.u.s.aux == reg) {  /* t[i], i = 1, 2 */
+				hazard = 1;
+				lh->v.u.s.aux = tmp;
+			}
+		}
+	}
+	if (hazard) {
+		/* Rename conflicting variable. */
+		bcemit_AD(fs, BC_MOV, tmp, reg);
+		bcreg_reserve(fs, 1);
+	}
+}
+
+/* Adjust LHS/RHS of an assignment. */
+static void assign_adjust(LexState *ls, BCReg nvars, BCReg nexps, ExpDesc *e)
+{
+	FuncState *fs = ls->fs;
+	int32_t extra = (int32_t)nvars - (int32_t)nexps;
+
+	if (e->k == VCALL) {
+		extra++;  /* Compensate for the VCALL itself. */
+		if (extra < 0)
+			extra = 0;
+		setbc_b(bcptr(fs, e), extra+1);  /* Fixup call results. */
+		if (extra > 1)
+			bcreg_reserve(fs, (BCReg)extra-1);
+	} else {
+		if (e->k != VVOID)
+			expr_tonextreg(fs, e);  /* Close last expression. */
+		if (extra > 0) {  /* Leftover LHS are set to nil. */
+			BCReg reg = fs->freereg;
+			bcreg_reserve(fs, (BCReg)extra);
+			bcemit_nil(fs, reg, (BCReg)extra);
+		}
+	}
+}
+
+/* Recursively parse assignment statement. */
+static void parse_assignment(LexState *ls, LHSVarList *lh, BCReg nvars)
+{
+	ExpDesc e;
+
+	checkcond(ls, VLOCAL <= lh->v.k && lh->v.k <= VINDEXED,
+			KP_ERR_XSYNTAX);
+	if (lex_opt(ls, ',')) {  /* Collect LHS list and recurse upwards. */
+		LHSVarList vl;
+		vl.prev = lh;
+		expr_primary(ls, &vl.v);
+		if (vl.v.k == VLOCAL)
+			assign_hazard(ls, lh, &vl.v);
+		checklimit(ls->fs, ls->level + nvars, KP_MAX_XLEVEL,
+				"variable names");
+		parse_assignment(ls, &vl, nvars+1);
+	} else {  /* Parse RHS. */
+		BCReg nexps;
+		int assign_incr = 1;
+
+		if (lex_opt(ls, '='))
+			assign_incr = 0;
+		else if (lex_opt(ls, TK_incr))
+			assign_incr = 1;
+		else
+			err_syntax(ls, KP_ERR_XSYMBOL);
+
+		nexps = expr_list(ls, &e);
+		if (nexps == nvars) {
+			if (e.k == VCALL) {
+				/* Vararg assignment. */
+				if (bc_op(*bcptr(ls->fs, &e)) == BC_VARG) {
+					ls->fs->freereg--;
+					e.k = VRELOCABLE;
+				} else {  /* Multiple call results. */
+					/* Base of call is not relocatable. */
+					e.u.s.info = e.u.s.aux;
+					e.k = VNONRELOC;
+				}
+			}
+			if (assign_incr == 0)
+				bcemit_store(ls->fs, &lh->v, &e);
+			else
+				bcemit_store_incr(ls->fs, &lh->v, &e);
+			return;
+		}
+		assign_adjust(ls, nvars, nexps, &e);
+		if (nexps > nvars) {
+			/* Drop leftover regs. */
+			ls->fs->freereg -= nexps - nvars;
+		}
+	}
+	/* Assign RHS to LHS and recurse downwards. */
+	expr_init(&e, VNONRELOC, ls->fs->freereg-1);
+	bcemit_store(ls->fs, &lh->v, &e);
+}
+
+/* Parse call statement or assignment. */
+static void parse_call_assign(LexState *ls)
+{
+	FuncState *fs = ls->fs;
+	LHSVarList vl;
+
+	expr_primary(ls, &vl.v);
+	if (vl.v.k == VCALL) {  /* Function call statement. */
+		setbc_b(bcptr(fs, &vl.v), 1);  /* No results. */
+	} else {  /* Start of an assignment. */
+		vl.prev = NULL;
+		parse_assignment(ls, &vl, 1);
+	}
+}
+
+/* Parse 'var'(local in lua) statement. */
+static void parse_local(LexState *ls)
+{
+	if (lex_opt(ls, TK_function)) {  /* Local function declaration. */
+		ExpDesc v, b;
+		FuncState *fs = ls->fs;
+		var_new(ls, 0, lex_str(ls));
+		expr_init(&v, VLOCAL, fs->freereg);
+		v.u.s.aux = fs->varmap[fs->freereg];
+		bcreg_reserve(fs, 1);
+		var_add(ls, 1);
+		parse_body(ls, &b, 0, ls->linenumber);
+		/* bcemit_store(fs, &v, &b) without setting VSTACK_VAR_RW. */
+		expr_free(fs, &b);
+		expr_toreg(fs, &b, v.u.s.info);
+		/* The upvalue is in scope, but the local is only valid 
+		 * after the store. */
+		var_get(ls, fs, fs->nactvar - 1).startpc = fs->pc;
+	} else {  /* Local variable declaration. */
+		ExpDesc e;
+		BCReg nexps, nvars = 0;
+		do {  /* Collect LHS. */
+			var_new(ls, nvars++, lex_str(ls));
+		} while (lex_opt(ls, ','));
+		if (lex_opt(ls, '=')) {  /* Optional RHS. */
+			nexps = expr_list(ls, &e);
+		} else {  /* Or implicitly set to nil. */
+			e.k = VVOID;
+			nexps = 0;
+		}
+		assign_adjust(ls, nvars, nexps, &e);
+		var_add(ls, nvars);
+	}
+}
+
+/* Parse 'function' statement. */
+static void parse_func(LexState *ls, BCLine line)
+{
+	FuncState *fs = ls->fs;
+	ExpDesc v, b;
+
+	kp_lex_next(ls);  /* Skip 'function'. */
+
+	/* function is declared as local */
+#if 1
+	var_new(ls, 0, lex_str(ls));
+	expr_init(&v, VLOCAL, fs->freereg);
+	v.u.s.aux = fs->varmap[fs->freereg];
+	bcreg_reserve(fs, 1);
+	var_add(ls, 1);
+	parse_body(ls, &b, 0, ls->linenumber);
+	/* bcemit_store(fs, &v, &b) without setting VSTACK_VAR_RW. */
+	expr_free(fs, &b);
+	expr_toreg(fs, &b, v.u.s.info);
+	/* The upvalue is in scope, but the local is only valid 
+	 * after the store. */
+	var_get(ls, fs, fs->nactvar - 1).startpc = fs->pc;
+
+#else
+	int needself = 0;
+
+	/* Parse function name. */
+	var_lookup(ls, &v);
+	while (ls->tok == '.')  /* Multiple dot-separated fields. */
+		expr_field(ls, &v);
+	if (ls->tok == ':') {  /* Optional colon to signify method call. */
+		needself = 1;
+		expr_field(ls, &v);
+	}
+	parse_body(ls, &b, needself, line);
+	fs = ls->fs;
+	bcemit_store(fs, &v, &b);
+	fs->bcbase[fs->pc - 1].line = line;  /* Set line for the store. */
+#endif
+}
+
+/* -- Control transfer statements ----------------------------------------- */
+
+/* Check for end of block. */
+static int parse_isend(LexToken tok)
+{
+	switch (tok) {
+	case TK_else: case TK_elseif: case TK_end: case TK_until: case TK_eof:
+	case '}':
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/* Parse 'return' statement. */
+static void parse_return(LexState *ls)
+{
+	BCIns ins;
+	FuncState *fs = ls->fs;
+
+	kp_lex_next(ls);  /* Skip 'return'. */
+	fs->flags |= PROTO_HAS_RETURN;
+	if (parse_isend(ls->tok) || ls->tok == ';') {  /* Bare return. */
+		ins = BCINS_AD(BC_RET0, 0, 1);
+	} else {  /* Return with one or more values. */
+		ExpDesc e;  /* Receives the _last_ expression in the list. */
+		BCReg nret = expr_list(ls, &e);
+		if (nret == 1) {  /* Return one result. */
+			if (e.k == VCALL) {  /* Check for tail call. */
+				BCIns *ip = bcptr(fs, &e);
+				/* It doesn't pay off to add BC_VARGT just
+				 * for 'return ...'. */
+				if (bc_op(*ip) == BC_VARG)
+					goto notailcall;
+				fs->pc--;
+				ins = BCINS_AD(bc_op(*ip)-BC_CALL+BC_CALLT,
+						bc_a(*ip), bc_c(*ip));
+			} else { /* Can return the result from any register. */
+				ins = BCINS_AD(BC_RET1,
+					expr_toanyreg(fs, &e), 2);
+			}
+		} else {
+			if (e.k == VCALL) {/* Append all results from a call */
+ notailcall:
+				setbc_b(bcptr(fs, &e), 0);
+				ins = BCINS_AD(BC_RETM, fs->nactvar,
+						e.u.s.aux - fs->nactvar);
+			} else {
+				/* Force contiguous registers. */
+				expr_tonextreg(fs, &e);
+				ins = BCINS_AD(BC_RET, fs->nactvar, nret+1);
+			}
+		}
+	}
+	if (fs->flags & PROTO_CHILD) {
+		/* May need to close upvalues first. */
+		bcemit_AJ(fs, BC_UCLO, 0, 0);
+	}
+	bcemit_INS(fs, ins);
+}
+
+/* Parse 'break' statement. */
+static void parse_break(LexState *ls)
+{
+	ls->fs->bl->flags |= FSCOPE_BREAK;
+	gola_new(ls, NAME_BREAK, VSTACK_GOTO, bcemit_jmp(ls->fs));
+}
+
+/* Parse label. */
+static void parse_label(LexState *ls)
+{
+	FuncState *fs = ls->fs;
+	ktap_str_t *name;
+	int idx;
+
+	fs->lasttarget = fs->pc;
+	fs->bl->flags |= FSCOPE_GOLA;
+	kp_lex_next(ls);  /* Skip '::'. */
+	name = lex_str(ls);
+	if (gola_findlabel(ls, name))
+		kp_lex_error(ls, 0, KP_ERR_XLDUP, getstr(name));
+	idx = gola_new(ls, name, VSTACK_LABEL, fs->pc);
+	lex_check(ls, TK_label);
+	/* Recursively parse trailing statements: labels and ';'. */
+	for (;;) {
+		if (ls->tok == TK_label) {
+			synlevel_begin(ls);
+			parse_label(ls);
+			synlevel_end(ls);
+		} else if (ls->tok == ';') {
+			kp_lex_next(ls);
+		} else {
+			break;
+		}
+	}
+	/* Trailing label is considered to be outside of scope. */
+	if (parse_isend(ls->tok) && ls->tok != TK_until)
+		ls->vstack[idx].slot = fs->bl->nactvar;
+	gola_resolve(ls, fs->bl, idx);
+}
+
+/* -- Blocks, loops and conditional statements ---------------------------- */
+
+/* Parse a block. */
+static void parse_block(LexState *ls)
+{
+	FuncState *fs = ls->fs;
+	FuncScope bl;
+
+	fscope_begin(fs, &bl, 0);
+	parse_chunk(ls);
+	fscope_end(fs);
+}
+
+/* Parse 'while' statement. */
+static void parse_while(LexState *ls, BCLine line)
+{
+	FuncState *fs = ls->fs;
+	BCPos start, loop, condexit;
+	FuncScope bl;
+
+	kp_lex_next(ls);  /* Skip 'while'. */
+	start = fs->lasttarget = fs->pc;
+	condexit = expr_cond(ls);
+	fscope_begin(fs, &bl, FSCOPE_LOOP);
+	//lex_check(ls, TK_do);
+	lex_check(ls, '{');
+	loop = bcemit_AD(fs, BC_LOOP, fs->nactvar, 0);
+	parse_block(ls);
+	jmp_patch(fs, bcemit_jmp(fs), start);
+	//lex_match(ls, TK_end, TK_while, line);
+	lex_check(ls, '}');
+	fscope_end(fs);
+	jmp_tohere(fs, condexit);
+	jmp_patchins(fs, loop, fs->pc);
+}
+
+/* Parse 'repeat' statement. */
+static void parse_repeat(LexState *ls, BCLine line)
+{
+	FuncState *fs = ls->fs;
+	BCPos loop = fs->lasttarget = fs->pc;
+	BCPos condexit;
+	FuncScope bl1, bl2;
+
+	fscope_begin(fs, &bl1, FSCOPE_LOOP);  /* Breakable loop scope. */
+	fscope_begin(fs, &bl2, 0);  /* Inner scope. */
+	kp_lex_next(ls);  /* Skip 'repeat'. */
+	bcemit_AD(fs, BC_LOOP, fs->nactvar, 0);
+	parse_chunk(ls);
+	lex_match(ls, TK_until, TK_repeat, line);
+	/* Parse condition (still inside inner scope). */
+	condexit = expr_cond(ls);
+	/* No upvalues? Just end inner scope. */
+	if (!(bl2.flags & FSCOPE_UPVAL)) {
+		fscope_end(fs);
+	} else {
+		/* Otherwise generate: cond: UCLO+JMP out,
+		 * !cond: UCLO+JMP loop. */
+		parse_break(ls);  /* Break from loop and close upvalues. */
+		jmp_tohere(fs, condexit);
+		fscope_end(fs);  /* End inner scope and close upvalues. */
+		condexit = bcemit_jmp(fs);
+	}
+	jmp_patch(fs, condexit, loop);  /* Jump backwards if !cond. */
+	jmp_patchins(fs, loop, fs->pc);
+	fscope_end(fs);  /* End loop scope. */
+}
+
+/* Parse numeric 'for'. */
+static void parse_for_num(LexState *ls, ktap_str_t *varname, BCLine line)
+{
+	FuncState *fs = ls->fs;
+	BCReg base = fs->freereg;
+	FuncScope bl;
+	BCPos loop, loopend;
+
+	/* Hidden control variables. */
+	var_new_fixed(ls, FORL_IDX, VARNAME_FOR_IDX);
+	var_new_fixed(ls, FORL_STOP, VARNAME_FOR_STOP);
+	var_new_fixed(ls, FORL_STEP, VARNAME_FOR_STEP);
+	/* Visible copy of index variable. */
+	var_new(ls, FORL_EXT, varname);
+	lex_check(ls, '=');
+	expr_next(ls);
+	lex_check(ls, ',');
+	expr_next(ls);
+	if (lex_opt(ls, ',')) {
+		expr_next(ls);
+	} else {
+		/* Default step is 1. */
+		bcemit_AD(fs, BC_KSHORT, fs->freereg, 1);
+		bcreg_reserve(fs, 1);
+	}
+	var_add(ls, 3);  /* Hidden control variables. */
+	//lex_check(ls, TK_do);
+	lex_check(ls, ')');
+	lex_check(ls, '{');
+	loop = bcemit_AJ(fs, BC_FORI, base, NO_JMP);
+	fscope_begin(fs, &bl, 0);  /* Scope for visible variables. */
+	var_add(ls, 1);
+	bcreg_reserve(fs, 1);
+	parse_block(ls);
+	fscope_end(fs);
+	/* Perform loop inversion. Loop control instructions are at the end. */
+	loopend = bcemit_AJ(fs, BC_FORL, base, NO_JMP);
+	fs->bcbase[loopend].line = line;  /* Fix line for control ins. */
+	jmp_patchins(fs, loopend, loop+1);
+	jmp_patchins(fs, loop, fs->pc);
+}
+
+/*
+ * Try to predict whether the iterator is next() and specialize the bytecode.
+ * Detecting next() and pairs() by name is simplistic, but quite effective.
+ * The interpreter backs off if the check for the closure fails at runtime.
+ */
+static int predict_next(LexState *ls, FuncState *fs, BCPos pc)
+{
+	BCIns ins = fs->bcbase[pc].ins;
+	ktap_str_t *name;
+	const ktap_val_t *o;
+
+	switch (bc_op(ins)) {
+	case BC_MOV:
+		name = var_get(ls, fs, bc_d(ins)).name;
+		break;
+	case BC_UGET:
+		name = ls->vstack[fs->uvmap[bc_d(ins)]].name;
+		break;
+	case BC_GGET:
+		/* There's no inverse index (yet), so lookup the strings. */
+		o = kp_tab_getstr(fs->kt, kp_str_newz("pairs"));
+		if (o && tvhaskslot(o) && tvkslot(o) == bc_d(ins))
+			return 1;
+		o = kp_tab_getstr(fs->kt, kp_str_newz("next"));
+		if (o && tvhaskslot(o) && tvkslot(o) == bc_d(ins))
+			return 1;
+		return 0;
+	default:
+		return 0;
+	}
+
+	return (name->len == 5 && !strcmp(getstr(name), "pairs")) ||
+		(name->len == 4 && !strcmp(getstr(name), "next"));
+}
+
+/* Parse 'for' iterator. */
+static void parse_for_iter(LexState *ls, ktap_str_t *indexname)
+{
+	FuncState *fs = ls->fs;
+	ExpDesc e;
+	BCReg nvars = 0;
+	BCLine line;
+	BCReg base = fs->freereg + 3;
+	BCPos loop, loopend, exprpc = fs->pc;
+	FuncScope bl;
+	int isnext;
+
+	/* Hidden control variables. */
+	var_new_fixed(ls, nvars++, VARNAME_FOR_GEN);
+	var_new_fixed(ls, nvars++, VARNAME_FOR_STATE);
+	var_new_fixed(ls, nvars++, VARNAME_FOR_CTL);
+
+	/* Visible variables returned from iterator. */
+	var_new(ls, nvars++, indexname);
+	while (lex_opt(ls, ','))
+		var_new(ls, nvars++, lex_str(ls));
+	lex_check(ls, TK_in);
+	line = ls->linenumber;
+	assign_adjust(ls, 3, expr_list(ls, &e), &e);
+	/* The iterator needs another 3 slots (func + 2 args). */
+	bcreg_bump(fs, 3);
+	isnext = (nvars <= 5 && predict_next(ls, fs, exprpc));
+	var_add(ls, 3);  /* Hidden control variables. */
+	//lex_check(ls, TK_do);
+	lex_check(ls, ')');
+	lex_check(ls, '{');
+	loop = bcemit_AJ(fs, isnext ? BC_ISNEXT : BC_JMP, base, NO_JMP);
+	fscope_begin(fs, &bl, 0);  /* Scope for visible variables. */
+	var_add(ls, nvars-3);
+	bcreg_reserve(fs, nvars-3);
+	parse_block(ls);
+	fscope_end(fs);
+	/* Perform loop inversion. Loop control instructions are at the end. */
+	jmp_patchins(fs, loop, fs->pc);
+	bcemit_ABC(fs, isnext ? BC_ITERN : BC_ITERC, base, nvars-3+1, 2+1);
+	loopend = bcemit_AJ(fs, BC_ITERL, base, NO_JMP);
+	fs->bcbase[loopend-1].line = line;  /* Fix line for control ins. */
+	fs->bcbase[loopend].line = line;
+	jmp_patchins(fs, loopend, loop+1);
+}
+
+/* Parse 'for' statement. */
+static void parse_for(LexState *ls, BCLine line)
+{
+	FuncState *fs = ls->fs;
+	ktap_str_t *varname;
+	FuncScope bl;
+
+	fscope_begin(fs, &bl, FSCOPE_LOOP);
+	kp_lex_next(ls);  /* Skip 'for'. */
+	lex_check(ls, '(');
+	varname = lex_str(ls);  /* Get first variable name. */
+	if (ls->tok == '=')
+		parse_for_num(ls, varname, line);
+	else if (ls->tok == ',' || ls->tok == TK_in)
+		parse_for_iter(ls, varname);
+	else
+		err_syntax(ls, KP_ERR_XFOR);
+	//lex_check(ls, '}');
+	//lex_match(ls, TK_end, TK_for, line);
+	lex_match(ls, '}', TK_for, line);
+	fscope_end(fs);  /* Resolve break list. */
+}
+
+/* Parse condition and 'then' block. */
+static BCPos parse_then(LexState *ls)
+{
+	BCPos condexit;
+	kp_lex_next(ls);  /* Skip 'if' or 'elseif'. */
+	condexit = expr_cond(ls);
+	lex_check(ls, '{');
+	parse_block(ls);
+	lex_check(ls, '}');
+	return condexit;
+}
+
+/* Parse 'if' statement. */
+static void parse_if(LexState *ls, BCLine line)
+{
+	FuncState *fs = ls->fs;
+	BCPos flist;
+	BCPos escapelist = NO_JMP;
+	flist = parse_then(ls);
+	while (ls->tok == TK_elseif) {  /* Parse multiple 'elseif' blocks. */
+		jmp_append(fs, &escapelist, bcemit_jmp(fs));
+		jmp_tohere(fs, flist);
+		flist = parse_then(ls);
+	}
+	if (ls->tok == TK_else) {  /* Parse optional 'else' block. */
+		jmp_append(fs, &escapelist, bcemit_jmp(fs));
+		jmp_tohere(fs, flist);
+		kp_lex_next(ls);  /* Skip 'else'. */
+		lex_check(ls, '{');
+		parse_block(ls);
+		lex_check(ls, '}');
+	} else {
+		jmp_append(fs, &escapelist, flist);
+	}
+	jmp_tohere(fs, escapelist);
+	//lex_match(ls, TK_end, TK_if, line);
+}
+
+/* Parse 'trace' and 'trace_end' statement. */
+static void parse_trace(LexState *ls)
+{
+	ExpDesc v, key, args;
+	ktap_str_t *kdebug_str = kp_str_newz("kdebug");
+	ktap_str_t *probe_str = kp_str_newz("trace_by_id");
+	ktap_str_t *probe_end_str = kp_str_newz("trace_end");
+	FuncState *fs = ls->fs;
+	int token = ls->tok;
+	BCIns ins;
+	BCReg base;
+	BCLine line = ls->linenumber;
+
+	if (token == TK_trace)
+		kp_lex_read_string_until(ls, '{');
+	else
+		kp_lex_next(ls);  /* skip "trace_end" keyword */
+
+	/* kdebug */
+	expr_init(&v, VGLOBAL, 0);
+	v.u.sval = kdebug_str;
+	expr_toanyreg(fs, &v);
+
+	/* fieldsel: kdebug.probe */
+	expr_init(&key, VKSTR, 0);
+	key.u.sval = token == TK_trace ? probe_str : probe_end_str;
+	expr_index(fs, &v, &key);
+
+	/* funcargs*/
+	expr_tonextreg(fs, &v);
+
+	if (token == TK_trace) {
+		ktap_eventdesc_t *evdef_info;
+		const char *str;
+
+		/* argument: EVENTDEF string */
+		lex_check(ls, TK_string);
+		str = svalue(&ls->tokval);
+		evdef_info = kp_parse_events(str);
+		if (!evdef_info)
+			kp_lex_error(ls, 0, KP_ERR_XEVENTDEF, str);
+
+
+		/* pass a userspace pointer to kernel */
+		expr_init(&args, VKNUM, 0);
+		set_number(&args.u.nval, (ktap_number)evdef_info);
+
+		expr_tonextreg(fs, &args);
+	}
+
+	/* argument: callback function */
+	parse_body_no_args(ls, &args, 0, ls->linenumber);
+
+	expr_tonextreg(fs, &args);
+
+	base = v.u.s.info;  /* base register for call */
+	ins = BCINS_ABC(BC_CALL, base, 2, fs->freereg - base);
+
+	expr_init(&v, VCALL, bcemit_INS(fs, ins));
+	v.u.s.aux = base;
+	fs->bcbase[fs->pc - 1].line = line;
+	fs->freereg = base+1;  /* Leave one result by default. */
+
+	setbc_b(bcptr(fs, &v), 1);  /* No results. */
+}
+
+
+/* Parse 'profile' and 'tick' statement. */
+static void parse_timer(LexState *ls)
+{
+	FuncState *fs = ls->fs;
+	ExpDesc v, key, args;
+	ktap_str_t *token_str = rawtsvalue(&ls->tokval);
+	ktap_str_t *interval_str;
+	BCLine line = ls->linenumber;
+	BCIns ins;
+	BCReg base;
+
+	kp_lex_next(ls);  /* skip '-' */
+
+	kp_lex_read_string_until(ls, '{');
+	interval_str = rawtsvalue(&ls->tokval);
+	lex_check(ls, TK_string);
+
+	/* timer */
+	expr_init(&v, VGLOBAL, 0);
+	v.u.sval = kp_str_newz("timer");
+	expr_toanyreg(fs, &v);
+
+	/* fieldsel: timer.profile, timer.tick */
+	expr_init(&key, VKSTR, 0);
+	key.u.sval = token_str;
+	expr_index(fs, &v, &key);
+
+	/* funcargs*/
+	expr_tonextreg(fs, &v);
+
+	/* argument: interval string */
+	expr_init(&args, VKSTR, 0);
+	args.u.sval = interval_str;
+
+	expr_tonextreg(fs, &args);
+
+	/* argument: callback function */
+	parse_body_no_args(ls, &args, 0, ls->linenumber);
+
+	expr_tonextreg(fs, &args);
+
+	base = v.u.s.info;  /* base register for call */
+	ins = BCINS_ABC(BC_CALL, base, 2, fs->freereg - base);
+
+	expr_init(&v, VCALL, bcemit_INS(fs, ins));
+	v.u.s.aux = base;
+	fs->bcbase[fs->pc - 1].line = line;
+	fs->freereg = base+1;  /* Leave one result by default. */
+
+	setbc_b(bcptr(fs, &v), 1);  /* No results. */
+}
+
+/* -- Parse statements ---------------------------------------------------- */
+
+/* Parse a statement. Returns 1 if it must be the last one in a chunk. */
+static int parse_stmt(LexState *ls)
+{
+	BCLine line = ls->linenumber;
+	switch (ls->tok) {
+	case TK_if:
+		parse_if(ls, line);
+		break;
+	case TK_while:
+		parse_while(ls, line);
+		break;
+	case TK_do:
+		kp_lex_next(ls);
+		parse_block(ls);
+		lex_match(ls, TK_end, TK_do, line);
+		break;
+	case TK_for:
+		parse_for(ls, line);
+		break;
+	case TK_repeat:
+		parse_repeat(ls, line);
+		break;
+	case TK_function:
+		parse_func(ls, line);
+		break;
+	case TK_local:
+		kp_lex_next(ls);
+		parse_local(ls);
+		break;
+	case TK_return:
+		parse_return(ls);
+		return 1;  /* Must be last. */
+	case TK_break:
+		kp_lex_next(ls);
+		parse_break(ls);
+		return 0;  /* Must be last. */
+	case ';':
+		kp_lex_next(ls);
+		break;
+	case TK_label:
+		parse_label(ls);
+		break;
+	case TK_trace:
+	case TK_trace_end:
+		parse_trace(ls);
+		break;
+	case TK_profile:
+	case TK_tick:
+		parse_timer(ls);
+		break;
+	default:
+		parse_call_assign(ls);
+		break;
+	}
+	return 0;
+}
+
+/* A chunk is a list of statements optionally separated by semicolons. */
+static void parse_chunk(LexState *ls)
+{
+	int islast = 0;
+
+	synlevel_begin(ls);
+	while (!islast && !parse_isend(ls->tok)) {
+		islast = parse_stmt(ls);
+		lex_opt(ls, ';');
+		kp_assert(ls->fs->framesize >= ls->fs->freereg &&
+			ls->fs->freereg >= ls->fs->nactvar);
+		/* Free registers after each stmt. */
+		ls->fs->freereg = ls->fs->nactvar;
+	}
+	synlevel_end(ls);
+}
+
+/* Entry point of bytecode parser. */
+ktap_proto_t *kp_parse(LexState *ls)
+{
+	FuncState fs;
+	FuncScope bl;
+	ktap_proto_t *pt;
+
+	ls->chunkname = kp_str_newz(ls->chunkarg);
+	ls->level = 0;
+	fs_init(ls, &fs);
+	fs.linedefined = 0;
+	fs.numparams = 0;
+	fs.bcbase = NULL;
+	fs.bclim = 0;
+	fs.flags |= PROTO_VARARG;  /* Main chunk is always a vararg func. */
+	fscope_begin(&fs, &bl, 0);
+	bcemit_AD(&fs, BC_FUNCV, 0, 0);  /* Placeholder. */
+	kp_lex_next(ls);  /* Read-ahead first token. */
+	parse_chunk(ls);
+	if (ls->tok != TK_eof)
+		err_token(ls, TK_eof);
+	pt = fs_finish(ls, ls->linenumber);
+	kp_assert(fs.prev == NULL);
+	kp_assert(ls->fs == NULL);
+	kp_assert(pt->sizeuv == 0);
+	return pt;
+}
+
diff --git a/tools/ktap/kp_parse.h b/tools/ktap/kp_parse.h
new file mode 100644
index 0000000..90d27cb
--- /dev/null
+++ b/tools/ktap/kp_parse.h
@@ -0,0 +1,4 @@
+
+ktap_proto_t *kp_parse(LexState *ls);
+ktap_str_t *kp_parse_keepstr(LexState *ls, const char *str, size_t l);
+
diff --git a/tools/ktap/kp_parse_events.c b/tools/ktap/kp_parse_events.c
new file mode 100644
index 0000000..fea12db
--- /dev/null
+++ b/tools/ktap/kp_parse_events.c
@@ -0,0 +1,798 @@
+/*
+ * parse_events.c - ktap events parser
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2012-2013 Jovi Zhangwei <jovi.zhangwei@gmail.com>.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <ctype.h>
+
+#include <ktap/ktap_types.h>
+#include <ktap/ktap_bc.h>
+#include "kp_symbol.h"
+#include "kp_util.h"
+
+#define TRACING_EVENTS_DIR "/sys/kernel/debug/tracing/events"
+
+static u8 *idmap;
+static int idmap_size = 1024; /* set init size */
+static int id_nr;
+
+static int idmap_init(void)
+{
+	idmap = malloc(idmap_size);
+	if (!idmap)
+		return -1;
+
+	memset(idmap, 0, idmap_size);
+	return 0;
+}
+
+static void idmap_free(void)
+{
+	id_nr = 0;
+	free(idmap);
+}
+
+static inline int idmap_is_set(int id)
+{
+	return idmap[id / 8] & (1 << (id % 8));
+}
+
+static void idmap_set(int id)
+{
+	if (id >= idmap_size * 8) {
+		int newsize = id + 100; /* allocate extra 800 id */
+		idmap = realloc(idmap, newsize);
+		memset(idmap + idmap_size, 0, newsize - idmap_size);
+		idmap_size = newsize;
+	}
+
+	if (!idmap_is_set(id))
+		id_nr++;
+
+	idmap[id / 8] = idmap[id / 8] | (1 << (id % 8));
+}
+
+static void idmap_clear(int id)
+{
+	if (!idmap_is_set(id))
+		return;
+
+	id_nr--;
+	idmap[id / 8] = idmap[id / 8] & ~ (1 << (id % 8));
+}
+
+static int idmap_get_max_id(void)
+{
+	return idmap_size * 8;
+}
+
+static int *get_id_array()
+{
+	int *id_array;
+	int i, j = 0;
+
+	id_array = malloc(sizeof(int) * id_nr);
+	if (!id_array)
+		return NULL;
+
+	for (i = 0; i < idmap_get_max_id(); i++) {
+		if (idmap_is_set(i))
+			id_array[j++] = i;
+	}
+
+	return id_array;
+}
+
+static int add_event(char *evtid_path)
+{
+	char id_buf[24];
+	int id, fd;
+
+	fd = open(evtid_path, O_RDONLY);
+	if (fd < 0) {
+		/*
+		 * some tracepoint doesn't have id file, like ftrace,
+		 * return success in here, and don't print error.
+		 */
+		verbose_printf("warning: cannot open file %s\n", evtid_path);
+		return 0;
+	}
+
+	if (read(fd, id_buf, sizeof(id_buf)) < 0) {
+		fprintf(stderr, "read file error %s\n", evtid_path);
+		close(fd);
+		return -1;
+	}
+
+	id = atoll(id_buf);
+
+	idmap_set(id);
+
+	close(fd);
+	return 0;
+}
+
+static int add_tracepoint(const char *sys_name, const char *evt_name)
+{
+	char evtid_path[PATH_MAX] = {0};
+
+	snprintf(evtid_path, PATH_MAX, "%s/%s/%s/id", TRACING_EVENTS_DIR,
+					sys_name, evt_name);
+	return add_event(evtid_path);
+}
+
+static int parse_events_add_tracepoint(char *sys, char *event)
+{
+	process_available_tracepoints(sys, event, add_tracepoint);
+	return 0;
+}
+
+enum {
+	KPROBE_EVENT,
+	UPROBE_EVENT,
+};
+
+struct probe_list {
+	struct probe_list *next;
+	int type;
+	char event[64];
+};
+
+static struct probe_list *probe_list_head; /* for cleanup resources */
+
+/*
+ * Some symbol format cannot write to uprobe_events in debugfs, like:
+ * symbol "check_one_fd.part.0" in glibc.
+ * For those symbols, we change the format to:
+ * "check_one_fd.part.0" -> "check_one_fd_part_0"
+ */
+static char *format_symbol_name(const char *old_symbol)
+{
+	char *new_name = strdup(old_symbol);
+	char *name = new_name;
+	int changed = 0;
+
+        if (!isalpha(*name) && *name != '_') {
+		*name = '_';
+		changed = 1;
+	}
+
+        while (*++name != '\0') {
+                if (!isalpha(*name) && !isdigit(*name) && *name != '_') {
+			*name = '_';
+			changed = 1;
+			continue;
+		}
+        }
+
+	if (changed)
+		fprintf(stderr,
+			"Warning: symbol \"%s\" transformed to event \"%s\"\n",
+			old_symbol, new_name);
+
+	/* this is a good name */
+        return new_name;
+}
+
+
+#define KPROBE_EVENTS_PATH "/sys/kernel/debug/tracing/kprobe_events"
+
+/**
+ * @return 0 on success, otherwise -1
+ */
+static int
+write_kprobe_event(int fd, int ret_probe, const char *symbol,
+		   unsigned long start, char *fetch_args)
+{
+	char probe_event[128] = {0};
+	char event[64] = {0};
+	struct probe_list *pl;
+	char event_id_path[128] = {0};
+	char *symbol_name;
+	int id_fd, ret;
+
+	/* In case some symbols cannot write to uprobe_events debugfs file */
+	symbol_name = format_symbol_name(symbol);
+
+	if (!fetch_args)
+		fetch_args = " ";
+
+	if (ret_probe) {
+		snprintf(event, 64, "ktap_kprobes_%d/ret_%s",
+			 getpid(), symbol_name);
+		/* Return probe point must be a symbol */
+		snprintf(probe_event, 128, "r:%s %s %s",
+			 event, symbol, fetch_args);
+	} else {
+		snprintf(event, 64, "ktap_kprobes_%d/%s",
+			 getpid(), symbol_name);
+		snprintf(probe_event, 128, "p:%s 0x%lx %s",
+			 event, start, fetch_args);
+	}
+
+	sprintf(event_id_path, "/sys/kernel/debug/tracing/events/%s/id", event);
+	/* if event id already exist, then don't write to kprobes_event again */
+	id_fd = open(event_id_path, O_RDONLY);
+	if (id_fd > 0) {
+		close(id_fd);
+
+		/* remember add event id to ids_array */
+		ret = add_event(event_id_path);
+		if (ret)
+			goto error;
+
+		goto out;
+	}
+
+	verbose_printf("write kprobe event %s\n", probe_event);
+
+	if (write(fd, probe_event, strlen(probe_event)) <= 0) {
+		fprintf(stderr, "Cannot write %s to %s\n", probe_event,
+				KPROBE_EVENTS_PATH);
+		goto error;
+	}
+
+	/* add to cleanup list */
+	pl = malloc(sizeof(struct probe_list));
+	if (!pl)
+		goto error;
+
+	pl->type = KPROBE_EVENT;
+	pl->next = probe_list_head;
+	memcpy(pl->event, event, 64);
+	probe_list_head = pl;
+
+	ret = add_event(event_id_path);
+	if (ret < 0)
+		goto error;
+
+ out:
+	free(symbol_name);
+	return 0;
+
+ error:
+	free(symbol_name);
+	return -1;
+}
+
+static unsigned long kprobes_text_start;
+static unsigned long kprobes_text_end;
+
+static void init_kprobe_prohibited_area(void)
+{
+	static int once = 0;
+
+	if (once > 0)
+		return;
+
+	once = 1;
+	kprobes_text_start     = find_kernel_symbol("__kprobes_text_start");
+	kprobes_text_end       = find_kernel_symbol("__kprobes_text_end");
+}
+
+static int check_kprobe_addr_prohibited(unsigned long addr)
+{
+	if (addr >= kprobes_text_start && addr <= kprobes_text_end)
+		return -1;
+
+	return 0;
+}
+
+struct probe_cb_base {
+	int fd;
+	int ret_probe;
+	const char *event;
+	char *binary;
+	char *symbol;
+	char *fetch_args;
+};
+
+static int kprobe_symbol_actor(void *arg, const char *name, char type,
+			       unsigned long start)
+{
+	struct probe_cb_base *base = (struct probe_cb_base *)arg;
+
+	/* only can probe text function */
+	if (type != 't' && type != 'T')
+		return -1;
+
+	if (!strglobmatch(name, base->symbol))
+		return -1;
+
+	if (check_kprobe_addr_prohibited(start))
+		return -1;
+
+	/* ignore reture code of write debugfs */
+	write_kprobe_event(base->fd, base->ret_probe, name, start,
+			   base->fetch_args);
+
+	return 0; /* success */
+}
+
+static int parse_events_add_kprobe(char *event)
+{
+	char *symbol, *end;
+	struct probe_cb_base base;
+	int fd, ret;
+
+	fd = open(KPROBE_EVENTS_PATH, O_WRONLY);
+	if (fd < 0) {
+		fprintf(stderr, "Cannot open %s\n", KPROBE_EVENTS_PATH);
+		return -1;
+	}
+
+	end = strpbrk(event, "% ");
+	if (end)
+		symbol = strndup(event, end - event);
+	else
+		symbol = strdup(event);
+
+	base.fd = fd;
+	base.ret_probe = !!strstr(event, "%return");
+	base.symbol = symbol;
+	base.fetch_args = strchr(event, ' ');
+
+	init_kprobe_prohibited_area();
+
+	ret = kallsyms_parse(&base, kprobe_symbol_actor);
+	if (ret <= 0) {
+		fprintf(stderr, "cannot parse symbol \"%s\"\n", symbol);
+		ret = -1;
+	} else {
+		ret = 0;
+	}
+
+	free(symbol);
+	close(fd);
+
+	return ret;
+}
+
+#define UPROBE_EVENTS_PATH "/sys/kernel/debug/tracing/uprobe_events"
+
+/**
+ * @return 0 on success, otherwise -1
+ */
+static int
+write_uprobe_event(int fd, int ret_probe, const char *binary,
+		   const char *symbol, unsigned long addr,
+		   char *fetch_args)
+{
+	char probe_event[128] = {0};
+	char event[64] = {0};
+	struct probe_list *pl;
+	char event_id_path[128] = {0};
+	char *symbol_name;
+	int id_fd, ret;
+
+	/* In case some symbols cannot write to uprobe_events debugfs file */
+	symbol_name = format_symbol_name(symbol);
+
+	if (!fetch_args)
+		fetch_args = " ";
+
+	if (ret_probe) {
+		snprintf(event, 64, "ktap_uprobes_%d/ret_%s",
+			 getpid(), symbol_name);
+		snprintf(probe_event, 128, "r:%s %s:0x%lx %s",
+			 event, binary, addr, fetch_args);
+	} else {
+		snprintf(event, 64, "ktap_uprobes_%d/%s",
+			 getpid(), symbol_name);
+		snprintf(probe_event, 128, "p:%s %s:0x%lx %s",
+			 event, binary, addr, fetch_args);
+	}
+
+	sprintf(event_id_path, "/sys/kernel/debug/tracing/events/%s/id", event);
+	/* if event id already exist, then don't write to uprobes_event again */
+	id_fd = open(event_id_path, O_RDONLY);
+	if (id_fd > 0) {
+		close(id_fd);
+
+		/* remember add event id to ids_array */
+		ret = add_event(event_id_path);
+		if (ret)
+			goto error;
+
+		goto out;
+	}
+
+	verbose_printf("write uprobe event %s\n", probe_event);
+
+	if (write(fd, probe_event, strlen(probe_event)) <= 0) {
+		fprintf(stderr, "Cannot write %s to %s\n", probe_event,
+				UPROBE_EVENTS_PATH);
+		goto error;
+	}
+
+	/* add to cleanup list */
+	pl = malloc(sizeof(struct probe_list));
+	if (!pl)
+		goto error;
+
+	pl->type = UPROBE_EVENT;
+	pl->next = probe_list_head;
+	memcpy(pl->event, event, 64);
+	probe_list_head = pl;
+
+	ret = add_event(event_id_path);
+	if (ret < 0)
+		goto error;
+
+ out:
+	free(symbol_name);
+	return 0;
+
+ error:
+	free(symbol_name);
+	return -1;
+}
+
+/**
+ * TODO: avoid copy-paste stuff
+ *
+ * @return 1 on success, otherwise 0
+ */
+#ifdef NO_LIBELF
+static int parse_events_resolve_symbol(int fd, char *event, int type)
+{
+	char *colon, *binary, *fetch_args;
+	unsigned long symbol_address;
+
+	colon = strchr(event, ':');
+	if (!colon)
+		return -1;
+
+	symbol_address = strtol(colon + 1 /* skip ":" */, NULL, 0);
+
+	fetch_args = strchr(event, ' ');
+
+	/**
+	 * We already have address, no need in resolving.
+	 */
+	if (symbol_address) {
+		int ret;
+
+		binary = strndup(event, colon - event);
+		ret = write_uprobe_event(fd, !!strstr(event, "%return"), binary,
+					 "NULL", symbol_address, fetch_args);
+		free(binary);
+		return ret;
+	}
+
+	fprintf(stderr, "error: cannot resolve event \"%s\" without libelf, "
+			"please recompile ktap with NO_LIBELF disabled\n",
+			event);
+	exit(EXIT_FAILURE);
+	return -1;
+}
+
+#else
+static int uprobe_symbol_actor(const char *name, vaddr_t addr, void *arg)
+{
+	struct probe_cb_base *base = (struct probe_cb_base *)arg;
+	int ret;
+
+	if (!strglobmatch(name, base->symbol))
+		return 0;
+
+	verbose_printf("uprobe: binary: \"%s\" symbol \"%s\" "
+			"resolved to 0x%lx\n",
+			base->binary, base->symbol, (unsigned long)addr);
+
+	ret = write_uprobe_event(base->fd, base->ret_probe, base->binary,
+				 name, addr, base->fetch_args);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int parse_events_resolve_symbol(int fd, char *event, int type)
+{
+	char *colon, *end;
+	vaddr_t symbol_address;
+	int ret;
+	struct probe_cb_base base = {
+		.fd = fd,
+		.event = event
+	};
+
+	colon = strchr(event, ':');
+	if (!colon)
+		return 0;
+
+	base.ret_probe = !!strstr(event, "%return");
+	symbol_address = strtol(colon + 1 /* skip ":" */, NULL, 0);
+	base.binary = strndup(event, colon - event);
+
+	base.fetch_args = strchr(event, ' ');
+
+	/*
+	 * We already have address, no need in resolving.
+	 */
+	if (symbol_address) {
+		int ret;
+		ret = write_uprobe_event(fd, base.ret_probe, base.binary,
+					 "NULL", symbol_address,
+					 base.fetch_args);
+		free(base.binary);
+		return ret;
+	}
+
+	end = strpbrk(event, "% ");
+	if (end)
+		base.symbol = strndup(colon + 1, end - 1 - colon);
+	else
+		base.symbol = strdup(colon + 1);
+
+	ret = parse_dso_symbols(base.binary, type, uprobe_symbol_actor,
+				(void *)&base);
+	if (!ret) {
+		fprintf(stderr, "error: cannot find symbol %s in binary %s\n",
+			base.symbol, base.binary);
+		ret = -1;
+	} else if(ret > 0) {
+		/* no error found when parse symbols */
+		ret = 0;
+	}
+
+	free(base.binary);
+	free(base.symbol);
+
+	return ret;
+}
+#endif
+
+static int parse_events_add_uprobe(char *old_event, int type)
+{
+	int ret;
+	int fd;
+
+	fd = open(UPROBE_EVENTS_PATH, O_WRONLY);
+	if (fd < 0) {
+		fprintf(stderr, "Cannot open %s\n", UPROBE_EVENTS_PATH);
+		return -1;
+	}
+
+	ret = parse_events_resolve_symbol(fd, old_event, type);
+
+	close(fd);
+	return ret;
+}
+
+static int parse_events_add_probe(char *old_event)
+{
+	char *separator;
+
+	separator = strchr(old_event, ':');
+	if (!separator || (separator == old_event))
+		return parse_events_add_kprobe(old_event);
+	else
+		return parse_events_add_uprobe(old_event, FIND_SYMBOL);
+}
+
+static int parse_events_add_sdt(char *old_event)
+{
+	return parse_events_add_uprobe(old_event, FIND_STAPSDT_NOTE);
+}
+
+static void strim(char *s)
+{
+	size_t size;
+	char *end;
+
+	size = strlen(s);
+	if (!size)
+		return;
+
+	end = s + size -1;
+	while (end >= s && isspace(*end))
+		end--;
+
+	*(end + 1) = '\0';
+}
+
+static int get_sys_event_filter_str(char *start,
+				    char **sys, char **event, char **filter)
+{
+	char *separator, *separator2, *ptr, *end;
+
+	while (*start == ' ')
+		start++;
+
+	/* find sys */
+	separator = strchr(start, ':');
+	if (!separator || (separator == start)) {
+		return -1;
+	}
+
+	ptr = malloc(separator - start + 1);
+	if (!ptr)
+		return -1;
+
+	strncpy(ptr, start, separator - start);
+	ptr[separator - start] = '\0';
+
+	strim(ptr);
+	*sys = ptr;
+
+	if (!strcmp(*sys, "probe") && (*(separator + 1) == '/')) {
+		/* it's uprobe event */
+		separator2 = strchr(separator + 1, ':');
+		if (!separator2)
+			return -1;
+	} else
+		separator2 = separator;
+
+	/* find filter */
+	end = start + strlen(start);
+	while (*--end == ' ') {
+	}
+
+	if (*end == '/') {
+		char *filter_start;
+
+		filter_start = strchr(separator2, '/');
+		if (filter_start == end)
+			return -1;
+
+		ptr = malloc(end - filter_start);
+		if (!ptr)
+			return -1;
+
+		memcpy(ptr, filter_start + 1, end - filter_start - 1);
+		ptr[end - filter_start - 1] = '\0';
+
+		*filter = ptr;
+
+		end = filter_start;
+	} else {
+		*filter = NULL;
+		end++;
+	}
+
+	/* find event */
+	ptr = malloc(end - separator);
+	if (!ptr)
+		return -1;
+
+	memcpy(ptr, separator + 1, end - separator - 1);
+	ptr[end - separator - 1] = '\0';
+
+	strim(ptr);
+	*event = ptr;
+
+	return 0;
+}
+
+static char *get_next_eventdef(char *str)
+{
+	char *separator;
+
+	separator = strchr(str, ',');
+	if (!separator)
+		return str + strlen(str);
+
+	*separator = '\0';
+	return separator + 1;
+}
+
+ktap_eventdesc_t *kp_parse_events(const char *eventdef)
+{
+	char *str = strdup(eventdef);
+	char *sys, *event, *filter, *next;
+	ktap_eventdesc_t *evdef_info;
+	int ret;
+
+	idmap_init();
+
+ parse_next_eventdef:
+	next = get_next_eventdef(str);
+
+	if (get_sys_event_filter_str(str, &sys, &event, &filter))
+		goto error;
+
+	verbose_printf("parse_eventdef: sys[%s], event[%s], filter[%s]\n",
+		       sys, event, filter);
+
+	if (!strcmp(sys, "probe"))
+		ret = parse_events_add_probe(event);
+	else if (!strcmp(sys, "sdt"))
+		ret = parse_events_add_sdt(event);
+	else
+		ret = parse_events_add_tracepoint(sys, event);
+
+	if (ret)
+		goto error;
+
+	/* don't trace ftrace:function when all tracepoints enabled */
+	if (!strcmp(sys, "*"))
+		idmap_clear(1);
+
+
+	if (filter && *next != '\0') {
+		fprintf(stderr, "Error: eventdef only can append one filter\n");
+		goto error;
+	}
+
+	str = next;
+	if (*next != '\0')
+		goto parse_next_eventdef;
+
+	evdef_info = malloc(sizeof(*evdef_info));
+	if (!evdef_info)
+		goto error;
+
+	evdef_info->nr = id_nr;
+	evdef_info->id_arr = get_id_array();
+	evdef_info->filter = filter;
+
+	idmap_free();
+	return evdef_info;
+ error:
+	idmap_free();
+	cleanup_event_resources();
+	return NULL;
+}
+
+void cleanup_event_resources(void)
+{
+	struct probe_list *pl;
+	const char *path;
+	char probe_event[128] = {0};
+	int fd, ret;
+
+	for (pl = probe_list_head; pl; pl = pl->next) {
+		if (pl->type == KPROBE_EVENT)
+			path = KPROBE_EVENTS_PATH;
+		else if (pl->type == UPROBE_EVENT)
+			path = UPROBE_EVENTS_PATH;
+		else {
+			fprintf(stderr, "Cannot cleanup event type %d\n",
+					pl->type);
+			continue;
+		}
+
+		snprintf(probe_event, 128, "-:%s", pl->event);
+
+		fd = open(path, O_WRONLY);
+		if (fd < 0) {
+			fprintf(stderr, "Cannot open %s\n", UPROBE_EVENTS_PATH);
+			continue;
+		}
+
+		ret = write(fd, probe_event, strlen(probe_event));
+		if (ret <= 0) {
+			fprintf(stderr, "Cannot write %s to %s\n", probe_event,
+					path);
+			close(fd);
+			continue;
+		}
+
+		close(fd);
+	}
+}
+
diff --git a/tools/ktap/kp_reader.c b/tools/ktap/kp_reader.c
new file mode 100644
index 0000000..0af7bec
--- /dev/null
+++ b/tools/ktap/kp_reader.c
@@ -0,0 +1,106 @@
+/*
+ * reader.c - ring buffer reader in userspace
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2012-2013 Jovi Zhangwei <jovi.zhangwei@gmail.com>.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <sys/signal.h>
+#include <fcntl.h>
+#include <pthread.h>
+
+#define MAX_BUFLEN  131072
+#define PATH_MAX 128
+
+#define handle_error(str) do { perror(str); exit(-1); } while(0)
+
+void sigfunc(int signo)
+{
+	/* should not not reach here */
+}
+
+static void block_sigint()
+{
+	sigset_t mask;
+
+	sigemptyset(&mask);
+	sigaddset(&mask, SIGINT);
+
+	pthread_sigmask(SIG_BLOCK, &mask, NULL);
+}
+
+static void *reader_thread(void *data)
+{
+	char buf[MAX_BUFLEN];
+	char filename[PATH_MAX];
+	const char *output = data; 
+	int failed = 0, fd, out_fd, len;
+
+	block_sigint();
+
+	if (output) {
+		out_fd = open(output, O_CREAT | O_WRONLY | O_TRUNC,
+					S_IRUSR|S_IWUSR);
+		if (out_fd < 0) {
+			fprintf(stderr, "Cannot open output file %s\n", output);
+			return NULL;
+		}
+	} else
+		out_fd = 1;
+
+	sprintf(filename, "/sys/kernel/debug/ktap/trace_pipe_%d", getpid());
+
+ open_again:
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) {
+		usleep(10000);
+
+		if (failed++ == 10) {
+			fprintf(stderr, "Cannot open file %s\n", filename);
+			return NULL;
+		}
+		goto open_again;
+	}
+
+	while ((len = read(fd, buf, sizeof(buf))) > 0)
+		write(out_fd, buf, len);
+
+	close(fd);
+	close(out_fd);
+
+	return NULL;
+}
+
+int kp_create_reader(const char *output)
+{
+	pthread_t reader;
+
+	signal(SIGINT, sigfunc);
+
+	if (pthread_create(&reader, NULL, reader_thread, (void *)output) < 0)
+		handle_error("pthread_create reader_thread failed\n");
+
+	return 0;
+}
+
diff --git a/tools/ktap/kp_symbol.c b/tools/ktap/kp_symbol.c
new file mode 100644
index 0000000..2f2e72b
--- /dev/null
+++ b/tools/ktap/kp_symbol.c
@@ -0,0 +1,360 @@
+/*
+ * symbol.c
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2013 Azat Khuzhin <a3at.mail@gmail.com>.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <linux/limits.h>
+
+#include <libelf.h>
+
+#include <ktap/ktap_types.h>
+#include "kp_symbol.h"
+
+const char *dbg_link_name = ".gnu_debuglink";
+const char *dbg_bin_dir = "/usr/lib/debug";
+
+static Elf_Scn *elf_section_by_name(Elf *elf, GElf_Ehdr *ep,
+				    GElf_Shdr *shp, const char *name)
+{
+	Elf_Scn *scn = NULL;
+
+	/* Elf is corrupted/truncated, avoid calling elf_strptr. */
+	if (!elf_rawdata(elf_getscn(elf, ep->e_shstrndx), NULL))
+		return NULL;
+
+	while ((scn = elf_nextscn(elf, scn)) != NULL) {
+		char *str;
+
+		gelf_getshdr(scn, shp);
+		str = elf_strptr(elf, ep->e_shstrndx, shp->sh_name);
+		if (!strcmp(name, str))
+			break;
+	}
+
+	return scn;
+}
+
+/**
+ * @return v_addr of "LOAD" program header, that have zero offset.
+ */
+static int find_load_address(Elf *elf, vaddr_t *load_address)
+{
+	GElf_Phdr phdr;
+	size_t i, phdrnum;
+
+	if (elf_getphdrnum(elf, &phdrnum))
+		return -1;
+
+	for (i = 0; i < phdrnum; i++) {
+		if (gelf_getphdr(elf, i, &phdr) == NULL)
+			return -1;
+
+		if (phdr.p_type != PT_LOAD || phdr.p_offset != 0)
+			continue;
+
+		*load_address = phdr.p_vaddr;
+		return 0;
+	}
+
+	/* cannot found load address */
+	return -1;
+}
+
+static size_t elf_symbols(GElf_Shdr shdr)
+{
+	return shdr.sh_size / shdr.sh_entsize;
+}
+
+static int dso_symbols(Elf *elf, symbol_actor actor, void *arg)
+{
+	Elf_Data *elf_data = NULL;
+	Elf_Scn *scn = NULL;
+	GElf_Sym sym;
+	GElf_Shdr shdr;
+	int symbols_count = 0;
+	vaddr_t load_address;
+
+	if (find_load_address(elf, &load_address))
+		return -1;
+
+	while ((scn = elf_nextscn(elf, scn))) {
+		int i;
+
+		gelf_getshdr(scn, &shdr);
+
+		if (shdr.sh_type != SHT_SYMTAB)
+			continue;
+
+		elf_data = elf_getdata(scn, elf_data);
+
+		for (i = 0; i < elf_symbols(shdr); i++) {
+			char *name;
+			vaddr_t addr;
+			int ret;
+
+			gelf_getsym(elf_data, i, &sym);
+
+			if (GELF_ST_TYPE(sym.st_info) != STT_FUNC)
+				continue;
+
+			name = elf_strptr(elf, shdr.sh_link, sym.st_name);
+			addr = sym.st_value - load_address;
+
+			ret = actor(name, addr, arg);
+			if (ret)
+				return ret;
+
+			++symbols_count;
+		}
+	}
+
+	return symbols_count;
+}
+
+#define SDT_NOTE_TYPE 3
+#define SDT_NOTE_COUNT 3
+#define SDT_NOTE_SCN ".note.stapsdt"
+#define SDT_NOTE_NAME "stapsdt"
+
+static vaddr_t sdt_note_addr(Elf *elf, const char *data, size_t len, int type)
+{
+	vaddr_t vaddr;
+
+	/*
+	 * Three addresses need to be obtained :
+	 * Marker location, address of base section and semaphore location
+	 */
+	union {
+		Elf64_Addr a64[3];
+		Elf32_Addr a32[3];
+	} buf;
+
+	/*
+	 * dst and src are required for translation from file to memory
+	 * representation
+	 */
+	Elf_Data dst = {
+		.d_buf = &buf, .d_type = ELF_T_ADDR, .d_version = EV_CURRENT,
+		.d_size = gelf_fsize(elf, ELF_T_ADDR, SDT_NOTE_COUNT, EV_CURRENT),
+		.d_off = 0, .d_align = 0
+	};
+
+	Elf_Data src = {
+		.d_buf = (void *) data, .d_type = ELF_T_ADDR,
+		.d_version = EV_CURRENT, .d_size = dst.d_size, .d_off = 0,
+		.d_align = 0
+	};
+
+	/* Check the type of each of the notes */
+	if (type != SDT_NOTE_TYPE)
+		return 0;
+
+	if (len < dst.d_size + SDT_NOTE_COUNT)
+		return 0;
+
+	/* Translation from file representation to memory representation */
+	if (gelf_xlatetom(elf, &dst, &src,
+			  elf_getident(elf, NULL)[EI_DATA]) == NULL)
+		return 0; /* TODO */
+
+	memcpy(&vaddr, &buf, sizeof(vaddr));
+
+	return vaddr;
+}
+
+static const char *sdt_note_name(Elf *elf, GElf_Nhdr *nhdr, const char *data)
+{
+	const char *provider = data + gelf_fsize(elf,
+		ELF_T_ADDR, SDT_NOTE_COUNT, EV_CURRENT);
+	const char *name = (const char *)memchr(provider, '\0',
+		data + nhdr->n_descsz - provider);
+
+	if (name++ == NULL)
+		return NULL;
+
+	return name;
+}
+
+static const char *sdt_note_data(const Elf_Data *data, size_t off)
+{
+	return ((data->d_buf) + off);
+}
+
+static int dso_sdt_notes(Elf *elf, symbol_actor actor, void *arg)
+{
+	GElf_Ehdr ehdr;
+	Elf_Scn *scn = NULL;
+	Elf_Data *data;
+	GElf_Shdr shdr;
+	size_t shstrndx;
+	size_t next;
+	GElf_Nhdr nhdr;
+	size_t name_off, desc_off, offset;
+	vaddr_t vaddr = 0;
+	int symbols_count = 0;
+
+	if (gelf_getehdr(elf, &ehdr) == NULL)
+		return 0;
+	if (elf_getshdrstrndx(elf, &shstrndx) != 0)
+		return 0;
+
+	/*
+	 * Look for section type = SHT_NOTE, flags = no SHF_ALLOC
+	 * and name = .note.stapsdt
+	 */
+	scn = elf_section_by_name(elf, &ehdr, &shdr, SDT_NOTE_SCN);
+	if (!scn)
+		return 0;
+	if (!(shdr.sh_type == SHT_NOTE) || (shdr.sh_flags & SHF_ALLOC))
+		return 0;
+
+	data = elf_getdata(scn, NULL);
+
+	for (offset = 0;
+		(next = gelf_getnote(data, offset, &nhdr, &name_off, &desc_off)) > 0;
+		offset = next) {
+		const char *name;
+		int ret;
+
+		if (nhdr.n_namesz != sizeof(SDT_NOTE_NAME) ||
+		    memcmp(data->d_buf + name_off, SDT_NOTE_NAME,
+			    sizeof(SDT_NOTE_NAME)))
+			continue;
+
+		name = sdt_note_name(elf, &nhdr, sdt_note_data(data, desc_off));
+		if (!name)
+			continue;
+
+		vaddr = sdt_note_addr(elf, sdt_note_data(data, desc_off),
+					nhdr.n_descsz, nhdr.n_type);
+		if (!vaddr)
+			continue;
+
+		ret = actor(name, vaddr, arg);
+		if (ret)
+			return ret;
+
+		++symbols_count;
+	}
+
+	return symbols_count;
+}
+
+int dso_follow_debuglink(Elf *elf,
+			 const char *orig_exec,
+			 int type,
+			 symbol_actor actor,
+			 void *arg)
+{
+	GElf_Ehdr ehdr;
+	size_t shstrndx, orig_exec_dir_len;
+	GElf_Shdr shdr;
+	Elf_Scn *dbg_link_scn;
+	Elf_Data *dbg_link_scn_data;
+	char *dbg_link, *dbg_bin, *last_slash;
+	int symbols_count;
+
+	/* First try to find the .gnu_debuglink section in the binary. */
+	if (gelf_getehdr(elf, &ehdr) == NULL)
+		return 0;
+	if (elf_getshdrstrndx(elf, &shstrndx) != 0)
+		return 0;
+
+	dbg_link_scn = elf_section_by_name(elf, &ehdr, &shdr, dbg_link_name);
+	if (dbg_link_scn == NULL)
+		return 0;
+
+	/* Debug link section found, read of the content (only get the first
+	   string, no checksum checking atm). This is debug binary file name. */
+	dbg_link_scn_data = elf_getdata(dbg_link_scn, NULL);
+	if (dbg_link_scn_data == NULL ||
+	    dbg_link_scn_data->d_size <= 0 ||
+	    dbg_link_scn_data->d_buf == NULL)
+		return 0;
+
+	/* Now compose debug executable name */
+	dbg_link = (char *)(dbg_link_scn_data->d_buf);
+	dbg_bin = malloc(strlen(dbg_bin_dir) + 1 +
+			 strlen(orig_exec) + 1 +
+			 strlen(dbg_link) + 1);
+	if (!dbg_bin)
+		return 0;
+
+	orig_exec_dir_len = PATH_MAX;
+	last_slash = strrchr(orig_exec, '/');
+	if (last_slash != NULL)
+		orig_exec_dir_len = last_slash - orig_exec;
+
+	sprintf(dbg_bin, "%s/%.*s/%s",
+		dbg_bin_dir, (int)orig_exec_dir_len, orig_exec, dbg_link);
+
+	/* Retry symbol seach with the debug binary */
+	symbols_count = parse_dso_symbols(dbg_bin, type, actor, arg);
+
+	free(dbg_bin);
+
+	return symbols_count;
+}
+
+int parse_dso_symbols(const char *exec, int type, symbol_actor actor, void *arg)
+{
+	int symbols_count = 0;
+	Elf *elf;
+	int fd;
+
+	if (elf_version(EV_CURRENT) == EV_NONE)
+		return -1;
+
+	fd = open(exec, O_RDONLY);
+	if (fd < 0)
+		return -1;
+
+	elf = elf_begin(fd, ELF_C_READ, NULL);
+	if (elf) {
+		switch (type) {
+		case FIND_SYMBOL:
+			symbols_count = dso_symbols(elf, actor, arg);
+			if (symbols_count != 0)
+				break;
+			/* If no symbols found, try in the debuglink binary. */
+			symbols_count = dso_follow_debuglink(elf,
+							     exec,
+							     type,
+							     actor,
+							     arg);
+			break;
+		case FIND_STAPSDT_NOTE:
+			symbols_count = dso_sdt_notes(elf, actor, arg);
+			break;
+		}
+
+		elf_end(elf);
+	}
+
+	close(fd);
+	return symbols_count;
+}
diff --git a/tools/ktap/kp_symbol.h b/tools/ktap/kp_symbol.h
new file mode 100644
index 0000000..650e785
--- /dev/null
+++ b/tools/ktap/kp_symbol.h
@@ -0,0 +1,50 @@
+/*
+ * symbol.h - extract symbols from DSO.
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2013 Azat Khuzhin <a3at.mail@gmail.com>.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#define FIND_SYMBOL 1
+#define FIND_STAPSDT_NOTE 2
+
+#ifndef NO_LIBELF
+
+#include <gelf.h>
+#include <sys/queue.h>
+
+typedef GElf_Addr vaddr_t;
+typedef int (*symbol_actor)(const char *name, vaddr_t addr, void *arg);
+
+/**
+ * Parse all DSO symbols/sdt notes and all for every of them
+ * an actor.
+ *
+ * @exec - path to DSO
+ * @type - see FIND_*
+ * @symbol_actor - actor to call (callback)
+ * @arg - argument for @actor
+ *
+ * @return
+ * If there have errors, return negative value;
+ * No symbols found, return 0;
+ * Otherwise return number of dso symbols found
+ */
+int
+parse_dso_symbols(const char *exec, int type, symbol_actor actor, void *arg);
+#endif
diff --git a/tools/ktap/kp_util.c b/tools/ktap/kp_util.c
new file mode 100644
index 0000000..6f88cd5
--- /dev/null
+++ b/tools/ktap/kp_util.c
@@ -0,0 +1,646 @@
+/*
+ * util.c
+ *
+ * This file is part of ktap by Jovi Zhangwei.
+ *
+ * Copyright (C) 2012-2013 Jovi Zhangwei <jovi.zhangwei@gmail.com>.
+ *
+ * Adapted from luajit and lua interpreter.
+ * Copyright (C) 2005-2014 Mike Pall.
+ * Copyright (C) 1994-2008 Lua.org, PUC-Rio.
+ *
+ * ktap is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * ktap is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <ctype.h>
+#include <ktap/ktap_types.h>
+#include <ktap/ktap_bc.h>
+#include "kp_util.h"
+
+/* Error message strings. */
+const char *kp_err_allmsg =
+#define ERRDEF(name, msg)       msg "\0"
+#include <ktap/ktap_errmsg.h>
+;
+
+const uint8_t kp_char_bits[257] = {
+    0,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  3,  3,  3,  3,  3,  1,  1,
+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+    2,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
+  152,152,152,152,152,152,152,152,152,152,  4,  4,  4,  4,  4,  4,
+    4,176,176,176,176,176,176,160,160,160,160,160,160,160,160,160,
+  160,160,160,160,160,160,160,160,160,160,160,  4,  4,  4,  4,132,
+    4,208,208,208,208,208,208,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,  4,  4,  4,  4,  1,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128
+};
+
+void kp_buf_init(SBuf *sb)
+{
+	sb->b = (char *)malloc(200);
+	sb->p = NULL;
+	sb->e = sb->b + 200;
+}
+
+void kp_buf_reset(SBuf *sb)
+{
+	sb->p = sb->b;
+}
+
+void kp_buf_free(SBuf *sb)
+{
+	free(sbufB(sb));
+}
+
+char *kp_buf_more(SBuf *sb, int sz)
+{
+	char *b;
+	int old_len = sbuflen(sb);
+
+	if (sz > sbufleft(sb)) {
+		b = realloc(sbufB(sb), sbuflen(sb) * 2);
+		sb->b = b;
+		sb->p = b + old_len;
+		sb->e = b + old_len * 2;
+	}
+
+	return sbufP(sb);
+}
+
+char *kp_buf_need(SBuf *sb, int sz)
+{
+	char *b;
+	int old_len = sbuflen(sb);
+
+	if (sz > sbufsz(sb)) {
+		b = realloc(sbufB(sb), sz);
+		sb->b = b;
+		sb->p = b + old_len;
+		sb->e = b + sz;
+	}
+
+	return sbufB(sb);
+}
+
+char *kp_buf_wmem(char *p, const void *q, int len)
+{
+	return (char *)memcpy(p, q, len) + len;
+}
+
+void kp_buf_putb(SBuf *sb, int c)
+{
+	char *p = kp_buf_more(sb, 1);
+	*p++ = (char)c;
+	setsbufP(sb, p);
+}
+
+ktap_str_t *kp_buf_str(SBuf *sb)
+{
+	return kp_str_new(sbufB(sb), sbuflen(sb));
+}
+
+/* Write ULEB128 to buffer. */
+char *strfmt_wuleb128(char *p, uint32_t v)
+{
+  for (; v >= 0x80; v >>= 7)
+    *p++ = (char)((v & 0x7f) | 0x80);
+  *p++ = (char)v;
+  return p;
+}
+
+void kp_err_lex(ktap_str_t *src, const char *tok, BCLine line,
+		ErrMsg em, va_list argp)
+{
+	const char *msg;
+
+	msg = kp_sprintfv(err2msg(em), argp);
+	msg = kp_sprintf("%s:%d: %s", getstr(src), line, msg);
+	if (tok)
+		msg = kp_sprintf(err2msg(KP_ERR_XNEAR), msg, tok);
+	fprintf(stderr, "%s: %s\n", err2msg(KP_ERR_XSYNTAX), msg);
+	exit(-1);
+}
+
+void *kp_reallocv(void *block, size_t osize, size_t nsize)
+{
+	return realloc(block, nsize);
+}
+
+static const ktap_val_t kp_niltv = { {NULL}, {KTAP_TNIL} } ;
+#define niltv  (&kp_niltv)
+
+#define gnode(t,i)	(&(t)->node[i])
+#define gkey(n)		(&(n)->key)
+#define gval(n)		(&(n)->val)
+
+const ktap_val_t *kp_tab_get(ktap_tab_t *t, const ktap_val_t *key)
+{
+	int i;
+
+	switch (itype(key)) {
+	case KTAP_TNIL:
+		return niltv;
+	case KTAP_TNUM:
+		for (i = 0; i <= t->hmask; i++) {
+			ktap_val_t *v = gkey(gnode(t, i));
+			if (is_number(v) && nvalue(key) == nvalue(v))
+				return gval(gnode(t, i));
+		}
+		break;
+	case KTAP_TSTR:
+		for (i = 0; i <= t->hmask; i++) {
+			ktap_val_t *v = gkey(gnode(t, i));
+			if (is_string(v) && (rawtsvalue(key) == rawtsvalue(v)))
+				return gval(gnode(t, i));
+		}
+		break;
+	default:
+		for (i = 0; i <= t->hmask; i++) {
+			if (kp_obj_equal(key, gkey(gnode(t, i))))
+				return gval(gnode(t, i));
+		}
+		break;
+	}
+
+	return niltv;
+}
+
+const ktap_val_t *kp_tab_getstr(ktap_tab_t *t, const ktap_str_t *ts)
+{
+	int i;
+
+	for (i = 0; i <= t->hmask; i++) {
+		ktap_val_t *v = gkey(gnode(t, i));
+		if (is_string(v) && (ts == rawtsvalue(v)))
+			return gval(gnode(t, i));
+	}
+
+	return niltv;
+}
+
+void kp_tab_setvalue(ktap_tab_t *t, const ktap_val_t *key, ktap_val_t *val)
+{
+	const ktap_val_t *v = kp_tab_get(t, key);
+
+	if (v != niltv) {
+		set_obj((ktap_val_t *)v, val);
+	} else {
+		if (t->freetop == t->node) {
+			int size = (t->hmask + 1) * sizeof(ktap_node_t);
+			t->node = realloc(t->node, size * 2);
+			memset(t->node + t->hmask + 1, 0, size);
+			t->freetop = t->node + (t->hmask + 1) * 2;
+			t->hmask = (t->hmask + 1) * 2 - 1;
+		}
+
+		ktap_node_t *n = --t->freetop;
+		set_obj(gkey(n), key);
+		set_obj(gval(n), val);
+	}
+}
+
+ktap_val_t *kp_tab_set(ktap_tab_t *t, const ktap_val_t *key)
+{
+	const ktap_val_t *v = kp_tab_get(t, key);
+
+	if (v != niltv) {
+		return (ktap_val_t *)v;
+	} else {
+		if (t->freetop == t->node) {
+			int size = (t->hmask + 1) * sizeof(ktap_node_t);
+			t->node = realloc(t->node, size * 2);
+			memset(t->node + t->hmask + 1, 0, size);
+			t->freetop = t->node + (t->hmask + 1) * 2;
+			t->hmask = (t->hmask + 1) * 2 - 1;
+		}
+
+		ktap_node_t *n = --t->freetop;
+		set_obj(gkey(n), key);
+		set_nil(gval(n));
+		return gval(n);
+	}
+}
+
+
+ktap_tab_t *kp_tab_new(void)
+{
+	int hsize, i;
+
+	ktap_tab_t *t = malloc(sizeof(ktap_tab_t));
+	t->gct = ~KTAP_TTAB;
+	hsize = 1024;
+	t->hmask = hsize - 1;
+	t->node = (ktap_node_t *)malloc(hsize * sizeof(ktap_node_t));
+	t->freetop = &t->node[hsize];
+	t->asize = 0;
+
+	for (i = 0; i <= t->hmask; i++) {
+		set_nil(&t->node[i].val);
+		set_nil(&t->node[i].key);
+	}
+	return t;
+}
+
+/* simple interned string array, use hash table in future  */
+static ktap_str_t **strtab;
+static int strtab_size = 1000; /* initial size */
+static int strtab_nr;
+
+void kp_str_resize(void)
+{
+	int size = strtab_size * sizeof(ktap_str_t *);
+
+	strtab = malloc(size);
+	if (!strtab) {
+		fprintf(stderr, "cannot allocate stringtable\n");
+		exit(-1);
+	}
+
+	memset(strtab, 0, size);
+	strtab_nr = 0;
+}
+
+static ktap_str_t *stringtable_search(const char *str, int len)
+{
+	int i;
+
+	for (i = 0; i < strtab_nr; i++) {
+		ktap_str_t *s = strtab[i];
+		if ((len == s->len) && !memcmp(str, getstr(s), len))
+			return s;
+	}
+
+	return NULL;
+}
+
+static void stringtable_insert(ktap_str_t *ts)
+{
+	strtab[strtab_nr++] = ts;
+
+	if (strtab_nr == strtab_size) {
+		int size = strtab_size * sizeof(ktap_str_t *);
+		strtab = realloc(strtab, size * 2);
+		memset(strtab + strtab_size, 0, size);
+		strtab_size *= 2;
+	}
+}
+
+static ktap_str_t *createstrobj(const char *str, size_t l)
+{
+	ktap_str_t *ts;
+	size_t totalsize;  /* total size of TString object */
+
+	totalsize = sizeof(ktap_str_t) + ((l + 1) * sizeof(char));
+	ts = (ktap_str_t *)malloc(totalsize);
+	ts->gct = ~KTAP_TSTR;
+	ts->len = l;
+	ts->reserved = 0;
+	ts->extra = 0;
+	memcpy(ts + 1, str, l * sizeof(char));
+	((char *)(ts + 1))[l] = '\0';  /* ending 0 */
+	return ts;
+}
+
+ktap_str_t *kp_str_new(const char *str, size_t l)
+{
+	ktap_str_t *ts = stringtable_search(str, l);
+
+	if (ts)
+		return ts;
+
+	ts = createstrobj(str, l);
+	stringtable_insert(ts);
+	return ts;
+}
+
+ktap_str_t *kp_str_newz(const char *str)
+{
+	return kp_str_new(str, strlen(str));
+}
+
+/*
+ * todo: memory leak here
+ */
+char *kp_sprintf(const char *fmt, ...)
+{
+	char *msg = malloc(128);
+
+	va_list argp;
+	va_start(argp, fmt);
+	vsprintf(msg, fmt, argp);
+	va_end(argp);
+	return msg;
+}
+
+const char *kp_sprintfv(const char *fmt, va_list argp)
+{
+	char *msg = malloc(128);
+
+	vsprintf(msg, fmt, argp);
+	return msg;
+}
+
+int kp_obj_equal(const ktap_val_t *t1, const ktap_val_t *t2)
+{
+	switch (itype(t1)) {
+	case KTAP_TNIL:
+		return 1;
+	case KTAP_TNUM:
+		return nvalue(t1) == nvalue(t2);
+	case KTAP_TTRUE:
+	case KTAP_TFALSE:
+		return itype(t1) == itype(t2);
+	case KTAP_TLIGHTUD:
+		return pvalue(t1) == pvalue(t2);
+	case KTAP_TFUNC:
+		return fvalue(t1) == fvalue(t2);
+	case KTAP_TSTR:
+		return rawtsvalue(t1) == rawtsvalue(t2);
+	default:
+		return gcvalue(t1) == gcvalue(t2);
+	}
+
+	return 0;
+}
+
+/*
+ * strglobmatch is copyed from perf(linux/tools/perf/util/string.c)
+ */
+
+/* Character class matching */
+static bool __match_charclass(const char *pat, char c, const char **npat)
+{
+	bool complement = false, ret = true;
+
+	if (*pat == '!') {
+		complement = true;
+		pat++;
+	}
+	if (*pat++ == c)	/* First character is special */
+		goto end;
+
+	while (*pat && *pat != ']') {	/* Matching */
+		if (*pat == '-' && *(pat + 1) != ']') {	/* Range */
+			if (*(pat - 1) <= c && c <= *(pat + 1))
+				goto end;
+			if (*(pat - 1) > *(pat + 1))
+				goto error;
+			pat += 2;
+		} else if (*pat++ == c)
+			goto end;
+	}
+	if (!*pat)
+		goto error;
+	ret = false;
+
+end:
+	while (*pat && *pat != ']')	/* Searching closing */
+		pat++;
+	if (!*pat)
+		goto error;
+	*npat = pat + 1;
+	return complement ? !ret : ret;
+
+error:
+	return false;
+}
+
+/* Glob/lazy pattern matching */
+static bool __match_glob(const char *str, const char *pat, bool ignore_space)
+{
+	while (*str && *pat && *pat != '*') {
+		if (ignore_space) {
+			/* Ignore spaces for lazy matching */
+			if (isspace(*str)) {
+				str++;
+				continue;
+			}
+			if (isspace(*pat)) {
+				pat++;
+				continue;
+			}
+		}
+		if (*pat == '?') {	/* Matches any single character */
+			str++;
+			pat++;
+			continue;
+		} else if (*pat == '[')	/* Character classes/Ranges */
+			if (__match_charclass(pat + 1, *str, &pat)) {
+				str++;
+				continue;
+			} else
+				return false;
+		else if (*pat == '\\') /* Escaped char match as normal char */
+			pat++;
+		if (*str++ != *pat++)
+			return false;
+	}
+	/* Check wild card */
+	if (*pat == '*') {
+		while (*pat == '*')
+			pat++;
+		if (!*pat)	/* Tail wild card matches all */
+			return true;
+		while (*str)
+			if (__match_glob(str++, pat, ignore_space))
+				return true;
+	}
+	return !*str && !*pat;
+}
+
+/**
+ * strglobmatch - glob expression pattern matching
+ * @str: the target string to match
+ * @pat: the pattern string to match
+ *
+ * This returns true if the @str matches @pat. @pat can includes wildcards
+ * ('*','?') and character classes ([CHARS], complementation and ranges are
+ * also supported). Also, this supports escape character ('\') to use special
+ * characters as normal character.
+ *
+ * Note: if @pat syntax is broken, this always returns false.
+ */
+bool strglobmatch(const char *str, const char *pat)
+{
+	return __match_glob(str, pat, false);
+}
+
+#define handle_error(str) do { perror(str); exit(-1); } while(0)
+
+#define KALLSYMS_PATH "/proc/kallsyms"
+/*
+ * read kernel symbol from /proc/kallsyms
+ */
+int kallsyms_parse(void *arg,
+		   int(*process_symbol)(void *arg, const char *name,
+		   char type, unsigned long start))
+{
+	FILE *file;
+	char *line = NULL;
+	int ret = 0;
+	int found = 0;
+
+	file = fopen(KALLSYMS_PATH, "r");
+	if (file == NULL)
+		handle_error("open " KALLSYMS_PATH " failed");
+
+	while (!feof(file)) {
+		char *symbol_addr, *symbol_name;
+		char symbol_type;
+		unsigned long start;
+		int line_len;
+		size_t n;
+
+		line_len = getline(&line, &n, file);
+		if (line_len < 0 || !line)
+			break;
+
+		line[--line_len] = '\0'; /* \n */
+
+		symbol_addr = strtok(line, " \t");
+		start = strtoul(symbol_addr, NULL, 16);
+
+		symbol_type = *strtok(NULL, " \t");
+		symbol_name = strtok(NULL, " \t");
+
+		ret = process_symbol(arg, symbol_name, symbol_type, start);
+		if (!ret)
+			found = 1;
+	}
+
+	free(line);
+	fclose(file);
+
+	return found;
+}
+
+struct ksym_addr_t {
+	const char *name;
+	unsigned long addr;
+};
+
+static int symbol_cmp(void *arg, const char *name, char type,
+		      unsigned long start)
+{
+	struct ksym_addr_t *base = arg;
+
+	if (strcmp(base->name, name) == 0) {
+		base->addr = start;
+		return 1;
+	}
+
+	return 0;
+}
+
+unsigned long find_kernel_symbol(const char *symbol)
+{
+	int ret;
+	struct ksym_addr_t arg = {
+		.name = symbol,
+		.addr = 0
+	};
+
+	ret = kallsyms_parse(&arg, symbol_cmp);
+	if (ret < 0 || arg.addr == 0) {
+		fprintf(stderr, "cannot read kernel symbol \"%s\" in %s\n",
+			symbol, KALLSYMS_PATH);
+		exit(EXIT_FAILURE);
+	}
+
+	return arg.addr;
+}
+
+
+#define AVAILABLE_EVENTS_PATH "/sys/kernel/debug/tracing/available_events"
+
+void list_available_events(const char *match)
+{
+	FILE *file;
+	char *line = NULL;
+
+	file = fopen(AVAILABLE_EVENTS_PATH, "r");
+	if (file == NULL)
+		handle_error("open " AVAILABLE_EVENTS_PATH " failed");
+
+	while (!feof(file)) {
+		int line_len;
+		size_t n;
+
+		line_len = getline(&line, &n, file);
+		if (line_len < 0 || !line)
+			break;
+
+		if (!match || strglobmatch(line, match))
+			printf("%s", line);
+	}
+
+	free(line);
+	fclose(file);
+}
+
+void process_available_tracepoints(const char *sys, const char *event,
+				   int (*process)(const char *sys,
+						  const char *event))
+{
+	char *line = NULL;
+	FILE *file;
+	char str[128] = {0};
+
+	/* add '\n' into tail */
+	snprintf(str, 64, "%s:%s\n", sys, event);
+
+	file = fopen(AVAILABLE_EVENTS_PATH, "r");
+	if (file == NULL)
+		handle_error("open " AVAILABLE_EVENTS_PATH " failed");
+
+	while (!feof(file)) {
+		int line_len;
+		size_t n;
+
+		line_len = getline(&line, &n, file);
+		if (line_len < 0 || !line)
+			break;
+
+		if (strglobmatch(line, str)) {
+			char match_sys[64] = {0};
+			char match_event[64] = {0};
+			char *sep;
+
+			sep = strchr(line, ':');
+			memcpy(match_sys, line, sep - line);
+			memcpy(match_event, sep + 1,
+					    line_len - (sep - line) - 2);
+
+			if (process(match_sys, match_event))
+				break;
+		}
+	}
+
+	free(line);
+	fclose(file);
+}
+
diff --git a/tools/ktap/kp_util.h b/tools/ktap/kp_util.h
new file mode 100644
index 0000000..e1f5db1
--- /dev/null
+++ b/tools/ktap/kp_util.h
@@ -0,0 +1,134 @@
+#ifndef __KTAP_UTIL_H__
+#define __KTAP_UTIL_H__
+
+#include <ktap/ktap_bc.h>
+#include <ktap/ktap_err.h>
+
+typedef int bool;
+#define false 0
+#define true 1
+
+/* Resizable string buffer. */
+typedef struct SBuf {
+	char *p; /* String buffer pointer. */
+	char *e; /* String buffer end pointer. */
+	char *b; /* String buffer base. */
+} SBuf;
+
+/* Resizable string buffers. Struct definition in kp_obj.h. */
+#define sbufB(sb)	((char *)(sb)->b)
+#define sbufP(sb)	((char *)(sb)->p)
+#define sbufE(sb)	((char *)(sb)->e)
+#define sbufsz(sb)	((int)(sbufE((sb)) - sbufB((sb))))
+#define sbuflen(sb)	((int)(sbufP((sb)) - sbufB((sb))))
+#define sbufleft(sb)	((int)(sbufE((sb)) - sbufP((sb))))
+#define setsbufP(sb, q) ((sb)->p = (q))
+
+void kp_buf_init(SBuf *sb);
+void kp_buf_reset(SBuf *sb);
+void kp_buf_free(SBuf *sb);
+char *kp_buf_more(SBuf *sb, int sz);
+char *kp_buf_need(SBuf *sb, int sz);
+char *kp_buf_wmem(char *p, const void *q, int len);
+void kp_buf_putb(SBuf *sb, int c);
+ktap_str_t *kp_buf_str(SBuf *sb);
+
+
+#define KP_CHAR_CNTRL	0x01
+#define KP_CHAR_SPACE	0x02
+#define KP_CHAR_PUNCT	0x04
+#define KP_CHAR_DIGIT	0x08
+#define KP_CHAR_XDIGIT	0x10
+#define KP_CHAR_UPPER	0x20
+#define KP_CHAR_LOWER	0x40
+#define KP_CHAR_IDENT	0x80
+#define KP_CHAR_ALPHA	(KP_CHAR_LOWER|KP_CHAR_UPPER)
+#define KP_CHAR_ALNUM	(KP_CHAR_ALPHA|KP_CHAR_DIGIT)
+#define KP_CHAR_GRAPH	(KP_CHAR_ALNUM|KP_CHAR_PUNCT)
+
+/* Only pass -1 or 0..255 to these macros. Never pass a signed char! */
+#define kp_char_isa(c, t)	((kp_char_bits+1)[(c)] & t)
+#define kp_char_iscntrl(c)	kp_char_isa((c), KP_CHAR_CNTRL)
+#define kp_char_isspace(c)	kp_char_isa((c), KP_CHAR_SPACE)
+#define kp_char_ispunct(c)	kp_char_isa((c), KP_CHAR_PUNCT)
+#define kp_char_isdigit(c)	kp_char_isa((c), KP_CHAR_DIGIT)
+#define kp_char_isxdigit(c)	kp_char_isa((c), KP_CHAR_XDIGIT)
+#define kp_char_isupper(c)	kp_char_isa((c), KP_CHAR_UPPER)
+#define kp_char_islower(c)	kp_char_isa((c), KP_CHAR_LOWER)
+#define kp_char_isident(c)	kp_char_isa((c), KP_CHAR_IDENT)
+#define kp_char_isalpha(c)	kp_char_isa((c), KP_CHAR_ALPHA)
+#define kp_char_isalnum(c)	kp_char_isa((c), KP_CHAR_ALNUM)
+#define kp_char_isgraph(c)	kp_char_isa((c), KP_CHAR_GRAPH)
+
+#define kp_char_toupper(c)	((c) - (kp_char_islower(c) >> 1))
+#define kp_char_tolower(c)	((c) + kp_char_isupper(c))
+
+extern const char *kp_err_allmsg;
+#define err2msg(em)     (kp_err_allmsg+(int)(em))
+
+extern const uint8_t kp_char_bits[257];
+
+
+char *strfmt_wuleb128(char *p, uint32_t v);
+void kp_err_lex(ktap_str_t *src, const char *tok, BCLine line,
+		ErrMsg em, va_list argp);
+char *kp_sprintf(const char *fmt, ...);
+const char *kp_sprintfv(const char *fmt, va_list argp);
+
+void *kp_reallocv(void *block, size_t osize, size_t nsize);
+
+void kp_str_resize(void);
+ktap_str_t *kp_str_newz(const char *str);
+ktap_str_t *kp_str_new(const char *str, size_t l);
+
+ktap_tab_t *kp_tab_new();
+const ktap_val_t *kp_tab_get(ktap_tab_t *t, const ktap_val_t *key);
+const ktap_val_t *kp_tab_getstr(ktap_tab_t *t, const ktap_str_t *ts);
+void kp_tab_setvalue(ktap_tab_t *t, const ktap_val_t *key, ktap_val_t *val);
+ktap_val_t *kp_tab_set(ktap_tab_t *t, const ktap_val_t *key);
+
+int kp_obj_equal(const ktap_val_t *t1, const ktap_val_t *t2);
+
+bool strglobmatch(const char *str, const char *pat);
+int kallsyms_parse(void *arg,
+		   int(*process_symbol)(void *arg, const char *name,
+		   char type, unsigned long start));
+
+unsigned long find_kernel_symbol(const char *symbol);
+void list_available_events(const char *match);
+void process_available_tracepoints(const char *sys, const char *event,
+				   int (*process)(const char *sys,
+						  const char *event));
+int kallsyms_parse(void *arg,
+                   int(*process_symbol)(void *arg, const char *name,
+                   char type, unsigned long start));
+
+
+#ifdef CONFIG_KTAP_FFI
+#include "../include/ktap_ffi.h"
+
+typedef struct cp_csymbol_state {
+	int cs_nr; /* number of c symbols */
+	int cs_arr_size; /* size of current symbol arrays */
+	csymbol *cs_arr;
+} cp_csymbol_state;
+
+cp_csymbol_state *ctype_get_csym_state(void);
+void kp_dump_csymbols();
+#endif
+
+ktap_eventdesc_t *kp_parse_events(const char *eventdef);
+void cleanup_event_resources(void);
+
+extern int verbose;
+#define verbose_printf(...) \
+	if (verbose)	\
+		printf("[verbose] " __VA_ARGS__);
+
+
+void kp_dump_proto(ktap_proto_t *pt);
+typedef int (*ktap_writer)(const void* p, size_t sz, void* ud);
+int kp_bcwrite(ktap_proto_t *pt, ktap_writer writer, void *data, int strip);
+
+int kp_create_reader(const char *output);
+#endif
diff --git a/tools/ktap/samples/ansi/ansi_color_demo.kp b/tools/ktap/samples/ansi/ansi_color_demo.kp
new file mode 100644
index 0000000..2998fe0
--- /dev/null
+++ b/tools/ktap/samples/ansi/ansi_color_demo.kp
@@ -0,0 +1,22 @@
+#!/usr/bin/env ktap
+
+#this script demonstrate how to use ktap to output color text.
+
+ansi.clear_screen()
+
+ansi.set_color(32)
+printf("this line should be Green color\n")
+
+ansi.set_color(31)
+printf("this line should be Red color\n")
+
+ansi.set_color2(34, 43)
+printf("this line should be Blue color, with Yellow background\n")
+
+ansi.reset_color()
+ansi.set_color3(34, 46, 4)
+printf("this line should be Blue color, with Cyan background, underline single attribute\n")
+
+ansi.reset_color()
+ansi.new_line()
+
diff --git a/tools/ktap/samples/basic/backtrace.kp b/tools/ktap/samples/basic/backtrace.kp
new file mode 100644
index 0000000..4c13c1a
--- /dev/null
+++ b/tools/ktap/samples/basic/backtrace.kp
@@ -0,0 +1,6 @@
+#!/usr/bin/env ktap
+
+trace sched:sched_switch {
+	print(stack())
+}
+
diff --git a/tools/ktap/samples/basic/event_trigger.kp b/tools/ktap/samples/basic/event_trigger.kp
new file mode 100644
index 0000000..7bf4720
--- /dev/null
+++ b/tools/ktap/samples/basic/event_trigger.kp
@@ -0,0 +1,27 @@
+#!/usr/bin/env ktap
+
+#This ktap script will output all tracepoint events between
+#sys_enter_open and sys_exit_open, in one cpu.
+
+var soft_disabled = 1
+var this_cpu = 0
+
+trace syscalls:sys_enter_open {
+	print(argstr)
+	soft_disabled = 0
+	this_cpu = cpu
+}
+
+trace *:* {
+	if (soft_disabled == 0 && cpu == this_cpu) {
+		print(argstr)
+	}
+}
+
+trace syscalls:sys_exit_open {
+	print(argstr)
+	if (cpu == this_cpu) {
+		exit()
+	}
+}
+
diff --git a/tools/ktap/samples/basic/event_trigger_ftrace.kp b/tools/ktap/samples/basic/event_trigger_ftrace.kp
new file mode 100644
index 0000000..f2ebfa5
--- /dev/null
+++ b/tools/ktap/samples/basic/event_trigger_ftrace.kp
@@ -0,0 +1,27 @@
+#!/usr/bin/env ktap
+
+#This ktap script will output all function calling between
+#sys_enter_open and sys_exit_open, in one cpu.
+
+var soft_disabled = 1
+var this_cpu = 0
+
+trace syscalls:sys_enter_open {
+	print(argstr)
+	soft_disabled = 0
+	this_cpu = cpu
+}
+
+trace ftrace:function {
+	if (soft_disabled == 0 && cpu == this_cpu) {
+		print(argstr)
+	}
+}
+
+trace syscalls:sys_exit_open {
+	print(argstr)
+	if (cpu == this_cpu) {
+		exit()
+	}
+}
+
diff --git a/tools/ktap/samples/basic/ftrace.kp b/tools/ktap/samples/basic/ftrace.kp
new file mode 100644
index 0000000..22cff5d
--- /dev/null
+++ b/tools/ktap/samples/basic/ftrace.kp
@@ -0,0 +1,8 @@
+#!/usr/bin/env ktap
+
+#Description: output all mutex* function event
+
+trace ftrace:function /ip==mutex*/ {
+	print(cpu, pid, execname, argstr)
+}
+
diff --git a/tools/ktap/samples/basic/function_time.kp b/tools/ktap/samples/basic/function_time.kp
new file mode 100644
index 0000000..51d0f89
--- /dev/null
+++ b/tools/ktap/samples/basic/function_time.kp
@@ -0,0 +1,62 @@
+#!/usr/bin/env ktap
+
+#Demo for thread-local variable
+#
+#Note this kind of function time tracing already handled concurrent issue,
+#but not aware on the recursion problem, user need to aware this limitation,
+#so don't use this script to trace function which could be called recursive.
+
+var self = {}
+var count_max = 0
+var count_min = 0
+var count_num = 0
+var total_time = 0
+
+printf("measure time(us) of function vfs_read\n");
+
+trace probe:vfs_read {
+	if (execname == "ktap") {
+		return
+	}
+
+	self[tid] = gettimeofday_us()
+}
+
+trace probe:vfs_read%return {
+	if (execname == "ktap") {
+		return
+	}
+
+	if (self[tid] == nil) {
+		return
+	}
+
+	var durtion = gettimeofday_us() - self[tid]
+	if (durtion > count_max) {
+		count_max = durtion
+	}
+	var min = count_min
+	if (min == 0 || durtion < min) {
+		count_min = durtion
+	}
+
+	count_num = count_num + 1
+	total_time = total_time + durtion
+
+	self[tid] = nil
+}
+
+trace_end {
+	var avg
+	if (count_num == 0) {
+		avg = 0
+	} else {
+		avg = total_time/count_num
+	}
+
+	printf("avg\tmax\tmin\n");
+	printf("-------------------\n")
+	printf("%d\t%d\t%d\n", avg, count_max, count_min)
+}
+
+
diff --git a/tools/ktap/samples/basic/kretprobe.kp b/tools/ktap/samples/basic/kretprobe.kp
new file mode 100644
index 0000000..e03a7a2
--- /dev/null
+++ b/tools/ktap/samples/basic/kretprobe.kp
@@ -0,0 +1,6 @@
+#!/usr/bin/env ktap
+
+trace probe:vfs_read%return fd=$retval {
+	print(execname, argstr);
+}
+
diff --git a/tools/ktap/samples/basic/memcpy_memset.kp b/tools/ktap/samples/basic/memcpy_memset.kp
new file mode 100644
index 0000000..18008cc
--- /dev/null
+++ b/tools/ktap/samples/basic/memcpy_memset.kp
@@ -0,0 +1,23 @@
+#!/usr/bin/env ktap
+
+# This script collect kernel memcpy/memset size histgoram output.
+
+var h_memcpy = {}
+var h_memset = {}
+
+trace probe:memcpy size=%dx {
+	h_memcpy[arg1] += 1
+}
+
+trace probe:memset size=%dx {
+	h_memset[arg1] += 1
+}
+
+trace_end {
+	print("memcpy size hist:")
+	print_hist(h_memcpy)
+
+	print()
+	print("memset size hist:")
+	print_hist(h_memset)
+}
diff --git a/tools/ktap/samples/ffi/ffi_kmalloc.kp b/tools/ktap/samples/ffi/ffi_kmalloc.kp
new file mode 100644
index 0000000..221827d
--- /dev/null
+++ b/tools/ktap/samples/ffi/ffi_kmalloc.kp
@@ -0,0 +1,19 @@
+#!/usr/bin/env ktap
+
+ffi.cdef[[
+	typedef unsigned gfp_t;
+	typedef unsigned long size_t;
+	void *__kmalloc( size_t size, gfp_t flags);
+	void kfree(const void *objp);
+]]
+
+var t1 = gettimeofday_us()
+
+for (i = 1, 1000, 1) {
+	var object = ffi.C.__kmalloc(128, 208) #GFP_KERNEL is 208
+	ffi.C.kfree(object)
+}
+
+var t2 = gettimeofday_us()
+
+printf("execution time: %d us\n", t2 - t1)
diff --git a/tools/ktap/samples/ffi/printk.kp b/tools/ktap/samples/ffi/printk.kp
new file mode 100644
index 0000000..72e01b5
--- /dev/null
+++ b/tools/ktap/samples/ffi/printk.kp
@@ -0,0 +1,10 @@
+ffi.cdef[[
+	int printk(const char *fmt, ...);
+]]
+
+
+ffi.C.printk("This is printed out by ffi\n")
+ffi.C.printk("Show me the %s\n", "code")
+ffi.C.printk("%s should be at %02d/%02d %02d:%02d:%02d\n", "New Year", 1, 1, 0, 0, 0)
+ffi.C.printk("\'a\' + 5 = \'%c\'\n", 95 + 5)
+ffi.C.printk("The string is located at 0x%p\n", "str")
diff --git a/tools/ktap/samples/ffi/sched_clock.kp b/tools/ktap/samples/ffi/sched_clock.kp
new file mode 100644
index 0000000..d3c5d5d
--- /dev/null
+++ b/tools/ktap/samples/ffi/sched_clock.kp
@@ -0,0 +1,6 @@
+ffi.cdef[[
+	unsigned long long sched_clock();
+]]
+
+var ret = ffi.C.sched_clock()
+print("C.sched_clock returned, value: ", ret)
diff --git a/tools/ktap/samples/ffi/skb_cast.kp b/tools/ktap/samples/ffi/skb_cast.kp
new file mode 100644
index 0000000..f5d846a
--- /dev/null
+++ b/tools/ktap/samples/ffi/skb_cast.kp
@@ -0,0 +1,106 @@
+#!/usr/bin/env ktap
+
+# This script demonstrate how to access kernel data structure in ktap,
+# it's based on ffi.cast function.
+# Tested in x86-64.
+#
+# Below sk_buff structure definition should be retrived from vmlinux
+# You should fetch your sk_buff type definition in your vmlinux.
+#
+# Note: In future, you don't have to declare sk_buff in this script.
+
+ffi.cdef [[
+typedef union ktime {
+    long long int tv64;
+} ktime_t;
+
+typedef unsigned char __u8;
+typedef short unsigned int __u16;
+typedef short unsigned int __be16;
+typedef unsigned int __u32;
+typedef unsigned int __wsum;
+
+typedef int dma_cookie_t;
+typedef unsigned int sk_buff_data_t;
+
+typedef struct { int counter; } atomic_t;
+
+struct sk_buff {
+    struct sk_buff *next;
+    struct sk_buff *prev;
+    ktime_t tstamp;
+    struct sock *sk;
+    struct net_device *dev;
+    char cb[48];
+    long unsigned int _skb_refdst;
+    struct sec_path *sp;
+    unsigned int len;
+    unsigned int data_len;
+    __u16 mac_len;
+    __u16 hdr_len;
+    union {
+        __wsum csum;
+	/* struct {...}; */
+    };
+    __u32 priority;
+    __u8 local_df : 1;
+    __u8 cloned : 1;
+    __u8 ip_summed : 2;
+    __u8 nohdr : 1;
+    __u8 nfctinfo : 3;
+    __u8 pkt_type : 3;
+    __u8 fclone : 2;
+    __u8 ipvs_property : 1;
+    __u8 peeked : 1;
+    __u8 nf_trace : 1;
+    __be16 protocol;
+    unsigned long *destructor; /* void (*destructor)(struct sk_buff *); */
+    struct nf_conntrack *nfct;
+    struct nf_bridge_info *nf_bridge;
+    int skb_iif;
+    __u32 rxhash;
+    __be16 vlan_proto;
+    __u16 vlan_tci;
+    __u16 tc_index;
+    __u16 tc_verd;
+    __u16 queue_mapping;
+    __u8 ndisc_nodetype : 2;
+    __u8 pfmemalloc : 1;
+    __u8 ooo_okay : 1;
+    __u8 l4_rxhash : 1;
+    __u8 wifi_acked_valid : 1;
+    __u8 wifi_acked : 1;
+    __u8 no_fcs : 1;
+    __u8 head_frag : 1;
+    __u8 encapsulation : 1;
+    union {
+        unsigned int napi_id;
+        dma_cookie_t dma_cookie;
+    };
+    __u32 secmark;
+    union {
+        __u32 mark;
+        __u32 dropcount;
+        __u32 reserved_tailroom;
+    };
+    __be16 inner_protocol;
+    __u16 inner_transport_header;
+    __u16 inner_network_header;
+    __u16 inner_mac_header;
+    __u16 transport_header;
+    __u16 network_header;
+    __u16 mac_header;
+    sk_buff_data_t tail;
+    sk_buff_data_t end;
+    unsigned char *head;
+    unsigned char *data;
+    unsigned int truesize;
+    atomic_t users;
+};
+]]
+
+trace net:netif_receive_skb {
+	var skb = ffi.cast("struct sk_buff *", arg0)
+	printf("skb len: %d, data_len: %d, iif: %d\n", skb.len, skb.data_len, skb.skb_iif)
+}
+
diff --git a/tools/ktap/samples/game/tetris.kp b/tools/ktap/samples/game/tetris.kp
new file mode 100644
index 0000000..07723cb
--- /dev/null
+++ b/tools/ktap/samples/game/tetris.kp
@@ -0,0 +1,297 @@
+#!/usr/bin/env ktap
+ 
+#
+# Tetris KTAP Script
+#
+# Copyright (C) 2013/OCT/05 Tadaki SAKAI
+#
+# based on stapgames (Systemtap Game Collection)
+#   https://github.com/mhiramat/stapgames/blob/master/games/tetris.stp
+#
+#   - Requirements
+#     Kernel Configuration: CONFIG_KPROBE_EVENT=y
+#                           CONFIG_EVENT_TRACING=y
+#                           CONFIG_PERF_EVENTS=y
+#                           CONFIG_DEBUG_FS=y
+#     CPU Architecture : x86_64
+#
+#   - Setup
+#     $ sudo mount -t debugfs none /sys/kernel/debug/
+#
+#     $ git clone https://github.com/ktap/ktap
+#     $ cd ktap
+#     $ make 2>&1 | tee ../make.log
+#     $ sudo make load
+#     $ sudo sh -c 'echo 50000 > /sys/module/ktapvm/parameters/max_exec_count'
+#
+#   - Run Tetris
+#     $ sudo ./ktap samples/game/tetris.kp
+#
+ 
+#
+# global value
+#
+
+var empty = -1
+
+var key_code = 0
+var point = 0
+var block_number = 0
+var height = 0
+var height_update = 0
+
+var destination_position = {}
+ 
+var block_data0 = {}
+var block_data1 = {}
+var block_data2 = {}
+var block_data3 = {}
+var block_data4 = {}
+var block_data5 = {}
+var block_data6 = {}
+var block_table = {}
+ 
+#
+# utils
+#
+ 
+function rand(max) {
+	var r = gettimeofday_us()
+	if (r < 0) {
+		r = r * -1
+	}
+	return r % max
+}
+
+var display_buffer = {}
+
+function update_display() {
+	var tmp
+	for (i = 0, 239, 1) {
+		if ((i % 12 - 11) != 0) {
+			tmp = ""
+		} else {
+			tmp = "\n"
+		}
+
+		if (display_buffer[240 + i] == empty) {
+			printf("  %s", tmp)
+		} else {
+			var color = display_buffer[240 + i] + 40
+			ansi.set_color2(color, color)
+			printf("  %s", tmp)
+			ansi.reset_color()
+		}
+
+		# clear the display buffer
+		display_buffer[240 + i] = display_buffer[i]
+	}
+
+	printf("%d\n",point)
+}
+
+ 
+
+#
+# Initialize
+#
+ 
+# Create blocks
+# block is represented by the position from the center.
+# Every block has "L" part in the center except for a bar.
+block_data0[0] = -11 # non-"L" part for each block
+block_data1[0] = -24
+block_data2[0] = 2
+block_data3[0] = 13
+block_data4[0] = -13
+block_data5[0] = -1
+block_data6[0] = 2
+	
+block_table[0] = block_data0
+block_table[1] = block_data1
+block_table[2] = block_data2
+block_table[3] = block_data3
+block_table[4] = block_data4
+block_table[5] = block_data5
+block_table[6] = block_data6
+ 
+for (i = 0, len(block_table) - 1, 1) {
+	# common "L" part
+	block_table[i][1] = 0
+	block_table[i][2] = 1
+	block_table[i][3] = -12
+}
+ 
+block_table[6][3] = -1 # bar is not common
+# Position: 1 row has 12 columns, 
+# and (x, y) is represented by h = x + y * 12.p
+height = 17 # First block position (center)
+
+for (i = 0, 240, 1) {
+	var tmp
+	# Wall and Floor (sentinel)
+	if (((i % 12) < 2) || (i > 228)) {
+		tmp = 7 # White
+	} else {
+		tmp = empty
+	}
+	display_buffer[i - 1] = tmp
+	display_buffer[240 + i - 1] = tmp
+}
+
+block_number = rand(7)
+
+ansi.clear_screen()
+ 
+ 
+#
+# Key Input
+#
+ 
+trace probe:kbd_event handle=%di event_type=%si event_code=%dx value=%cx {
+	# Only can run it in x86_64
+	#
+	# Register follow x86_64 call conversion:
+	#
+	# x86_64:
+	#	%rcx	4 argument
+	#	%rdx	3 argument
+	#	%rsi	2 argument
+	#	%rdi	1 argument
+ 
+	var event_code = arg3
+	var value = arg4
+ 
+	if (value != 0) {
+		if ((event_code - 4) != 0) {
+			key_code = event_code
+		}
+	}
+}
+ 
+ 
+#
+# timer
+#
+ 
+tick-200ms {
+	ansi.clear_screen()
+ 
+	var f = 0 # move/rotate flag
+	var d
+ 
+	if (key_code != 0) { # if key is pressed
+		if(key_code != 103) { #move left or right
+			# d: movement direction
+			if ((key_code - 105) != 0) {
+				if ((key_code - 106) != 0) {
+					d = 0
+				} else {
+					d = 1
+				}
+			} else {
+				d = -1
+			}
+ 
+			for (i = 0, 3, 1) { # check if the block can be moved
+				# destination is free
+				if (display_buffer[height +
+					block_table[block_number][i] + d] 
+				    != empty) {
+					f = 1
+				}
+			}
+			# move if destinations of every block are free
+			if (f == 0) {
+				height = height + d
+			} 
+		} else { # rotate
+			for (i = 0, 3, 1) { # check if block can be rotated
+				# each block position
+				var p = block_table[block_number][i]
+ 
+				# destination x pos(p/12 rounded)
+				var v = (p * 2 + 252) / 24 - 10
+				var w = p - v * 12 # destination y pos
+ 
+				# destination position
+				destination_position[i] = w * 12 - v
+ 
+				# check if desetination is free
+				if (display_buffer[height +
+				    destination_position[i]] != empty) {
+					f = 1
+				}
+			}
+ 
+			if (f == 0) {
+				# rotate if destinations of every block
+				# are free
+				for (i = 0, 3, 1) {
+					block_table[block_number][i] = 
+						destination_position[i] 
+				}
+			}
+		}
+	}
+	key_code = 0 # clear the input key
+ 
+	f = 0
+	for (i = 0, 3, 1) { # drop 1 row
+		# check if destination is free
+		var p = height + block_table[block_number][i]
+		if (display_buffer[12 + p] != empty) {
+			f = 1
+		}
+ 
+		# copy the moving block to display buffer
+		display_buffer[240 + p] = block_number
+	}
+
+	if ((f == 1) && (height == 17)) {
+		update_display()
+		exit() # exit if there are block at initial position
+	}
+ 
+	height_update = !height_update
+	if (height_update != 0) {
+		if(f != 0) { # the block can't drop anymore
+			for (i = 0, 3, 1) {
+				# fix the block
+				display_buffer[height + 
+				  block_table[block_number][i]] = block_number
+			}
+			# determin the next block
+			block_number = rand(7)
+			height = 17 # make the block to initial position
+		} else {
+			height = height + 12 # drop the block 1 row
+		}
+	}
+ 
+	var k = 1
+	for (i = 18, 0, -1) { #check if line is filled
+		# search for filled line
+		var j = 10
+		while ((j > 0) && 
+		       (display_buffer[i * 12 + j] != empty)) {
+			j = j - 1
+		}
+ 
+		if (j == 0) { # filled!
+			# add a point: 1 line - 1 point, ..., tetris - 10points
+			point = point + k
+			k = k + 1
+ 
+			# drop every upper block
+			j = (i + 1) * 12
+			i = i + 1
+			while (j > 2 * 12) {
+				j = j - 1
+				display_buffer[j] = display_buffer[j - 12] 
+			}
+		}
+	}
+ 
+	update_display()
+}
diff --git a/tools/ktap/samples/helloworld.kp b/tools/ktap/samples/helloworld.kp
new file mode 100644
index 0000000..5673c15
--- /dev/null
+++ b/tools/ktap/samples/helloworld.kp
@@ -0,0 +1,3 @@
+#!/usr/bin/env ktap
+
+print("Hello World! I am ktap")
diff --git a/tools/ktap/samples/interrupt/hardirq_time.kp b/tools/ktap/samples/interrupt/hardirq_time.kp
new file mode 100644
index 0000000..f305a41
--- /dev/null
+++ b/tools/ktap/samples/interrupt/hardirq_time.kp
@@ -0,0 +1,25 @@
+#!/usr/bin/env ktap
+
+#this script output each average consumimg time of each hardirq
+
+var s = {}
+var map = {}
+
+trace irq:irq_handler_entry {
+	map[cpu] = gettimeofday_us()
+}
+
+trace irq:irq_handler_exit {
+	var entry_time = map[cpu]
+	if (entry_time == nil) {
+		return;
+	}
+
+	s[arg0] += gettimeofday_us() - entry_time
+	map[cpu] = nil
+}
+
+trace_end {
+	print_hist(s)
+}
+
diff --git a/tools/ktap/samples/interrupt/softirq_time.kp b/tools/ktap/samples/interrupt/softirq_time.kp
new file mode 100644
index 0000000..561733a
--- /dev/null
+++ b/tools/ktap/samples/interrupt/softirq_time.kp
@@ -0,0 +1,24 @@
+#!/usr/bin/env ktap
+
+#this script output each average consumimg time of each softirq line
+var s = {}
+var map = {}
+
+trace irq:softirq_entry {
+	map[cpu] = gettimeofday_us()
+}
+
+trace irq:softirq_exit {
+	var entry_time = map[cpu]
+	if (entry_time == nil) {
+		return;
+	}
+
+	s[arg0] += gettimeofday_us() - entry_time
+	map[cpu] = nil
+}
+
+trace_end {
+	print_hist(s)
+}
+
diff --git a/tools/ktap/samples/io/kprobes-do-sys-open.kp b/tools/ktap/samples/io/kprobes-do-sys-open.kp
new file mode 100644
index 0000000..692f6c4
--- /dev/null
+++ b/tools/ktap/samples/io/kprobes-do-sys-open.kp
@@ -0,0 +1,20 @@
+#!/usr/bin/env ktap
+
+#Only can run it in x86_64
+#
+#Register follow x86_64 call conversion:
+#
+#x86_64:
+#	%rcx	4 argument
+#	%rdx	3 argument
+#	%rsi	2 argument
+#	%rdi	1 argument
+
+trace probe:do_sys_open dfd=%di filename=%si flags=%dx mode=%cx {
+	printf("[do_sys_open entry]: (%s) open file (%s)\n",
+		execname,  user_string(arg2))
+}
+
+trace probe:do_sys_open%return fd=$retval {
+	printf("[do_sys_open exit]:  return fd (%d)\n", arg2)
+}
diff --git a/tools/ktap/samples/io/traceio.kp b/tools/ktap/samples/io/traceio.kp
new file mode 100644
index 0000000..1ef6588
--- /dev/null
+++ b/tools/ktap/samples/io/traceio.kp
@@ -0,0 +1,61 @@
+#! /usr/bin/env ktap
+
+# Based on systemtap traceio.stp
+
+var reads = {}
+var writes = {}
+var total_io = {}
+
+trace syscalls:sys_exit_read {
+	reads[execname] += arg1
+	total_io[execname] += arg1
+}
+
+trace syscalls:sys_exit_write {
+	writes[execname] += arg1
+	total_io[execname] += arg1
+}
+
+function humanread_digit(bytes) {
+	if (bytes > 1024*1024*1024) {
+		return bytes/1024/1024/1024
+	} elseif (bytes > 1024*1024) {
+		return bytes/1024/1024
+	} elseif (bytes > 1024) {
+		return bytes/1024
+	} else {
+		return bytes
+	}
+}
+
+function humanread_x(bytes) {
+	if (bytes > 1024*1024*1024) {
+		return " GiB"
+	} elseif (bytes > 1024*1024) {
+		return " MiB"
+	} elseif (bytes > 1024) {
+		return " KiB"
+	} else {
+		return "   B"
+	}
+}
+
+tick-1s {
+	ansi.clear_screen()
+	for (exec, _ in pairs(total_io)) {
+		var readnum = reads[exec]
+		var writenum = writes[exec]
+
+		if (readnum == nil) {
+			readnum = 0
+		}
+		if (writenum == nil) {
+			writenum = 0
+		}
+		printf("%15s r: %12d%s w: %12d%s\n", exec,
+			humanread_digit(readnum), humanread_x(readnum),
+			humanread_digit(writenum), humanread_x(writenum))
+	}
+	printf("\n")
+}
+
diff --git a/tools/ktap/samples/mem/kmalloc-stack.kp b/tools/ktap/samples/mem/kmalloc-stack.kp
new file mode 100644
index 0000000..8406461
--- /dev/null
+++ b/tools/ktap/samples/mem/kmalloc-stack.kp
@@ -0,0 +1,12 @@
+#!/usr/bin/env ktap
+
+var s = {}
+
+trace kmem:kmalloc {
+	s[stack()] += 1
+}
+
+tick-60s {
+	print_hist(s)
+}
+
diff --git a/tools/ktap/samples/mem/kmem_count.kp b/tools/ktap/samples/mem/kmem_count.kp
new file mode 100644
index 0000000..ab5c8a9
--- /dev/null
+++ b/tools/ktap/samples/mem/kmem_count.kp
@@ -0,0 +1,29 @@
+#!/usr/bin/env ktap
+
+var count1 = 0
+trace kmem:kmalloc {
+	count1 += 1
+}
+
+var count2 = 0
+trace kmem:kfree {
+	count2 += 1
+}
+
+var count3 = 0
+trace kmem:mm_page_alloc {
+	count3 += 1
+}
+
+var count4 = 0
+trace kmem:mm_page_free {
+	count4 += 1
+}
+
+trace_end {
+	print("\n")
+	print("kmem:kmalloc:\t", count1)
+	print("kmem:kfree:\t", count2)
+	print("kmem:mm_page_alloc:", count3)
+	print("kmem:mm_page_free:", count4)
+}
diff --git a/tools/ktap/samples/network/tcp_ipaddr.kp b/tools/ktap/samples/network/tcp_ipaddr.kp
new file mode 100644
index 0000000..6363aef
--- /dev/null
+++ b/tools/ktap/samples/network/tcp_ipaddr.kp
@@ -0,0 +1,20 @@
+#!/usr/bin/env ktap
+
+#This script print source and destination IP address of received tcp message
+#
+#Tested in x86_64
+#
+#function tcp_recvmsg prototype:
+#int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+#                size_t len, int nonblock, int flags, int *addr_len)
+#
+
+var ip_sock_saddr = net.ip_sock_saddr
+var ip_sock_daddr = net.ip_sock_daddr
+var format_ip_addr = net.format_ip_addr
+
+trace probe:tcp_recvmsg sock=%si {
+	var saddr = format_ip_addr(ip_sock_saddr(arg1))
+	var daddr = format_ip_addr(ip_sock_daddr(arg1))
+	printf("%s -> %s\n", daddr, saddr)
+}
diff --git a/tools/ktap/samples/profiling/function_profiler.kp b/tools/ktap/samples/profiling/function_profiler.kp
new file mode 100644
index 0000000..1414936
--- /dev/null
+++ b/tools/ktap/samples/profiling/function_profiler.kp
@@ -0,0 +1,41 @@
+#!/usr/bin/env ktap
+
+#kernel function profile
+#You can use this script to know what function is called frequently,
+#without enable CONFIG_FUNCTION_PROFILER in kernel.
+
+var s = {}
+
+trace ftrace:function {
+	s[ipof(arg0)] += 1
+}
+
+trace_end {
+	print_hist(s)
+}
+
+#sample output
+#^C
+#                          value ------------- Distribution ------------- count
+#               sub_preempt_count | @@@@@                                  34904
+#               add_preempt_count | @@@@@                                  33435
+#              nsecs_to_jiffies64 | @@@                                    19919
+# irqtime_account_process_tick... | @                                      9970
+#               account_idle_time | @                                      9880
+#                  _raw_spin_lock |                                        5100
+#                _raw_spin_unlock |                                        5021
+#     _raw_spin_unlock_irqrestore |                                        4235
+#          _raw_spin_lock_irqsave |                                        4232
+#                 __rcu_read_lock |                                        3373
+#               __rcu_read_unlock |                                        3373
+#                  lookup_address |                                        2392
+#             pfn_range_is_mapped |                                        2384
+#      update_cfs_rq_blocked_load |                                        1983
+#                        idle_cpu |                                        1808
+#                       ktime_get |                                        1394
+#            _raw_spin_unlock_irq |                                        1270
+#              _raw_spin_lock_irq |                                        1091
+#                     update_curr |                                        950
+#             irqtime_account_irq |                                        950
+#                             ... |
+#
diff --git a/tools/ktap/samples/profiling/kprobe_all_kernel_functions.kp b/tools/ktap/samples/profiling/kprobe_all_kernel_functions.kp
new file mode 100644
index 0000000..d42f7de
--- /dev/null
+++ b/tools/ktap/samples/profiling/kprobe_all_kernel_functions.kp
@@ -0,0 +1,13 @@
+#!/usr/bin/env ktap
+
+#enable kprobe on all available kernel functios in /proc/kallsyms.
+#
+#This script is very dangerous, it will softlockup your system. 
+#and make your system extremely slow, but the reason is not
+#caused by ktap.
+#
+#DON'T use this script, at least for now.
+
+trace probe:* {
+	print(argstr)
+}
diff --git a/tools/ktap/samples/profiling/stack_profile.kp b/tools/ktap/samples/profiling/stack_profile.kp
new file mode 100644
index 0000000..3595a65
--- /dev/null
+++ b/tools/ktap/samples/profiling/stack_profile.kp
@@ -0,0 +1,27 @@
+#!/usr/bin/env ktap
+
+# This ktap script samples stacktrace of system per 10us,
+# you can use generated output to make a flame graph.
+#
+# Flame Graphs:
+# http://dtrace.org/blogs/brendan/2012/03/17/linux-kernel-performance-flame-graphs/
+#
+#
+# TODO: use aggregation instead of table.
+
+#pre-allocate 2000 record entries, enlarge it if it's not enough
+var s = table.new(0, 2000)
+
+profile-10us {
+	#skip 12 stack entries, and dump all remain entries.
+	s[stack(-1, 12)] += 1
+}
+
+tick-60s {
+	exit()
+}
+
+trace_end {
+	print_hist(s, 100000)
+}
+
diff --git a/tools/ktap/samples/schedule/sched_transition.kp b/tools/ktap/samples/schedule/sched_transition.kp
new file mode 100644
index 0000000..bad90e8
--- /dev/null
+++ b/tools/ktap/samples/schedule/sched_transition.kp
@@ -0,0 +1,5 @@
+#!/usr/bin/env ktap
+
+trace sched:sched_switch {
+	printf("%s ... ", arg0)
+}
diff --git a/tools/ktap/samples/schedule/schedtimes.kp b/tools/ktap/samples/schedule/schedtimes.kp
new file mode 100644
index 0000000..19de1bf
--- /dev/null
+++ b/tools/ktap/samples/schedule/schedtimes.kp
@@ -0,0 +1,131 @@
+#!/usr/vin/env ktap
+
+#schedtimer.kp
+#Initially inspired by Systemtap schedtimes.stp
+#and more bugfree compare with Systemtap's version
+#
+#Note that the time value is associate with pid, not with execname strictly,
+#sometime you will found there have sleep time for command "ls", the reason
+#is that sleep time is belong to parent process bash, so clear on this.
+
+var RUNNING = 0
+var QUEUED = 1
+var SLEEPING = 2
+var DEAD = 64
+
+var run_time = {}
+var queued_time = {}
+var sleep_time = {}
+var io_wait_time = {}
+
+var pid_state = {}
+var pid_names = {}
+var prev_timestamp = {}
+var io_wait = {}
+
+trace sched:sched_switch {
+	var prev_comm = arg0
+	var prev_pid = arg1
+	var prev_state = arg3
+	var next_comm = arg4
+	var next_pid = arg5
+	var t = gettimeofday_us()
+
+	if (pid_state[prev_pid] == nil) {
+		#do nothing
+	} elseif (pid_state[prev_pid] == RUNNING) {
+		run_time[prev_pid] += t - prev_timestamp[prev_pid]
+	} elseif (pid_state[prev_pid] == QUEUED) {
+		#found this:
+		#sched_wakeup comm=foo
+		#sched_switch prev_comm=foo
+		run_time[prev_pid] += t - prev_timestamp[prev_pid]
+	}
+
+	pid_names[prev_pid] = prev_comm
+	prev_timestamp[prev_pid] = t
+
+	if (prev_state == DEAD) {
+		pid_state[prev_pid] = DEAD
+	} elseif (prev_state > 0) {
+		if (in_iowait() == 1) {
+			io_wait[prev_pid] = 1
+		}
+		pid_state[prev_pid] = SLEEPING
+	} elseif (prev_state == 0) {
+		pid_state[prev_pid] = QUEUED
+	}
+
+	if (pid_state[next_pid] == nil) {
+		pid_state[next_pid] = RUNNING
+	} elseif (pid_state[next_pid] == QUEUED) {
+		queued_time[next_pid] += t - prev_timestamp[next_pid]
+		pid_state[next_pid] = RUNNING
+	}
+
+	pid_names[next_pid] = next_comm
+	prev_timestamp[next_pid] = t
+}
+
+trace sched:sched_wakeup, sched:sched_wakeup_new {
+	var comm = arg0
+	var wakeup_pid = arg1
+	var success = arg3
+	var t = gettimeofday_us()
+
+	if (pid_state[wakeup_pid] == nil) {
+		#do nothing
+	} elseif (pid_state[wakeup_pid] == SLEEPING) {
+		var durtion = t - prev_timestamp[wakeup_pid]
+
+		sleep_time[wakeup_pid] += durtion
+		if (io_wait[wakeup_pid] == 1) {
+			io_wait_time[wakeup_pid] += durtion
+			io_wait[wakeup_pid] = 0
+		}
+	} elseif (pid_state[wakeup_pid] == RUNNING) {
+		return
+	}
+
+	pid_names[wakeup_pid] = comm
+	prev_timestamp[wakeup_pid] = t
+	pid_state[wakeup_pid] = QUEUED
+}
+
+trace_end {
+	var t = gettimeofday_us()
+	
+	for (_pid, _state in pairs(pid_state)) {
+		var durtion = t - prev_timestamp[_pid]
+		if (_state == SLEEPING) {
+			sleep_time[_pid] += durtion
+		} elseif (_state == QUEUED) {
+			queued_time[_pid] += durtion
+		} elseif (_state == RUNNING) {
+			run_time[_pid] += durtion
+		}
+	}
+
+	printf ("%16s: %6s %10s %10s %10s %10s %10s\n\n",
+		"execname", "pid", "run(us)", "sleep(us)", "io_wait(us)",
+		"queued(us)", "total(us)")
+
+	for (_pid, _time in pairs(run_time)) {
+		if (sleep_time[_pid] == nil) {
+			sleep_time[_pid] = 0
+		}
+		if (queued_time[_pid] == nil) {
+			queued_time[_pid] = 0
+		}
+
+		if (io_wait_time[_pid] == nil) {
+			io_wait_time[_pid] = 0
+		}
+
+		printf("%16s: %6d %10d %10d %10d %10d %10d\n",
+			pid_names[_pid], _pid, run_time[_pid],
+			sleep_time[_pid], io_wait_time[_pid],
+			queued_time[_pid], run_time[_pid] + sleep_time[_pid] +
+			queued_time[_pid]);
+	}
+}
diff --git a/tools/ktap/samples/syscalls/errinfo.kp b/tools/ktap/samples/syscalls/errinfo.kp
new file mode 100644
index 0000000..5a0f7a6
--- /dev/null
+++ b/tools/ktap/samples/syscalls/errinfo.kp
@@ -0,0 +1,145 @@
+#!/usr/bin/env ktap
+
+#errdesc get from include/uapi/asm-generic/errno*.h
+var errdesc = {
+	[1] = "Operation not permitted",		#EPERM
+	[2] = "No such file or directory",		#ENOENT
+	[3] = "No such process",			#ESRCH
+	[4] = "Interrupted system call",		#EINRT
+	[5] = "I/O error",				#EIO
+	[6] = "No such device or address",		#ENXIO
+	[7] = "Argument list too long",			#E2BIG
+	[8] = "Exec format error",			#ENOEXEC
+	[9] = "Bad file number",			#EBADF
+	[10] = "No child processes",			#ECHILD
+	[11] = "Try again",				#EAGAIN
+	[12] = "Out of memory",				#ENOMEM
+	[13] = "Permission denied",			#EACCES
+	[14] = "Bad address",				#EFAULT
+	[15] = "Block device required",			#ENOTBLK
+	[16] = "Device or resource busy",		#EBUSY
+	[17] = "File exists",				#EEXIST
+	[18] = "Cross-device link",			#EXDEV
+	[19] = "No such device",			#ENODEV
+	[20] = "Not a directory",			#ENOTDIR
+	[21] = "Is a directory",			#EISDIR
+	[22] = "Invalid argument",			#EINVAL
+	[23] = "File table overflow",			#ENFILE
+	[24] = "Too many open files",			#EMFILE
+	[25] = "Not a typewriter",			#ENOTTY
+	[26] = "Text file busy",			#ETXTBSY
+	[27] = "File too large",			#EFBIG
+	[28] = "No space left on device",		#ENOSPC
+	[29] = "Illegal seek",				#ESPIPE
+	[30] = "Read-only file system",			#EROFS
+	[31] = "Too many links",			#EMLINK
+	[32] = "Broken pipe",				#EPIPE
+	[33] = "Math argument out of domain of func",	#EDOM
+	[34] = "Math result not representable",		#ERANGE
+
+	[35] = "Resource deadlock would occur",		#EDEADLK
+	[36] = "File name too long", 			#ENAMETOOLONG
+	[37] = "No record locks available",		#ENOLCK
+	[38] = "Function not implemented",		#ENOSYS
+	[39] = "Directory not empty",			#ENOTEMPTY		
+	[40] = "Too many symbolic links encountered",	#ELOOP
+	[42] = "No message of desired type",		#ENOMSG
+	[43] = "Identifier removed",			#EIDRM
+	[44] = "Channel number out of range",		#ECHRNG
+	[45] = "Level 2 not synchronized",		#EL2NSYNC
+	[46] = "Level 3 halted",			#EL3HLT
+	[47] = "Level 3 reset",				#EL3RST			
+	[48] = "Link number out of range",		#ELNRNG
+	[49] = "Protocol driver not attached",		#EUNATCH
+	[50] = "No CSI structure available",		#ENOCSI
+	[51] = "Level 2 halted",			#EL2HLT
+	[52] = "Invalid exchange",			#EBADE
+	[53] = "Invalid request descriptor",		#EBADR
+	[54] = "Exchange full",				#EXFULL
+	[55] = "No anode",				#ENOANO
+	[56] = "Invalid request code",			#EBADRQC
+	[57] = "Invalid slot",				#EBADSLT
+
+	[59] = "Bad font file format",			#EBFONT
+	[60] = "Device not a stream",			#ENOSTR
+	[61] = "No data available",			#ENODATA
+	[62] = "Timer expired",				#ETIME
+	[63] = "Out of streams resources",		#ENOSR
+	[64] = "Machine is not on the network",		#ENONET
+	[65] = "Package not installed",			#ENOPKG
+	[66] = "Object is remote",			#EREMOTE
+	[67] = "Link has been severed",			#ENOLINK
+	[68] = "Advertise error",			#EADV
+	[69] = "Srmount error",				#ESRMNT
+	[70] = "Communication error on send",		#ECOMM
+	[71] = "Protocol error",			#EPROTO
+	[72] = "Multihop attempted",			#EMULTIHOP
+	[73] = "RFS specific error",			#EDOTDOT
+	[74] = "Not a data message",			#EBADMSG
+	[75] = "Value too large for defined data type",	#EOVERFLOW
+	[76] = "Name not unique on network",		#ENOTUNIQ
+	[77] = "File descriptor in bad state",		#EBADFD
+	[78] = "Remote address changed",		#EREMCHG
+	[79] = "Can not access a needed shared library", #ELIBACC
+	[80] = "Accessing a corrupted shared library",	#ELIBBAD
+	[81] = ".lib section in a.out corrupted",	#ELIBSCN
+	[82] = "Attempting to link in too many shared libraries", #ELIBMAX
+	[83] = "Cannot exec a shared library directly",	#ELIBEXEC
+	[84] = "Illegal byte sequence",			#EILSEQ
+	[85] = "Interrupted system call should be restarted", #ERESTART
+	[86] = "Streams pipe error",			#ESTRPIPE
+	[87] = "Too many users",			#EUSERS
+	[88] = "Socket operation on non-socket",	#ENOTSOCK
+	[89] = "Destination address required",		#EDESTADDRREQ
+	[90] = "Message too long",			#EMSGSIZE
+	[91] = "Protocol wrong type for socket",	#EPROTOTYPE
+	[92] = "Protocol not available",		#ENOPROTOOPT
+	[93] = "Protocol not supported",		#EPROTONOSUPPORT
+	[94] = "Socket type not supported",		#ESOCKTNOSUPPORT
+	[95] = "Operation not supported on transport endpoint", #EOPNOTSUPP
+	[96] = "Protocol family not supported",		#EPFNOSUPPORT
+	[97] = "Address family not supported by protocol", #EAFNOSUPPORT
+	[98] = "Address already in use",		#EADDRINUSE
+	[99] = "Cannot assign requested address",	#EADDRNOTAVAIL
+	[100] = "Network is down",			#ENETDOWN
+	[101] = "Network is unreachable",		#ENETUNREACH
+	[102] = "Network dropped connection because of reset",	#ENETRESET
+	[103] = "Software caused connection abort",	#ECONNABORTED
+	[104] = "Connection reset by peer",		#ECONNRESET
+	[105] = "No buffer space available",		#ENOBUFS
+	[106] = "Transport endpoint is already connected", #EISCONN
+	[107] = "Transport endpoint is not connected",	#ENOTCONN
+	[108] = " Cannot send after transport endpoint shutdown", #ESHUTDOWN
+	[109] = "Too many references: cannot splice",	#ETOOMANYREFS
+	[110] = "Connection timed out",			#ETIMEDOUT
+	[111] = "Connection refused",			#ECONNREFUSED
+	[112] = "Host is down",				#EHOSTDOWN
+	[113] = "No route to host",			#EHOSTUNREACH
+	[114] = "Operation already in progress",	#EALREADY
+	[115] = "Operation now in progress",		#EINPROGRESS
+	[116] = "Stale NFS file handle",		#ESTALE
+	[117] = "Structure needs cleaning",		#EUCLEAN
+	[118] = "Not a XENIX named type file",		#ENOTNAM
+	[119] = "No XENIX semaphores available",	#ENAVAIL
+	[120] = "Is a named type file",			#EISNAM
+	[121] = "Remote I/O error",			#EREMOTEIO
+	[122] = "Quota exceeded",			#EDQUOT
+	[123] = "No medium found",			#ENOMEDIUM
+	[124] = "Wrong medium type",			#EMEDIUMTYPE
+	[125] = "Operation Canceled",			#ECANCELED
+	[126] = "Required key not available",		#ENOKEY
+	[127] = "Key has expired",			#EKEYEXPIRED
+	[128] = "Key has been revoked",			#EKEYREVOKED
+	[129] = "Key was rejected by service",		#EKEYREJECTED
+	[130] = "Owner died",				#EOWNERDEAD
+	[131] = "State not recoverable",		#ENOTRECOVERABLE
+
+}
+
+trace syscalls:sys_exit_* {
+	if (arg1 < 0) {
+		var errno = -arg1
+		printf("%-15s%-20s\t%d\t%-30s\n",
+			execname, probename, errno, errdesc[errno])
+	}
+}
diff --git a/tools/ktap/samples/syscalls/execve.kp b/tools/ktap/samples/syscalls/execve.kp
new file mode 100644
index 0000000..8b4115e
--- /dev/null
+++ b/tools/ktap/samples/syscalls/execve.kp
@@ -0,0 +1,9 @@
+#!/usr/bin/env ktap
+
+#This script trace filename of process execution
+#only tested in x86-64
+
+trace probe:do_execve filename=%di {
+	printf("[do_execve entry]: (%s) name=%s\n", execname,
+						    kernel_string(arg1))
+}
diff --git a/tools/ktap/samples/syscalls/opensnoop.kp b/tools/ktap/samples/syscalls/opensnoop.kp
new file mode 100644
index 0000000..5e561b2
--- /dev/null
+++ b/tools/ktap/samples/syscalls/opensnoop.kp
@@ -0,0 +1,31 @@
+#!/usr/local/bin/ktap -q
+#
+# opensnoop.kp	trace open syscalls with pathnames and basic info
+#
+# 23-Nov-2013	Brendan Gregg	Created this
+
+var path = {}
+
+printf("%5s %6s %-12s %3s %3s %s\n", "UID", "PID", "COMM", "FD", "ERR", "PATH");
+
+trace syscalls:sys_enter_open {
+	path[tid] = user_string(arg1)
+}
+
+trace syscalls:sys_exit_open {
+	var fd
+	var errno
+
+	if (arg1 < 0) {
+		fd = 0
+		errno = -arg1
+	} else {
+		fd = arg1
+		errno = 0
+	}
+
+	printf("%5d %6d %-12s %3d %3d %s\n", uid, pid, execname, fd,
+	    errno, path[tid])
+
+	path[tid] = 0
+}
diff --git a/tools/ktap/samples/syscalls/sctop.kp b/tools/ktap/samples/syscalls/sctop.kp
new file mode 100644
index 0000000..bd33d21
--- /dev/null
+++ b/tools/ktap/samples/syscalls/sctop.kp
@@ -0,0 +1,13 @@
+#! /usr/bin/env ktap
+
+var s = {}
+
+trace syscalls:sys_enter_* {
+	s[probename] += 1
+}
+
+tick-5s {
+	ansi.clear_screen()
+	print_hist(s)
+	delete(s)
+}
diff --git a/tools/ktap/samples/syscalls/syscalls.kp b/tools/ktap/samples/syscalls/syscalls.kp
new file mode 100644
index 0000000..4eb332a
--- /dev/null
+++ b/tools/ktap/samples/syscalls/syscalls.kp
@@ -0,0 +1,6 @@
+#!/usr/bin/env ktap
+
+trace syscalls:* {
+	print(cpu, pid, execname, argstr)
+}
+
diff --git a/tools/ktap/samples/syscalls/syscalls_count.kp b/tools/ktap/samples/syscalls/syscalls_count.kp
new file mode 100644
index 0000000..a355eef
--- /dev/null
+++ b/tools/ktap/samples/syscalls/syscalls_count.kp
@@ -0,0 +1,54 @@
+#!/usr/bin/env ktap
+
+var s = {}
+
+trace syscalls:sys_enter_* {
+	s[probename] += 1
+}
+
+trace_end {
+	print_hist(s)
+}
+
+#Result:
+#
+#[root@jovi ktap]# ./ktap samples/syscalls_count.kp
+#^C
+#                          value ------------- Distribution ------------- count
+#        sys_enter_rt_sigprocmask |@@@@@@                                 326
+#                  sys_enter_read |@@@@@                                  287
+#                 sys_enter_close |@@@@                                   236
+#                  sys_enter_open |@@@@                                   222
+#                sys_enter_stat64 |@@                                     132
+#                sys_enter_select |@@                                     123
+#          sys_enter_rt_sigaction |@@                                     107
+#                  sys_enter_poll |@                                      72
+#                 sys_enter_write |@                                      70
+#            sys_enter_mmap_pgoff |@                                      58
+#               sys_enter_fstat64 |                                       41
+#             sys_enter_nanosleep |                                       23
+#                sys_enter_access |                                       20
+#              sys_enter_mprotect |                                       18
+#               sys_enter_geteuid |                                       17
+#               sys_enter_getegid |                                       16
+#                sys_enter_getuid |                                       16
+#                sys_enter_getgid |                                       16
+#                   sys_enter_brk |                                       15
+#               sys_enter_waitpid |                                       11
+#                  sys_enter_time |                                       10
+#                 sys_enter_ioctl |                                       9
+#                sys_enter_munmap |                                       9
+#               sys_enter_fcntl64 |                                       7
+#                  sys_enter_dup2 |                                       7
+#                 sys_enter_clone |                                       6
+#            sys_enter_exit_group |                                       6
+#                sys_enter_execve |                                       4
+#                  sys_enter_pipe |                                       3
+#          sys_enter_gettimeofday |                                       3
+#              sys_enter_getdents |                                       2
+#             sys_enter_getgroups |                                       2
+#              sys_enter_statfs64 |                                       2
+#                 sys_enter_lseek |                                       2
+#                sys_enter_openat |                                       1
+#              sys_enter_newuname |                                       1
+
diff --git a/tools/ktap/samples/syscalls/syscalls_count_by_proc.kp b/tools/ktap/samples/syscalls/syscalls_count_by_proc.kp
new file mode 100644
index 0000000..fdd0eff
--- /dev/null
+++ b/tools/ktap/samples/syscalls/syscalls_count_by_proc.kp
@@ -0,0 +1,22 @@
+#!/usr/bin/env ktap
+
+var s = {}
+
+trace syscalls:sys_enter_* {
+	s[execname] += 1
+}
+
+trace_end {
+	print_hist(s)
+}
+
+#Result:
+#
+#[root@jovi ktap]# ./ktap samples/syscalls_count_by_proc.kp
+#^C
+#                          value ------------- Distribution ------------- count
+#                            sshd |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      196
+#                          iscsid |@@@@                                   24
+#                        sendmail |@                                      9
+
+
diff --git a/tools/ktap/samples/syscalls/syslatl.kp b/tools/ktap/samples/syscalls/syslatl.kp
new file mode 100644
index 0000000..e9cd91d
--- /dev/null
+++ b/tools/ktap/samples/syscalls/syslatl.kp
@@ -0,0 +1,33 @@
+#!/usr/bin/env ktap
+#
+# syslatl.kp	syscall latency linear aggregation
+#
+# 10-Nov-2013	Brendan Gregg	Created this
+
+var step = 10	# number of ms per step
+
+var self = {}
+var lats = {}
+var max = 0
+
+trace syscalls:sys_enter_* {
+	self[tid] = gettimeofday_us()
+}
+
+trace syscalls:sys_exit_* {
+	if (self[tid] == nil) { return }
+	var delta = (gettimeofday_us() - self[tid]) / (step * 1000)
+	if (delta > max) { max = delta }
+	lats[delta] += 1
+	self[tid] = nil
+}
+
+trace_end {
+	printf("   %8s %8s\n", "LAT(ms)+", "COUNT");
+	for (i = 0, max, 1) {
+		if (lats[i] == nil) {
+			lats[i] = 0
+		}
+		printf("   %8d %8d\n", i * step, lats[i]);
+	}
+}
diff --git a/tools/ktap/samples/syscalls/syslist.kp b/tools/ktap/samples/syscalls/syslist.kp
new file mode 100644
index 0000000..09f173d
--- /dev/null
+++ b/tools/ktap/samples/syscalls/syslist.kp
@@ -0,0 +1,31 @@
+#!/usr/bin/env ktap
+#
+# syslist.kp    syscall latency as a list with counts
+#
+# 10-Nov-2013   Brendan Gregg   Created this
+
+var self = {}
+var lats = {}
+var order = {}  # a workaround for key sorting
+
+trace syscalls:sys_enter_* {
+	self[tid] = gettimeofday_us()
+}
+
+trace syscalls:sys_exit_* {
+	if (self[tid] == nil) { return }
+	var delta = gettimeofday_us() - self[tid]
+	lats[delta] += 1
+	order[delta] = delta
+	self[tid] = nil
+}
+
+trace_end {
+	printf("   %8s %8s\n", "LAT(us)", "COUNT");
+	#TODO: use a more simple way to sort keys
+
+	#for (lat, dummy in sort_pairs(order, cmp)) {
+	#    printf("   %8d %8d\n", lat, lats[lat]);
+	#}
+	print_hist(lats)
+}
diff --git a/tools/ktap/samples/tracepoints/eventcount.kp b/tools/ktap/samples/tracepoints/eventcount.kp
new file mode 100644
index 0000000..a9e197b
--- /dev/null
+++ b/tools/ktap/samples/tracepoints/eventcount.kp
@@ -0,0 +1,210 @@
+#!/usr/bin/env ktap
+
+# showing all tracepoints in histogram style
+
+var s = {}
+
+trace *:* {
+	s[probename] += 1
+}
+
+trace_end {
+	print_hist(s)
+}
+
+#Results:
+#^C
+#
+#                          value ------------- Distribution ------------- count
+#                 rcu_utilization |@@@@@                                  225289
+#                        cpu_idle |@@@                                    120168
+#                    sched_wakeup |@@                                     91950
+#                    timer_cancel |@@                                     91232
+#                     timer_start |@@                                     91201
+#                sched_stat_sleep |@@                                     90981
+#               timer_expire_exit |@@                                     90634
+#              timer_expire_entry |@@                                     90625
+#                  hrtimer_cancel |@                                      75411
+#                   hrtimer_start |@                                      74946
+#                   softirq_raise |@                                      63117
+#                    softirq_exit |@                                      63109
+#                   softirq_entry |@                                      63094
+#                    sched_switch |@                                      62331
+#                 sched_stat_wait |@                                      60491
+#             hrtimer_expire_exit |@                                      47538
+#            hrtimer_expire_entry |@                                      47530
+#              sched_stat_runtime |                                       2780
+#                 kmem_cache_free |                                       2684
+#                kmem_cache_alloc |                                       2415
+#                           kfree |                                       2288
+#                        sys_exit |                                       2145
+#                       sys_enter |                                       2145
+#         sys_exit_rt_sigprocmask |                                       1000
+#        sys_enter_rt_sigprocmask |                                       1000
+#                      timer_init |                                       912
+#              sched_stat_blocked |                                       685
+#                         kmalloc |                                       667
+#           workqueue_execute_end |                                       621
+#         workqueue_execute_start |                                       621
+#                sys_enter_select |                                       566
+#                 sys_exit_select |                                       566
+#                  sys_enter_read |                                       526
+#                   sys_exit_read |                                       526
+#                    mm_page_free |                                       478
+#                   mm_page_alloc |                                       427
+#            mm_page_free_batched |                                       382
+#                   net_dev_queue |                                       296
+#                    net_dev_xmit |                                       296
+#                     consume_skb |                                       296
+#                  sys_exit_write |                                       290
+#                 sys_enter_write |                                       290
+#                       kfree_skb |                                       289
+#           kmem_cache_alloc_node |                                       269
+#                    kmalloc_node |                                       263
+#                 sys_enter_close |                                       249
+#                  sys_exit_close |                                       249
+#                    hrtimer_init |                                       248
+#               netif_receive_skb |                                       242
+#                  sys_enter_open |                                       237
+#                   sys_exit_open |                                       237
+#                       napi_poll |                                       226
+#              sched_migrate_task |                                       207
+#                   sys_exit_poll |                                       173
+#                  sys_enter_poll |                                       173
+#            workqueue_queue_work |                                       152
+#         workqueue_activate_work |                                       152
+#                sys_enter_stat64 |                                       133
+#                 sys_exit_stat64 |                                       133
+#           sys_exit_rt_sigaction |                                       133
+#          sys_enter_rt_sigaction |                                       133
+#               irq_handler_entry |                                       125
+#                irq_handler_exit |                                       125
+#       mm_page_alloc_zone_locked |                                       99
+#             sys_exit_mmap_pgoff |                                       66
+#            sys_enter_mmap_pgoff |                                       66
+#                sys_exit_fstat64 |                                       54
+#               sys_enter_fstat64 |                                       54
+#             sys_enter_nanosleep |                                       51
+#              sys_exit_nanosleep |                                       51
+#                 block_bio_queue |                                       46
+#                 block_bio_remap |                                       46
+#              block_bio_complete |                                       46
+#                  mix_pool_bytes |                                       44
+#              mm_page_pcpu_drain |                                       31
+#                   sys_exit_time |                                       23
+#                  sys_enter_time |                                       23
+#                 sys_exit_access |                                       20
+#                sys_enter_access |                                       20
+#           mix_pool_bytes_nolock |                                       18
+#              sys_enter_mprotect |                                       18
+#               sys_exit_mprotect |                                       18
+#               sys_enter_geteuid |                                       17
+#                sys_exit_geteuid |                                       17
+#                sys_enter_munmap |                                       17
+#                 sys_exit_munmap |                                       17
+#                     block_getrq |                                       16
+#                sys_enter_getuid |                                       16
+#                sys_enter_getgid |                                       16
+#                 sys_exit_getgid |                                       16
+#                 sys_exit_getuid |                                       16
+#                  block_rq_issue |                                       16
+#         scsi_dispatch_cmd_start |                                       16
+#               block_rq_complete |                                       16
+#          scsi_dispatch_cmd_done |                                       16
+#               sys_enter_getegid |                                       16
+#                sys_exit_getegid |                                       16
+#                 block_rq_insert |                                       16
+#         skb_copy_datagram_iovec |                                       15
+#                   sys_enter_brk |                                       15
+#                    sys_exit_brk |                                       15
+#             credit_entropy_bits |                                       14
+#                   wbc_writepage |                                       14
+#                  sys_exit_clone |                                       12
+#              block_touch_buffer |                                       12
+#              sched_process_wait |                                       11
+#               sys_enter_waitpid |                                       11
+#                sys_exit_waitpid |                                       11
+#               writeback_written |                                       10
+#                 writeback_start |                                       10
+#              writeback_queue_io |                                       10
+#     ext4_es_lookup_extent_enter |                                       9
+#                 sys_enter_ioctl |                                       9
+#                  sys_exit_ioctl |                                       9
+#       ext4_ext_map_blocks_enter |                                       9
+#        ext4_ext_map_blocks_exit |                                       9
+#      ext4_es_lookup_extent_exit |                                       9
+#           ext4_es_insert_extent |                                       9
+#            ext4_ext_show_extent |                                       8
+#                 extract_entropy |                                       8
+#ext4_es_find_delayed_extent_exit |                                       8
+# ext4_es_find_delayed_extent_... |                                       8
+#         writeback_pages_written |                                       7
+#                   sys_exit_dup2 |                                       7
+#                  sys_enter_dup2 |                                       7
+#                 signal_generate |                                       7
+#               sys_enter_fcntl64 |                                       7
+#                sys_exit_fcntl64 |                                       7
+#              global_dirty_state |                                       7
+#     writeback_dirty_inode_start |                                       7
+#             block_bio_backmerge |                                       7
+#           writeback_dirty_inode |                                       7
+#                sched_wakeup_new |                                       6
+#              sched_process_free |                                       6
+#            sys_enter_exit_group |                                       6
+#                    task_newtask |                                       6
+#                 sys_enter_clone |                                       6
+#              sched_process_fork |                                       6
+#              sched_process_exit |                                       6
+#           sys_exit_gettimeofday |                                       5
+#                  signal_deliver |                                       5
+#          sys_enter_gettimeofday |                                       5
+#          writeback_single_inode |                                       4
+#                sys_enter_execve |                                       4
+#                     task_rename |                                       4
+#              sched_process_exec |                                       4
+#              block_dirty_buffer |                                       4
+#                 sys_exit_execve |                                       4
+#                    block_unplug |                                       4
+#               sched_stat_iowait |                                       4
+#    writeback_single_inode_start |                                       4
+#                      block_plug |                                       4
+#           writeback_write_inode |                                       3
+#                  sys_enter_pipe |                                       3
+#            writeback_dirty_page |                                       3
+#     writeback_write_inode_start |                                       3
+#           ext4_mark_inode_dirty |                                       3
+#              ext4_journal_start |                                       3
+#                   sys_exit_pipe |                                       3
+#           jbd2_drop_transaction |                                       2
+#             jbd2_commit_locking |                                       2
+#            jbd2_commit_flushing |                                       2
+#               jbd2_handle_start |                                       2
+#                  jbd2_run_stats |                                       2
+#               sys_exit_getdents |                                       2
+#           jbd2_checkpoint_stats |                                       2
+#             sys_enter_getgroups |                                       2
+#               jbd2_start_commit |                                       2
+#                 jbd2_end_commit |                                       2
+#              ext4_da_writepages |                                       2
+#               jbd2_handle_stats |                                       2
+#              sys_enter_statfs64 |                                       2
+#               sys_exit_statfs64 |                                       2
+#              sys_exit_getgroups |                                       2
+#                  sys_exit_lseek |                                       2
+#                 sys_enter_lseek |                                       2
+#              sys_enter_getdents |                                       2
+#             ext4_da_write_pages |                                       2
+#             jbd2_commit_logging |                                       2
+#             ext4_request_blocks |                                       1
+#                 sys_exit_openat |                                       1
+#     ext4_discard_preallocations |                                       1
+#              ext4_mballoc_alloc |                                       1
+#                sys_enter_openat |                                       1
+#       ext4_da_writepages_result |                                       1
+#            ext4_allocate_blocks |                                       1
+#              sys_enter_newuname |                                       1
+#    ext4_da_update_reserve_space |                                       1
+# ext4_get_reserved_cluster_alloc |                                       1
+#               sys_exit_newuname |                                       1
+#           writeback_wake_thread |                                       1
+
diff --git a/tools/ktap/samples/tracepoints/eventcount_by_proc.kp b/tools/ktap/samples/tracepoints/eventcount_by_proc.kp
new file mode 100644
index 0000000..1b95f19
--- /dev/null
+++ b/tools/ktap/samples/tracepoints/eventcount_by_proc.kp
@@ -0,0 +1,57 @@
+#!/usr/bin/env ktap
+
+# showing all tracepoints in histogram style
+
+var s = {}
+
+trace *:* {
+	s[execname] += 1
+}
+
+trace_end {
+	print_hist(s)
+}
+
+#Results:
+#^C
+#                          value ------------- Distribution ------------- count
+#                       swapper/0 |@@@@@@@@@@@@                           354378
+#                       swapper/1 |@@@@@@@@@@                             284984
+#                              ps |@@@@                                   115697
+#                        ksmtuned |@@@                                    95857
+#                          iscsid |@@                                     80008
+#                             awk |@                                      30354
+#                      irqbalance |                                       16530
+#                       rcu_sched |                                       15892
+#                        sendmail |                                       14463
+#                     kworker/0:1 |                                       10540
+#                    kworker/u4:2 |                                       9250
+#                     kworker/1:2 |                                       7943
+#                           sleep |                                       7555
+#                           crond |                                       3911
+#                     ksoftirqd/0 |                                       3817
+#                            sshd |                                       2849
+#                 systemd-journal |                                       2209
+#                     migration/1 |                                       1601
+#                     migration/0 |                                       1350
+#                        dhclient |                                       1343
+#                 nm-dhcp-client. |                                       1208
+#                     ksoftirqd/1 |                                       1064
+#                      watchdog/1 |                                       966
+#                      watchdog/0 |                                       964
+#                      khugepaged |                                       776
+#                     dbus-daemon |                                       611
+#                         rpcbind |                                       607
+#                           gdbus |                                       529
+#                  NetworkManager |                                       399
+#                     jbd2/dm-1-8 |                                       378
+#                   modem-manager |                                       184
+#                  abrt-watch-log |                                       157
+#                         polkitd |                                       156
+#                   rs:main Q:Reg |                                       153
+#                    avahi-daemon |                                       151
+#                        rsyslogd |                                       102
+#                         systemd |                                       96
+#                    kworker/0:1H |                                       45
+#                          smartd |                                       30
+
diff --git a/tools/ktap/samples/tracepoints/raw_tracepoint.kp b/tools/ktap/samples/tracepoints/raw_tracepoint.kp
new file mode 100644
index 0000000..cffda45
--- /dev/null
+++ b/tools/ktap/samples/tracepoints/raw_tracepoint.kp
@@ -0,0 +1,15 @@
+#!/usr/bin/env ktap
+
+#This script use kdebug.tracepoint, not 'trace' keyword which use perf backend.
+#
+#The overhead of kdebug.tracepoint would be much little than normal perf
+#backend tracing.
+
+kdebug.tracepoint("sys_enter_open", function () {
+	printf("sys_enter_open: (%s) open file (%s)\n",
+		execname,  user_string(arg1))
+})
+
+kdebug.tracepoint("sys_exit_open", function () {
+	printf("sys_exit_open: return fd: (%d)\n", arg1)
+})
diff --git a/tools/ktap/samples/tracepoints/tracepoints.kp b/tools/ktap/samples/tracepoints/tracepoints.kp
new file mode 100644
index 0000000..3ff29b5
--- /dev/null
+++ b/tools/ktap/samples/tracepoints/tracepoints.kp
@@ -0,0 +1,6 @@
+#!/usr/bin/env ktap
+
+trace *:* {
+	print(cpu, pid, execname, argstr)
+}
+
diff --git a/tools/ktap/samples/userspace/gcc_unwind.kp b/tools/ktap/samples/userspace/gcc_unwind.kp
new file mode 100644
index 0000000..48db46e
--- /dev/null
+++ b/tools/ktap/samples/userspace/gcc_unwind.kp
@@ -0,0 +1,9 @@
+#!/usr/bin/env ktap
+
+#only tested in x86-64 system,
+#if you run this script in x86_32, change the libc path.
+
+trace sdt:/lib/x86_64-linux-gnu/libgcc_s.so.1:unwind {
+	print(execname, argstr)
+}
+
diff --git a/tools/ktap/samples/userspace/glibc_func_hist.kp b/tools/ktap/samples/userspace/glibc_func_hist.kp
new file mode 100644
index 0000000..bb3dd9f
--- /dev/null
+++ b/tools/ktap/samples/userspace/glibc_func_hist.kp
@@ -0,0 +1,44 @@
+#!/usr/bin/env ktap
+
+#This ktap script trace all glibc functions in histogram output
+
+#only tested in x86-64 system,
+#if you run this script in x86_32, change the libc path.
+
+var s = {}
+
+trace probe:/lib64/libc.so.6:* {
+	s[probename] += 1
+}
+
+trace_end {
+	print_hist(s)
+}
+
+# Example result:
+#[root@localhost ktap]# ./ktap ./glibc_func_hist.kp
+#Tracing... Ctrl-C to end.
+#^C
+#                          value ------------- Distribution ------------- count
+#                   _IO_sputbackc |                                       1536
+#                  __strncmp_sse2 |                                       1522
+#                    __GI_strncmp |                                       1522
+#                     __GI_memcpy |                                       1446
+#                   __memcpy_sse2 |                                       1446
+#        _dl_mcount_wrapper_check |                                       1433
+#   __GI__dl_mcount_wrapper_check |                                       1433
+# __gconv_transform_utf8_internal |                                       1429
+#                       __mbrtowc |                                       1425
+#                        mbrtoc32 |                                       1425
+#                  __GI___mbrtowc |                                       1425
+#                         mbrtowc |                                       1425
+#                    __GI_mbrtowc |                                       1425
+#                         strtouq |                                       1274
+#                        strtoull |                                       1274
+#                         strtoul |                                       1274
+#          __ctype_get_mb_cur_max |                                       984
+#         ____strtoull_l_internal |                                       970
+#     __GI_____strtoul_l_internal |                                       970
+#              __GI__IO_sputbackc |                                       960
+#                             ... |
+
diff --git a/tools/ktap/samples/userspace/glibc_sdt.kp b/tools/ktap/samples/userspace/glibc_sdt.kp
new file mode 100644
index 0000000..e396901
--- /dev/null
+++ b/tools/ktap/samples/userspace/glibc_sdt.kp
@@ -0,0 +1,11 @@
+#!/usr/bin/env ktap
+
+#This ktap script trace all sdt notes in glibc
+
+#only tested in x86-64 system,
+#if you run this script in x86_32, change the libc path.
+
+trace sdt:/lib64/libc.so.6:* {
+	print(execname, argstr)
+}
+
diff --git a/tools/ktap/samples/userspace/glibc_trace.kp b/tools/ktap/samples/userspace/glibc_trace.kp
new file mode 100644
index 0000000..9b8d16e
--- /dev/null
+++ b/tools/ktap/samples/userspace/glibc_trace.kp
@@ -0,0 +1,11 @@
+#!/usr/bin/env ktap
+
+#This ktap script trace all functions in glibc
+
+#only tested in x86-64 system,
+#if you run this script in x86_32, change the libc path.
+
+trace probe:/lib64/libc.so.6:* {
+	print(execname, argstr)
+}
+
diff --git a/tools/ktap/samples/userspace/malloc_free.kp b/tools/ktap/samples/userspace/malloc_free.kp
new file mode 100644
index 0000000..884d99a
--- /dev/null
+++ b/tools/ktap/samples/userspace/malloc_free.kp
@@ -0,0 +1,20 @@
+#!/usr/bin/env ktap
+
+#only tested in x86-64 system,
+#if you run this script in x86_32, change the libc path.
+
+trace probe:/lib64/libc.so.6:malloc {
+	print("malloc entry:", execname)
+}
+
+trace probe:/lib64/libc.so.6:malloc%return {
+	print("malloc exit:", execname)
+}
+
+trace probe:/lib64/libc.so.6:free {
+	print("free entry:", execname)
+}
+
+trace probe:/lib64/libc.so.6:free%return {
+	print("free exit:", execname)
+}
diff --git a/tools/ktap/samples/userspace/malloc_size_hist.kp b/tools/ktap/samples/userspace/malloc_size_hist.kp
new file mode 100644
index 0000000..41bd202
--- /dev/null
+++ b/tools/ktap/samples/userspace/malloc_size_hist.kp
@@ -0,0 +1,22 @@
+#!/usr/bin/env ktap
+
+# Aggregate system or process malloc size
+
+# only tested in x86-64 system,
+# if you run this script in x86_32, change the libc path and register name.
+#
+# Examples:
+#
+# ktap malloc_size_hist.kp
+# ktap malloc_size_hist.kp -- ls
+
+var s = {}
+
+trace probe:/lib64/libc.so.6:malloc size=%di {
+	#arg2 is argument "size" of malloc function
+	s[arg1] += 1
+}
+
+trace_end {
+	print_hist(s)
+}
diff --git a/tools/ktap/samples/userspace/pthread.kp b/tools/ktap/samples/userspace/pthread.kp
new file mode 100644
index 0000000..be693ac
--- /dev/null
+++ b/tools/ktap/samples/userspace/pthread.kp
@@ -0,0 +1,8 @@
+#!/usr/bin/env ktap
+
+# This script trace pthread_mutex* related call in libpthread
+# Tested in x86_64
+
+trace probe:/lib64/libpthread-2.17.so:pthread_mutex_* {
+	print(execname, argstr)
+}
-- 
2.0.2

