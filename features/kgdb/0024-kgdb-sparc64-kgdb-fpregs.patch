From 7855465ac9d2f5431fabdfedbd701878f05a2aa0 Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Thu, 12 Feb 2009 21:45:58 -0500
Subject: [PATCH] kgdb: sparc64 kgdb fpregs

Gdb saves total of 86 registers in which the first 32 floating
point registers are 4bytes and the rest are 8bytes. So total
of 560bytes * 2 = 1120 bytes is expected for 'g' packet
(in gdb RSP packet, it needs 2 charater to send 1 bytes).

While kernel SPARC kgdb also saves total of 86 registers which
all have 8bytes. This mean kgdb will send 'g' packet of size
86*8byte * 2 = 1376 bytes. This is why we got error:
"Remote 'g' packet reply is too long"

The sparcv9 has 32 floating point register of size 4bytes and
16 overlapping 8-byte floating point register pairs. So we
need to change the size of the first 32 floating point registers
in the kernel SPARC kgdb from 8bytes to 4bytes.

The gdb_regs variable in kernel/kgdb.c is basicaly a buffer holding
all the values of these 86 registers. So the patch first recompute
NUMREGBYTES which is the buffer size of gdb_regs to have less
4*32=128btyes than original. To be easy to fill in and to read
registers value in gdb_regs, the patch has new struct gdb_regs_sparc64
which acts as template of how gdb_regs layout. The patch then just
cast the raw buffer into struct gdb_regs_sparc64 and read/write
with it in sparc64/kernel/kgdb.c. No major changes in this file.

Signed-off-by: Vu Tran <vu.tran@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 arch/sparc/include/asm/kgdb.h |   16 +++++++-
 arch/sparc64/kernel/kgdb.c    |   85 ++++++++++++++++++++++-------------------
 2 files changed, 61 insertions(+), 40 deletions(-)

diff --git a/arch/sparc/include/asm/kgdb.h b/arch/sparc/include/asm/kgdb.h
index b6ef301..2e665c4 100644
--- a/arch/sparc/include/asm/kgdb.h
+++ b/arch/sparc/include/asm/kgdb.h
@@ -27,7 +27,21 @@ enum regnames {
 #ifdef CONFIG_SPARC32
 #define NUMREGBYTES		((GDB_CSR + 1) * 4)
 #else
-#define NUMREGBYTES		((GDB_Y + 1) * 8)
+#define NUMREGBYTES		((GDB_Y + 1) * 8 - (GDB_F32 - GDB_F0) * 4)
+#define NUM32BITFPREQS  (GDB_F32 - GDB_F0)
+#define NUM64BITFPREQS  (GDB_F62 - GDB_F32 + 1)
+
+struct gdb_regs_sparc64 {
+	unsigned long gdb_regs_u[GDB_I7 - GDB_G0 + 1];
+	unsigned int gdb_regs_32bit_fpr[NUM32BITFPREQS];
+	unsigned long gdb_regs_64bit_fpr[NUM64BITFPREQS];
+	unsigned long gdb_reg_pc;
+	unsigned long gdb_reg_npc;
+	unsigned long gdb_reg_state;
+	unsigned long gdb_reg_frs;
+	unsigned long gdb_reg_fprs;
+	unsigned long gdb_reg_y;
+};
 #endif
 
 extern void arch_kgdb_breakpoint(void);
diff --git a/arch/sparc64/kernel/kgdb.c b/arch/sparc64/kernel/kgdb.c
index fefbe6d..5671b2a 100644
--- a/arch/sparc64/kernel/kgdb.c
+++ b/arch/sparc64/kernel/kgdb.c
@@ -10,34 +10,39 @@
 #include <asm/ptrace.h>
 #include <asm/irq.h>
 
+
 void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)
 {
+	struct gdb_regs_sparc64 * gdb_regs_sparc64 = (struct gdb_regs_sparc64 *)gdb_regs;
 	struct reg_window *win;
 	int i;
 
-	gdb_regs[GDB_G0] = 0;
+	gdb_regs_sparc64->gdb_regs_u[GDB_G0] = 0;
 	for (i = 0; i < 15; i++)
-		gdb_regs[GDB_G1 + i] = regs->u_regs[UREG_G1 + i];
+		gdb_regs_sparc64->gdb_regs_u[GDB_G1 + i] = regs->u_regs[UREG_G1 + i];
 
 	win = (struct reg_window *) (regs->u_regs[UREG_FP] + STACK_BIAS);
 	for (i = 0; i < 8; i++)
-		gdb_regs[GDB_L0 + i] = win->locals[i];
+		gdb_regs_sparc64->gdb_regs_u[GDB_L0 + i] = win->locals[i];
 	for (i = 0; i < 8; i++)
-		gdb_regs[GDB_I0 + i] = win->ins[i];
-
-	for (i = GDB_F0; i <= GDB_F62; i++)
-		gdb_regs[i] = 0;
-
-	gdb_regs[GDB_PC] = regs->tpc;
-	gdb_regs[GDB_NPC] = regs->tnpc;
-	gdb_regs[GDB_STATE] = regs->tstate;
-	gdb_regs[GDB_FSR] = 0;
-	gdb_regs[GDB_FPRS] = 0;
-	gdb_regs[GDB_Y] = regs->y;
+		gdb_regs_sparc64->gdb_regs_u[GDB_I0 + i] = win->ins[i];
+
+	for (i = 0; i <= NUM32BITFPREQS; i++)
+		gdb_regs_sparc64->gdb_regs_32bit_fpr[i] = 0;
+	for (i = 0; i <= NUM64BITFPREQS; i++)
+		gdb_regs_sparc64->gdb_regs_64bit_fpr[i] = 0;
+
+	gdb_regs_sparc64->gdb_reg_pc = regs->tpc;
+	gdb_regs_sparc64->gdb_reg_npc = regs->tnpc;
+	gdb_regs_sparc64->gdb_reg_state = regs->tstate;
+	gdb_regs_sparc64->gdb_reg_frs = 0;
+	gdb_regs_sparc64->gdb_reg_fprs = 0;
+	gdb_regs_sparc64->gdb_reg_y = regs->y;
 }
 
 void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
 {
+	struct gdb_regs_sparc64 * gdb_regs_sparc64 = (struct gdb_regs_sparc64 *)gdb_regs;
 	struct thread_info *t = task_thread_info(p);
 	extern unsigned int switch_to_pc;
 	extern unsigned int ret_from_syscall;
@@ -46,65 +51,67 @@ void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
 	int i;
 
 	for (i = GDB_G0; i < GDB_G6; i++)
-		gdb_regs[i] = 0;
-	gdb_regs[GDB_G6] = (unsigned long) t;
-	gdb_regs[GDB_G7] = (unsigned long) p;
+		gdb_regs_sparc64->gdb_regs_u[i] = 0;
+	gdb_regs_sparc64->gdb_regs_u[GDB_G6] = (unsigned long) t;
+	gdb_regs_sparc64->gdb_regs_u[GDB_G7] = (unsigned long) p;
 	for (i = GDB_O0; i < GDB_SP; i++)
-		gdb_regs[i] = 0;
-	gdb_regs[GDB_SP] = t->ksp;
-	gdb_regs[GDB_O7] = 0;
+		gdb_regs_sparc64->gdb_regs_u[i] = 0;
+	gdb_regs_sparc64->gdb_regs_u[GDB_SP] = t->ksp;
+	gdb_regs_sparc64->gdb_regs_u[GDB_O7] = 0;
 
 	win = (struct reg_window *) (t->ksp + STACK_BIAS);
 	for (i = 0; i < 8; i++)
-		gdb_regs[GDB_L0 + i] = win->locals[i];
+		gdb_regs_sparc64->gdb_regs_u[GDB_L0 + i] = win->locals[i];
 	for (i = 0; i < 8; i++)
-		gdb_regs[GDB_I0 + i] = win->ins[i];
+		gdb_regs_sparc64->gdb_regs_u[GDB_I0 + i] = win->ins[i];
 
-	for (i = GDB_F0; i <= GDB_F62; i++)
-		gdb_regs[i] = 0;
+	for (i = 0; i <= NUM32BITFPREQS; i++)
+		gdb_regs_sparc64->gdb_regs_32bit_fpr[i] = 0;
+	for (i = 0; i <= NUM64BITFPREQS; i++)
+		gdb_regs_sparc64->gdb_regs_64bit_fpr[i] = 0;
 
 	if (t->new_child)
 		pc = (unsigned long) &ret_from_syscall;
 	else
 		pc = (unsigned long) &switch_to_pc;
 
-	gdb_regs[GDB_PC] = pc;
-	gdb_regs[GDB_NPC] = pc + 4;
+	gdb_regs_sparc64->gdb_reg_pc = pc;
+	gdb_regs_sparc64->gdb_reg_npc = pc + 4;
 
 	cwp = __thread_flag_byte_ptr(t)[TI_FLAG_BYTE_CWP];
 
-	gdb_regs[GDB_STATE] = (TSTATE_PRIV | TSTATE_IE | cwp);
-	gdb_regs[GDB_FSR] = 0;
-	gdb_regs[GDB_FPRS] = 0;
-	gdb_regs[GDB_Y] = 0;
+	gdb_regs_sparc64->gdb_reg_state = (TSTATE_PRIV | TSTATE_IE | cwp);
+	gdb_regs_sparc64->gdb_reg_frs = 0;
+	gdb_regs_sparc64->gdb_reg_fprs = 0;
+	gdb_regs_sparc64->gdb_reg_y = 0;
 }
 
 void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)
 {
+	struct gdb_regs_sparc64 * gdb_regs_sparc64 = (struct gdb_regs_sparc64 *)gdb_regs;
 	struct reg_window *win;
 	int i;
 
 	for (i = 0; i < 15; i++)
-		regs->u_regs[UREG_G1 + i] = gdb_regs[GDB_G1 + i];
+		regs->u_regs[UREG_G1 + i] = gdb_regs_sparc64->gdb_regs_u[GDB_G1 + i];
 
 	/* If the TSTATE register is changing, we have to preserve
 	 * the CWP field, otherwise window save/restore explodes.
 	 */
-	if (regs->tstate != gdb_regs[GDB_STATE]) {
+	if (regs->tstate != gdb_regs_sparc64->gdb_reg_state) {
 		unsigned long cwp = regs->tstate & TSTATE_CWP;
-
-		regs->tstate = (gdb_regs[GDB_STATE] & ~TSTATE_CWP) | cwp;
+		regs->tstate = (gdb_regs_sparc64->gdb_reg_state & ~TSTATE_CWP) | cwp;
 	}
 
-	regs->tpc = gdb_regs[GDB_PC];
-	regs->tnpc = gdb_regs[GDB_NPC];
-	regs->y = gdb_regs[GDB_Y];
+	regs->tpc = gdb_regs_sparc64->gdb_reg_pc;
+	regs->tnpc = gdb_regs_sparc64->gdb_reg_npc;
+	regs->y = gdb_regs_sparc64->gdb_reg_y;
 
 	win = (struct reg_window *) (regs->u_regs[UREG_FP] + STACK_BIAS);
 	for (i = 0; i < 8; i++)
-		win->locals[i] = gdb_regs[GDB_L0 + i];
+		win->locals[i] = gdb_regs_sparc64->gdb_regs_u[GDB_L0 + i];
 	for (i = 0; i < 8; i++)
-		win->ins[i] = gdb_regs[GDB_I0 + i];
+		win->ins[i] = gdb_regs_sparc64->gdb_regs_u[GDB_I0 + i];
 }
 
 #ifdef CONFIG_SMP
-- 
1.6.0.3

