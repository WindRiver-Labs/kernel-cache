From 2e86f08517647be9cc0f1338b80a29818a2b68df Mon Sep 17 00:00:00 2001
From: Dongdong Deng <dongdong.deng@windriver.com>
Date: Wed, 28 Apr 2010 23:34:33 -0700
Subject: [PATCH 2/3] kgdb core: clean the DCPU_WANT_MASTER state before free kgdb_active

There is a time window that multi-cpus could hold the
DCPU_WANT_MASTER state.

----------------------------------------------------------
cpu1                           cpu2

set DCPU_WATN_MASTER state

free the slave cpus(cpu2)

                               hit a breakpoint
                               spin at kgdb_active

free kgdb_active
                               enter kgdb...
                               set DCPU_WATN_MASTER state
                               kgdb_roundup_cpus()

interrupt by nmi, enter
kgdb with slave mode.

clean DCPU_WATN_MASTER

----------------------------------------------------------

To fix this, we clean the DCPU_WANT_MASTER state before free
kgdb_active.

Signed-off-by: Dongdong Deng <dongdong.deng@windriver.com>
---
 kernel/debug/debug_core.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/kernel/debug/debug_core.c b/kernel/debug/debug_core.c
index 4412bc9..38fee3b 100644
--- a/kernel/debug/debug_core.c
+++ b/kernel/debug/debug_core.c
@@ -523,6 +523,8 @@ return_normal:
 				arch_kgdb_ops.correct_hw_break();
 			if (trace_on)
 				tracing_on();
+
+			kgdb_info[cpu].exception_state &= ~DCPU_IS_SLAVE;
 			atomic_dec(&cpu_in_kgdb[cpu]);
 			touch_softlockup_watchdog_sync();
 			clocksource_touch_watchdog();
@@ -656,6 +658,9 @@ kgdb_restore:
 	}
 	if (trace_on)
 		tracing_on();
+
+	kgdb_info[cpu].exception_state &= ~(DCPU_WANT_MASTER |
+			DCPU_IS_SLAVE);
 	/* Free kgdb_active */
 	atomic_set(&kgdb_active, -1);
 	touch_softlockup_watchdog_sync();
@@ -677,7 +682,6 @@ kgdb_handle_exception(int evector, int signo, int ecode, struct pt_regs *regs)
 {
 	struct kgdb_state kgdb_var;
 	struct kgdb_state *ks = &kgdb_var;
-	int ret;
 
 	ks->cpu			= raw_smp_processor_id();
 	ks->ex_vector		= evector;
@@ -689,10 +693,7 @@ kgdb_handle_exception(int evector, int signo, int ecode, struct pt_regs *regs)
 	if (kgdb_reenter_check(ks))
 		return 0; /* Ouch, double exception ! */
 	kgdb_info[ks->cpu].exception_state |= DCPU_WANT_MASTER;
-	ret = kgdb_cpu_enter(ks, regs);
-	kgdb_info[ks->cpu].exception_state &= ~(DCPU_WANT_MASTER |
-						DCPU_IS_SLAVE);
-	return ret;
+	return kgdb_cpu_enter(ks, regs);
 }
 
 /*
@@ -726,7 +727,6 @@ int kgdb_nmicallback(int cpu, void *regs)
 	    atomic_read(&kgdb_active) != cpu) {
 		kgdb_info[cpu].exception_state |= DCPU_IS_SLAVE;
 		kgdb_cpu_enter(ks, regs);
-		kgdb_info[cpu].exception_state &= ~DCPU_IS_SLAVE;
 		return 0;
 	}
 #endif
-- 
1.6.5.2

