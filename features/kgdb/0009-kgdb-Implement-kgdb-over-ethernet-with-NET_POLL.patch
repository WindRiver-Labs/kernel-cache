From 92b70affb5f19ebed7f72c02eaec1dfa395db62c Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Mon, 4 Aug 2008 21:46:12 -0500
Subject: [PATCH] kgdb: Implement kgdb over ethernet with NET_POLL

At one point this was very similar to the version Matt Mackall wrote
to allow for the use of KGDB over ethernet.  Since then it has been
reworked to fit into the unified KGDB model.

This kgdb I/O driver can work as a kernel built-in or a kernel
module.

Signed-off-by: Tom Rini <trini@kernel.crashing.org>
Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Acked-by: Matt Mackall <mpm@selenic.com>
---
 Documentation/DocBook/kgdb.tmpl     |   64 ++++++++-
 Documentation/kernel-parameters.txt |    7 +
 drivers/net/Makefile                |    1 +
 drivers/net/kgdboe.c                |  286 +++++++++++++++++++++++++++++++++++
 include/linux/kgdb.h                |    1 +
 kernel/kgdb.c                       |   26 +++
 lib/Kconfig.kgdb                    |   11 ++
 7 files changed, 395 insertions(+), 1 deletions(-)
 create mode 100644 drivers/net/kgdboe.c

diff --git a/Documentation/DocBook/kgdb.tmpl b/Documentation/DocBook/kgdb.tmpl
index 651d710..fdefa36 100644
--- a/Documentation/DocBook/kgdb.tmpl
+++ b/Documentation/DocBook/kgdb.tmpl
@@ -311,6 +311,61 @@
   </para>
   </sect2>
   </sect1>
+  <sect1 id="kgdboe">
+  <title>Kernel parameter: kgdboe</title>
+  <para>
+  The term kgdboe is meant to stand for kgdb over ethernet.  To use
+  kgdboe, the ethernet driver must have implemented the NETPOLL API,
+  and the kernel must be compiled with NETPOLL support.  Also kgdboe
+  uses unicast udp.  This means your debug host needs to be on the
+  same lan as the target system you wish to debug.
+  </para>
+  <para>
+  NOTE: Even though an ethernet driver may implement the NETPOLL API
+  it is possible that kgdboe will not work as a robust debug method.
+  Trying to debug the network stack for instance, would likely hang
+  the kernel.  Also certain IRQ resources cannot be easily shared
+  between the normal kernel operation and the "polled context" where
+  the system is stopped by kgdb.  Using kgdboe with preemptible IRQ
+  handlers for the device kgdboe is using is known to have with the
+  system hanging for instance.
+  </para>
+  <para>
+  The kgdboe parameter string is as follows:
+  <constant>kgdboe=[src-port]@&lt;src-ip&gt;/[dev],[tgt-port]@&lt;tgt-ip&gt;/[tgt-macaddr]</constant>
+  where:
+  <itemizedlist>
+    <listitem><para>src-port (optional): source for UDP packets (defaults to <constant>6443</constant>)</para></listitem>
+    <listitem><para>src-ip (optional unless from boot): source IP to use (interface address)</para></listitem>
+    <listitem><para>dev (optional): network interface (<constant>eth0</constant>)</para></listitem>
+    <listitem><para>tgt-port (optional): port GDB will use (defaults to <constant>6442</constant>)</para></listitem>
+    <listitem><para>tgt-ip: IP address GDB will be connecting from</para></listitem>
+    <listitem><para>tgt-macaddr (optional): ethernet MAC address for logging agent (default is broadcast)</para></listitem>
+  </itemizedlist>
+  </para>
+  <para>
+  What follows are several examples of how to configure kgdboe in various ways.
+  <itemizedlist>
+  <listitem><para>From boot with target ip = 10.0.2.15 and debug host ip = 10.0.2.2</para>
+  <para><constant>kgdboe=@10.0.2.15/,@10.0.2.2/</constant></para>
+  </listitem>
+  <listitem><para>From boot using eth1, with target ip = 10.0.2.15 and debug host ip = 10.0.2.2</para>
+  <para><constant>kgdboe=@10.0.2.15/eth1,@10.0.2.2/</constant></para>
+  </listitem>
+  <listitem><para>As a module, with target ip = 10.0.2.15 and debug host ip = 10.0.2.2. NOTE: The src ip is only required when booting with kgdboe enabled</para>
+  <para><constant>kgdboe=@/,@10.0.2.2/</constant></para>
+  </listitem>
+  </itemizedlist>
+  </para>
+  <para>
+  You can also reconfigure kgdboe dynamically at run time as follows:
+  <itemizedlist>
+  <listitem>
+  <para><constant>echo "@/,@10.0.2.2/" &gt; /sys/module/kgdboe/paramters/kgdboe</constant></para>
+  </listitem>
+  </itemizedlist>
+  </para>
+  </sect1>
   <sect1 id="kgdbcon">
   <title>Kernel parameter: kgdbcon</title>
   <para>
@@ -335,7 +390,7 @@
   </para>
   <para>
   IMPORTANT NOTE: Using this option with kgdb over the console
-  (kgdboc) is not supported.
+  (kgdboc) or kgdb over ethernet (kgdboe) is not supported.
   </para>
   </sect1>
   </chapter>
@@ -368,6 +423,13 @@
     (gdb) target remote 192.168.2.2:2012
     </programlisting>
     <para>
+    Example (kgdb over ethernet):
+    </para>
+    <programlisting>
+    % gdb ./vmlinux
+    (gdb) target remote udp:192.168.2.2:6443
+    </programlisting>
+    <para>
     Once connected, you can debug a kernel the way you would debug an
     application program.
     </para>
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index e7bea3e..2ecb88a 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -938,6 +938,13 @@ and is between 256 and 4096 characters. It is defined in the file
 	ips=		[HW,SCSI] Adaptec / IBM ServeRAID controller
 			See header of drivers/scsi/ips.c.
 
+	kgdboe=		[HW] Setup the local ip information and host ip
+			information when the network driver supports
+			NETPOLL and kgdboe is configured as a built in.
+			Options are:
+			[src-port]@<src-ip>/[dev],[tgt-port]@<tgt-ip>/<tgt-mac>
+			IE: kgdboe=@10.0.1.2/,@10.0.0.1.3/
+
 	ports=		[IP_VS_FTP] IPVS ftp helper module
 			Default is 21.
 			Up to 8 (IP_VS_APP_MAX_PORTS) ports
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 7629c90..de81c8a 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -248,6 +248,7 @@ obj-$(CONFIG_ETRAX_ETHERNET) += cris/
 obj-$(CONFIG_ENP2611_MSF_NET) += ixp2000/
 
 obj-$(CONFIG_NETCONSOLE) += netconsole.o
+obj-$(CONFIG_KGDBOE) += kgdboe.o
 
 obj-$(CONFIG_FS_ENET) += fs_enet/
 
diff --git a/drivers/net/kgdboe.c b/drivers/net/kgdboe.c
new file mode 100644
index 0000000..939797a
--- /dev/null
+++ b/drivers/net/kgdboe.c
@@ -0,0 +1,286 @@
+/*
+ * drivers/net/kgdboe.c
+ *
+ * A network interface for GDB.
+ * Based upon 'gdbserial' by David Grothe <dave@gcom.com>
+ * and Scott Foehner <sfoehner@engr.sgi.com>
+ *
+ * Maintainer: Jason Wessel <jason.wessel@windriver.com>
+ *
+ * 2004 (c) Amit S. Kale <amitkale@linsyssoft.com>
+ * 2004-2005 (c) MontaVista Software, Inc.
+ * 2005-2008 (c) Wind River Systems, Inc.
+ *
+ * Contributors at various stages not listed above:
+ * San Mehat <nettwerk@biodome.org>, Robert Walsh <rjwalsh@durables.org>,
+ * wangdi <wangdi@clusterfs.com>, Matt Mackall <mpm@selenic.com>,
+ * Pavel Machek <pavel@suse.cz>, Jason Wessel <jason.wessel@windriver.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/kgdb.h>
+#include <linux/netpoll.h>
+#include <linux/init.h>
+
+#include <asm/atomic.h>
+
+#define IN_BUF_SIZE 512		/* power of 2, please */
+#define OUT_BUF_SIZE 30		/* We don't want to send too big of a packet. */
+#define MAX_CONFIG_LEN 256
+
+static char in_buf[IN_BUF_SIZE], out_buf[OUT_BUF_SIZE];
+static int in_head, in_tail, out_count;
+static atomic_t in_count;
+/* 0 = unconfigured, 1 = netpoll options parsed, 2 = fully configured. */
+static int configured;
+static struct kgdb_io local_kgdb_io_ops;
+static int use_dynamic_mac;
+
+MODULE_DESCRIPTION("KGDB driver for network interfaces");
+MODULE_LICENSE("GPL");
+static char config[MAX_CONFIG_LEN];
+static struct kparam_string kps = {
+	.string = config,
+	.maxlen = MAX_CONFIG_LEN,
+};
+
+static void rx_hook(struct netpoll *np, int port, char *msg, int len,
+		    struct sk_buff *skb)
+{
+	int i;
+
+	np->remote_port = port;
+
+	/* Copy the MAC address if we need to. */
+	if (use_dynamic_mac) {
+		memcpy(np->remote_mac, eth_hdr(skb)->h_source,
+				sizeof(np->remote_mac));
+		use_dynamic_mac = 0;
+	}
+
+	/*
+	 * This could be GDB trying to attach.  But it could also be GDB
+	 * finishing up a session, with kgdb_connected=0 but GDB sending
+	 * an ACK for the final packet.  To make sure we don't try and
+	 * make a breakpoint when GDB is leaving, make sure that if
+	 * !kgdb_connected the only len == 1 packet we allow is ^C.
+	 */
+	if (!kgdb_connected && (len != 1 || msg[0] == 3))
+		kgdb_schedule_breakpoint();
+
+	for (i = 0; i < len; i++) {
+		if (msg[i] == 3)
+			kgdb_schedule_breakpoint();
+
+		if (atomic_read(&in_count) >= IN_BUF_SIZE) {
+			/* buffer overflow, clear it */
+			in_head = 0;
+			in_tail = 0;
+			atomic_set(&in_count, 0);
+			break;
+		}
+		in_buf[in_head++] = msg[i];
+		in_head &= (IN_BUF_SIZE - 1);
+		atomic_inc(&in_count);
+	}
+}
+
+static struct netpoll np = {
+	.dev_name = "eth0",
+	.name = "kgdboe",
+	.rx_hook = rx_hook,
+	.local_port = 6443,
+	.remote_port = 6442,
+	.remote_mac = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff },
+};
+
+static void eth_pre_exception_handler(void)
+{
+	/* Increment the module count when the debugger is active */
+	if (!kgdb_connected)
+		try_module_get(THIS_MODULE);
+	netpoll_set_trap(1);
+}
+
+static void eth_post_exception_handler(void)
+{
+	/* decrement the module count when the debugger detaches */
+	if (!kgdb_connected)
+		module_put(THIS_MODULE);
+	netpoll_set_trap(0);
+}
+
+static int eth_get_char(void)
+{
+	int chr;
+
+	while (atomic_read(&in_count) == 0)
+		netpoll_poll(&np);
+
+	chr = in_buf[in_tail++];
+	in_tail &= (IN_BUF_SIZE - 1);
+	atomic_dec(&in_count);
+	return chr;
+}
+
+static void eth_flush_buf(void)
+{
+	if (out_count && np.dev) {
+		netpoll_send_udp(&np, out_buf, out_count);
+		memset(out_buf, 0, sizeof(out_buf));
+		out_count = 0;
+	}
+}
+
+static void eth_put_char(u8 chr)
+{
+	out_buf[out_count++] = chr;
+	if (out_count == OUT_BUF_SIZE)
+		eth_flush_buf();
+}
+
+static int option_setup(char *opt)
+{
+	char opt_scratch[MAX_CONFIG_LEN];
+
+	configured = 0;
+	/* If we're being given a new configuration, copy it in. */
+	if (opt != config)
+		strcpy(config, opt);
+
+	if (opt[0] == '\0')
+		return 1;
+
+	/* But work on a copy as netpoll_parse_options will eat it. */
+	strcpy(opt_scratch, opt);
+	configured = !netpoll_parse_options(&np, opt_scratch);
+
+	use_dynamic_mac = 1;
+
+	return 0;
+}
+__setup("kgdboe=", option_setup);
+
+/* With our config string set by some means, configure kgdboe. */
+static int configure_kgdboe(void)
+{
+	if (option_setup(config))
+		return 0;
+
+	if (!configured) {
+		printk(KERN_ERR "kgdboe: configuration incorrect - kgdboe not "
+		       "loaded.\n");
+		printk(KERN_ERR "  Usage: kgdboe=[src-port]@[src-ip]/[dev],"
+				"[tgt-port]@<tgt-ip>/<tgt-macaddr>\n");
+		return -EINVAL;
+	}
+
+	/* Bring it up. */
+	if (netpoll_setup(&np)) {
+		printk(KERN_ERR "kgdboe: netpoll_setup failed kgdboe failed\n");
+		return -EINVAL;
+	}
+
+	if (kgdb_register_io_module(&local_kgdb_io_ops)) {
+		netpoll_cleanup(&np);
+		return -EINVAL;
+	}
+
+	configured = 2;
+
+	return 0;
+}
+
+static int init_kgdboe(void)
+{
+	int ret;
+
+	/* Already done? */
+	if (configured == 2)
+		return 0;
+
+	/* OK, go ahead and do it. */
+	ret = configure_kgdboe();
+
+	if (configured == 2)
+		printk(KERN_INFO "kgdboe: debugging over ethernet enabled\n");
+
+	return ret;
+}
+
+static void cleanup_kgdboe(void)
+{
+	netpoll_cleanup(&np);
+	configured = 0;
+	kgdb_unregister_io_module(&local_kgdb_io_ops);
+}
+
+static int param_set_kgdboe_var(const char *kmessage, struct kernel_param *kp)
+{
+	char kmessage_save[MAX_CONFIG_LEN];
+	int len = strlen(kmessage);
+
+	if (len >= MAX_CONFIG_LEN) {
+		printk(KERN_ERR "kgdboc: config string too long\n");
+		return -ENOSPC;
+	}
+
+	if (kgdb_connected) {
+		printk(KERN_ERR "kgdboe: Cannot reconfigure while KGDB is "
+				"connected.\n");
+		return 0;
+	}
+
+	/* Start the reconfiguration process by saving the old string */
+	strncpy(kmessage_save, config, sizeof(kmessage_save));
+
+
+	/* Copy in the new param and strip out invalid characters so we
+	 * can optionally specify the MAC.
+	 */
+	strcpy(config, kmessage);
+	/* Chop out \n char as a result of echo */
+	if (config[len - 1] == '\n')
+		config[len - 1] = '\0';
+
+	len--;
+	while (len > 0 && (config[len] < ',' || config[len] > 'f')) {
+		config[len] = '\0';
+		len--;
+	}
+
+	if (configured == 2) {
+		cleanup_kgdboe();
+		configured = 0;
+	}
+	if (config[0] == '\0')
+		return 0;
+
+	configure_kgdboe();
+
+	if (configured != 2)
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct kgdb_io local_kgdb_io_ops = {
+	.name = "kgdboe",
+	.read_char = eth_get_char,
+	.write_char = eth_put_char,
+	.flush = eth_flush_buf,
+	.pre_exception = eth_pre_exception_handler,
+	.post_exception = eth_post_exception_handler
+};
+
+module_init(init_kgdboe);
+module_exit(cleanup_kgdboe);
+module_param_call(kgdboe, param_set_kgdboe_var, param_get_string, &kps, 0644);
+MODULE_PARM_DESC(kgdboe, "[src-port]@[src-ip]/[dev],"
+		 "[tgt-port]@<tgt-ip>/<tgt-macaddr>");
diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 6adcc29..8fdd3cb 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -279,5 +279,6 @@ extern int kgdb_nmicallback(int cpu, void *regs);
 
 extern int			kgdb_single_step;
 extern atomic_t			kgdb_active;
+extern void kgdb_schedule_breakpoint(void);
 
 #endif /* _KGDB_H_ */
diff --git a/kernel/kgdb.c b/kernel/kgdb.c
index f30478a..c803730 100644
--- a/kernel/kgdb.c
+++ b/kernel/kgdb.c
@@ -123,6 +123,7 @@ atomic_t			kgdb_active = ATOMIC_INIT(-1);
  */
 static atomic_t			passive_cpu_wait[NR_CPUS];
 static atomic_t			cpu_in_kgdb[NR_CPUS];
+static atomic_t			kgdb_break_tasklet_var;
 atomic_t			kgdb_setting_breakpoint;
 
 struct task_struct		*kgdb_usethread;
@@ -1677,6 +1678,31 @@ static void kgdb_unregister_callbacks(void)
 	}
 }
 
+/*
+ * There are times a tasklet needs to be used vs a compiled in in
+ * break point so as to cause an exception outside a kgdb I/O module,
+ * such as is the case with kgdboe, where calling a breakpoint in the
+ * I/O driver itself would be fatal.
+ */
+static void kgdb_tasklet_bpt(unsigned long ing)
+{
+	kgdb_breakpoint();
+	atomic_set(&kgdb_break_tasklet_var, 0);
+}
+
+static DECLARE_TASKLET(kgdb_tasklet_breakpoint, kgdb_tasklet_bpt, 0);
+
+void kgdb_schedule_breakpoint(void)
+{
+	if (atomic_read(&kgdb_break_tasklet_var) ||
+		atomic_read(&kgdb_active) != -1 ||
+		atomic_read(&kgdb_setting_breakpoint))
+		return;
+	atomic_inc(&kgdb_break_tasklet_var);
+	tasklet_schedule(&kgdb_tasklet_breakpoint);
+}
+EXPORT_SYMBOL_GPL(kgdb_schedule_breakpoint);
+
 static void kgdb_initial_breakpoint(void)
 {
 	kgdb_break_asap = 0;
diff --git a/lib/Kconfig.kgdb b/lib/Kconfig.kgdb
index 33a80db..bc8d481 100644
--- a/lib/Kconfig.kgdb
+++ b/lib/Kconfig.kgdb
@@ -55,6 +55,17 @@ config KGDB_8250
 	  attached via this driver,  the configured serial port cannot be
 	  used by the standard 8250 driver or serial earlyprintk/earlycon.
 
+config KGDBOE
+	tristate "KGDB: On ethernet"
+	depends on KGDB
+	select NETPOLL
+	select NETPOLL_TRAP
+	help
+	  Uses the NETPOLL API to communicate with the host GDB via UDP.
+	  In order for this to work, the ethernet interface specified must
+	  support the NETPOLL API, and this must be initialized at boot.
+	  See the documentation for syntax.
+
 config KGDB_TESTS
 	bool "KGDB: internal test suite"
 	default n
-- 
1.5.5.1

