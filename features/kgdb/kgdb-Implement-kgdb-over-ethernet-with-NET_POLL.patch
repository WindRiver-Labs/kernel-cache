From 0ebc78c54e84490445e49cb3ca94e4a336059f82 Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Tue, 28 Jul 2009 13:31:45 -0500
Subject: [PATCH] kgdb: Implement kgdb over ethernet with NET_POLL

At one point this was very similar to the version Matt Mackall wrote
to allow for the use of KGDB over ethernet.  Since then it has been
reworked to fit into the unified KGDB model.

This kgdb I/O driver can work as a kernel built-in or a kernel
module.

Signed-off-by: Tom Rini <trini@kernel.crashing.org>
Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Acked-by: Matt Mackall <mpm@selenic.com>
---
 Documentation/DocBook/kgdb.tmpl     |   62 ++++++++
 Documentation/kernel-parameters.txt |    7 +
 drivers/net/Makefile                |    1 +
 drivers/net/kgdboe.c                |  286 +++++++++++++++++++++++++++++++++++
 lib/Kconfig.kgdb                    |   11 ++
 5 files changed, 367 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/kgdboe.c

diff --git a/Documentation/DocBook/kgdb.tmpl b/Documentation/DocBook/kgdb.tmpl
index 5cff41a..abf32e2 100644
--- a/Documentation/DocBook/kgdb.tmpl
+++ b/Documentation/DocBook/kgdb.tmpl
@@ -216,6 +216,61 @@
   </para>
   </sect2>
   </sect1>
+  <sect1 id="kgdboe">
+  <title>Kernel parameter: kgdboe</title>
+  <para>
+  The term kgdboe is meant to stand for kgdb over ethernet.  To use
+  kgdboe, the ethernet driver must have implemented the NETPOLL API,
+  and the kernel must be compiled with NETPOLL support.  Also kgdboe
+  uses unicast udp.  This means your debug host needs to be on the
+  same lan as the target system you wish to debug.
+  </para>
+  <para>
+  NOTE: Even though an ethernet driver may implement the NETPOLL API
+  it is possible that kgdboe will not work as a robust debug method.
+  Trying to debug the network stack for instance, would likely hang
+  the kernel.  Also certain IRQ resources cannot be easily shared
+  between the normal kernel operation and the "polled context" where
+  the system is stopped by kgdb.  Using kgdboe with preemptible IRQ
+  handlers for the device kgdboe is using is known to have with the
+  system hanging for instance.
+  </para>
+  <para>
+  The kgdboe parameter string is as follows:
+  <constant>kgdboe=[src-port]@&lt;src-ip&gt;/[dev],[tgt-port]@&lt;tgt-ip&gt;/[tgt-macaddr]</constant>
+  where:
+  <itemizedlist>
+    <listitem><para>src-port (optional): source for UDP packets (defaults to <constant>6443</constant>)</para></listitem>
+    <listitem><para>src-ip (optional unless from boot): source IP to use (interface address)</para></listitem>
+    <listitem><para>dev (optional): network interface (<constant>eth0</constant>)</para></listitem>
+    <listitem><para>tgt-port (optional): port GDB will use (defaults to <constant>6442</constant>)</para></listitem>
+    <listitem><para>tgt-ip: IP address GDB will be connecting from</para></listitem>
+    <listitem><para>tgt-macaddr (optional): ethernet MAC address for logging agent (default is broadcast)</para></listitem>
+  </itemizedlist>
+  </para>
+  <para>
+  What follows are several examples of how to configure kgdboe in various ways.
+  <itemizedlist>
+  <listitem><para>From boot with target ip = 10.0.2.15 and debug host ip = 10.0.2.2</para>
+  <para><constant>kgdboe=@10.0.2.15/,@10.0.2.2/</constant></para>
+  </listitem>
+  <listitem><para>From boot using eth1, with target ip = 10.0.2.15 and debug host ip = 10.0.2.2</para>
+  <para><constant>kgdboe=@10.0.2.15/eth1,@10.0.2.2/</constant></para>
+  </listitem>
+  <listitem><para>As a module, with target ip = 10.0.2.15 and debug host ip = 10.0.2.2. NOTE: The src ip is only required when booting with kgdboe enabled</para>
+  <para><constant>kgdboe=@/,@10.0.2.2/</constant></para>
+  </listitem>
+  </itemizedlist>
+  </para>
+  <para>
+  You can also reconfigure kgdboe dynamically at run time as follows:
+  <itemizedlist>
+  <listitem>
+  <para><constant>echo "@/,@10.0.2.2/" &gt; /sys/module/kgdboe/paramters/kgdboe</constant></para>
+  </listitem>
+  </itemizedlist>
+  </para>
+  </sect1>
   <sect1 id="kgdbcon">
   <title>Kernel parameter: kgdbcon</title>
   <para>
@@ -273,6 +328,13 @@
     (gdb) target remote 192.168.2.2:2012
     </programlisting>
     <para>
+    Example (kgdb over ethernet):
+    </para>
+    <programlisting>
+    % gdb ./vmlinux
+    (gdb) target remote udp:192.168.2.2:6443
+    </programlisting>
+    <para>
     Once connected, you can debug a kernel the way you would debug an
     application program.
     </para>
diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index e4cbca5..9968dd9 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1122,6 +1122,13 @@ and is between 256 and 4096 characters. It is defined in the file
 			(only serial supported for now)
 			Format: <serial_device>[,baud]
 
+	kgdboe=		[HW] Setup the local ip information and host ip
+			information when the network driver supports
+			NETPOLL and kgdboe is configured as a built in.
+			Options are:
+			[src-port]@<src-ip>/[dev],[tgt-port]@<tgt-ip>/<tgt-mac>
+			IE: kgdboe=@10.0.1.2/,@10.0.0.1.3/
+
 	kmac=		[MIPS] korina ethernet MAC address.
 			Configure the RouterBoard 532 series on-chip
 			Ethernet adapter MAC address.
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 4788862..3f23e95 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -281,6 +281,7 @@ obj-$(CONFIG_ETRAX_ETHERNET) += cris/
 obj-$(CONFIG_ENP2611_MSF_NET) += ixp2000/
 
 obj-$(CONFIG_NETCONSOLE) += netconsole.o
+obj-$(CONFIG_KGDBOE) += kgdboe.o
 
 obj-$(CONFIG_FS_ENET) += fs_enet/
 
diff --git a/drivers/net/kgdboe.c b/drivers/net/kgdboe.c
new file mode 100644
index 0000000..939797a
--- /dev/null
+++ b/drivers/net/kgdboe.c
@@ -0,0 +1,286 @@
+/*
+ * drivers/net/kgdboe.c
+ *
+ * A network interface for GDB.
+ * Based upon 'gdbserial' by David Grothe <dave@gcom.com>
+ * and Scott Foehner <sfoehner@engr.sgi.com>
+ *
+ * Maintainer: Jason Wessel <jason.wessel@windriver.com>
+ *
+ * 2004 (c) Amit S. Kale <amitkale@linsyssoft.com>
+ * 2004-2005 (c) MontaVista Software, Inc.
+ * 2005-2008 (c) Wind River Systems, Inc.
+ *
+ * Contributors at various stages not listed above:
+ * San Mehat <nettwerk@biodome.org>, Robert Walsh <rjwalsh@durables.org>,
+ * wangdi <wangdi@clusterfs.com>, Matt Mackall <mpm@selenic.com>,
+ * Pavel Machek <pavel@suse.cz>, Jason Wessel <jason.wessel@windriver.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/kgdb.h>
+#include <linux/netpoll.h>
+#include <linux/init.h>
+
+#include <asm/atomic.h>
+
+#define IN_BUF_SIZE 512		/* power of 2, please */
+#define OUT_BUF_SIZE 30		/* We don't want to send too big of a packet. */
+#define MAX_CONFIG_LEN 256
+
+static char in_buf[IN_BUF_SIZE], out_buf[OUT_BUF_SIZE];
+static int in_head, in_tail, out_count;
+static atomic_t in_count;
+/* 0 = unconfigured, 1 = netpoll options parsed, 2 = fully configured. */
+static int configured;
+static struct kgdb_io local_kgdb_io_ops;
+static int use_dynamic_mac;
+
+MODULE_DESCRIPTION("KGDB driver for network interfaces");
+MODULE_LICENSE("GPL");
+static char config[MAX_CONFIG_LEN];
+static struct kparam_string kps = {
+	.string = config,
+	.maxlen = MAX_CONFIG_LEN,
+};
+
+static void rx_hook(struct netpoll *np, int port, char *msg, int len,
+		    struct sk_buff *skb)
+{
+	int i;
+
+	np->remote_port = port;
+
+	/* Copy the MAC address if we need to. */
+	if (use_dynamic_mac) {
+		memcpy(np->remote_mac, eth_hdr(skb)->h_source,
+				sizeof(np->remote_mac));
+		use_dynamic_mac = 0;
+	}
+
+	/*
+	 * This could be GDB trying to attach.  But it could also be GDB
+	 * finishing up a session, with kgdb_connected=0 but GDB sending
+	 * an ACK for the final packet.  To make sure we don't try and
+	 * make a breakpoint when GDB is leaving, make sure that if
+	 * !kgdb_connected the only len == 1 packet we allow is ^C.
+	 */
+	if (!kgdb_connected && (len != 1 || msg[0] == 3))
+		kgdb_schedule_breakpoint();
+
+	for (i = 0; i < len; i++) {
+		if (msg[i] == 3)
+			kgdb_schedule_breakpoint();
+
+		if (atomic_read(&in_count) >= IN_BUF_SIZE) {
+			/* buffer overflow, clear it */
+			in_head = 0;
+			in_tail = 0;
+			atomic_set(&in_count, 0);
+			break;
+		}
+		in_buf[in_head++] = msg[i];
+		in_head &= (IN_BUF_SIZE - 1);
+		atomic_inc(&in_count);
+	}
+}
+
+static struct netpoll np = {
+	.dev_name = "eth0",
+	.name = "kgdboe",
+	.rx_hook = rx_hook,
+	.local_port = 6443,
+	.remote_port = 6442,
+	.remote_mac = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff },
+};
+
+static void eth_pre_exception_handler(void)
+{
+	/* Increment the module count when the debugger is active */
+	if (!kgdb_connected)
+		try_module_get(THIS_MODULE);
+	netpoll_set_trap(1);
+}
+
+static void eth_post_exception_handler(void)
+{
+	/* decrement the module count when the debugger detaches */
+	if (!kgdb_connected)
+		module_put(THIS_MODULE);
+	netpoll_set_trap(0);
+}
+
+static int eth_get_char(void)
+{
+	int chr;
+
+	while (atomic_read(&in_count) == 0)
+		netpoll_poll(&np);
+
+	chr = in_buf[in_tail++];
+	in_tail &= (IN_BUF_SIZE - 1);
+	atomic_dec(&in_count);
+	return chr;
+}
+
+static void eth_flush_buf(void)
+{
+	if (out_count && np.dev) {
+		netpoll_send_udp(&np, out_buf, out_count);
+		memset(out_buf, 0, sizeof(out_buf));
+		out_count = 0;
+	}
+}
+
+static void eth_put_char(u8 chr)
+{
+	out_buf[out_count++] = chr;
+	if (out_count == OUT_BUF_SIZE)
+		eth_flush_buf();
+}
+
+static int option_setup(char *opt)
+{
+	char opt_scratch[MAX_CONFIG_LEN];
+
+	configured = 0;
+	/* If we're being given a new configuration, copy it in. */
+	if (opt != config)
+		strcpy(config, opt);
+
+	if (opt[0] == '\0')
+		return 1;
+
+	/* But work on a copy as netpoll_parse_options will eat it. */
+	strcpy(opt_scratch, opt);
+	configured = !netpoll_parse_options(&np, opt_scratch);
+
+	use_dynamic_mac = 1;
+
+	return 0;
+}
+__setup("kgdboe=", option_setup);
+
+/* With our config string set by some means, configure kgdboe. */
+static int configure_kgdboe(void)
+{
+	if (option_setup(config))
+		return 0;
+
+	if (!configured) {
+		printk(KERN_ERR "kgdboe: configuration incorrect - kgdboe not "
+		       "loaded.\n");
+		printk(KERN_ERR "  Usage: kgdboe=[src-port]@[src-ip]/[dev],"
+				"[tgt-port]@<tgt-ip>/<tgt-macaddr>\n");
+		return -EINVAL;
+	}
+
+	/* Bring it up. */
+	if (netpoll_setup(&np)) {
+		printk(KERN_ERR "kgdboe: netpoll_setup failed kgdboe failed\n");
+		return -EINVAL;
+	}
+
+	if (kgdb_register_io_module(&local_kgdb_io_ops)) {
+		netpoll_cleanup(&np);
+		return -EINVAL;
+	}
+
+	configured = 2;
+
+	return 0;
+}
+
+static int init_kgdboe(void)
+{
+	int ret;
+
+	/* Already done? */
+	if (configured == 2)
+		return 0;
+
+	/* OK, go ahead and do it. */
+	ret = configure_kgdboe();
+
+	if (configured == 2)
+		printk(KERN_INFO "kgdboe: debugging over ethernet enabled\n");
+
+	return ret;
+}
+
+static void cleanup_kgdboe(void)
+{
+	netpoll_cleanup(&np);
+	configured = 0;
+	kgdb_unregister_io_module(&local_kgdb_io_ops);
+}
+
+static int param_set_kgdboe_var(const char *kmessage, struct kernel_param *kp)
+{
+	char kmessage_save[MAX_CONFIG_LEN];
+	int len = strlen(kmessage);
+
+	if (len >= MAX_CONFIG_LEN) {
+		printk(KERN_ERR "kgdboc: config string too long\n");
+		return -ENOSPC;
+	}
+
+	if (kgdb_connected) {
+		printk(KERN_ERR "kgdboe: Cannot reconfigure while KGDB is "
+				"connected.\n");
+		return 0;
+	}
+
+	/* Start the reconfiguration process by saving the old string */
+	strncpy(kmessage_save, config, sizeof(kmessage_save));
+
+
+	/* Copy in the new param and strip out invalid characters so we
+	 * can optionally specify the MAC.
+	 */
+	strcpy(config, kmessage);
+	/* Chop out \n char as a result of echo */
+	if (config[len - 1] == '\n')
+		config[len - 1] = '\0';
+
+	len--;
+	while (len > 0 && (config[len] < ',' || config[len] > 'f')) {
+		config[len] = '\0';
+		len--;
+	}
+
+	if (configured == 2) {
+		cleanup_kgdboe();
+		configured = 0;
+	}
+	if (config[0] == '\0')
+		return 0;
+
+	configure_kgdboe();
+
+	if (configured != 2)
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct kgdb_io local_kgdb_io_ops = {
+	.name = "kgdboe",
+	.read_char = eth_get_char,
+	.write_char = eth_put_char,
+	.flush = eth_flush_buf,
+	.pre_exception = eth_pre_exception_handler,
+	.post_exception = eth_post_exception_handler
+};
+
+module_init(init_kgdboe);
+module_exit(cleanup_kgdboe);
+module_param_call(kgdboe, param_set_kgdboe_var, param_get_string, &kps, 0644);
+MODULE_PARM_DESC(kgdboe, "[src-port]@[src-ip]/[dev],"
+		 "[tgt-port]@<tgt-ip>/<tgt-macaddr>");
diff --git a/lib/Kconfig.kgdb b/lib/Kconfig.kgdb
index 9b5d1d7..fe5010b 100644
--- a/lib/Kconfig.kgdb
+++ b/lib/Kconfig.kgdb
@@ -27,6 +27,17 @@ config KGDB_SERIAL_CONSOLE
 	  Share a serial console with kgdb. Sysrq-g must be used
 	  to break in initially.
 
+config KGDBOE
+	tristate "KGDB: On ethernet"
+	depends on KGDB
+	select NETPOLL
+	select NETPOLL_TRAP
+	help
+	  Uses the NETPOLL API to communicate with the host GDB via UDP.
+	  In order for this to work, the ethernet interface specified must
+	  support the NETPOLL API, and this must be initialized at boot.
+	  See the documentation for syntax.
+
 config KGDB_TESTS
 	bool "KGDB: internal test suite"
 	default n
-- 
1.6.0.3

