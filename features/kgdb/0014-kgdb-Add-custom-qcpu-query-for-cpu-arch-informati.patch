From bdebf366ee0e689344c73a30e8cb54414f058a74 Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Mon, 3 Nov 2008 12:41:37 -0600
Subject: [PATCH] kgdb: Add custom qcpu query for cpu / arch information

This patch implements the ability to query the target architecture
via the gdb serial protocol.

For ARM use ARM_cpu_name directly for "qcpu" command.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Integrated-by: Dongdong Deng <dongdong.deng@windriver.com>
---
 arch/arm/kernel/setup.c |    8 ++++----
 kernel/kgdb.c           |   43 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 47 insertions(+), 4 deletions(-)

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 2ca7038..a8525c9 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -115,7 +115,7 @@ unsigned long phys_initrd_start __initdata = 0;
 unsigned long phys_initrd_size __initdata = 0;
 
 static struct meminfo meminfo __initdata = { 0, };
-static const char *cpu_name;
+const char *ARM_cpu_name;
 static const char *machine_name;
 static char __initdata command_line[COMMAND_LINE_SIZE];
 
@@ -353,7 +353,7 @@ static void __init setup_processor(void)
 		while (1);
 	}
 
-	cpu_name = list->cpu_name;
+	ARM_cpu_name = list->cpu_name;
 
 #ifdef MULTI_CPU
 	processor = *list->proc;
@@ -369,7 +369,7 @@ static void __init setup_processor(void)
 #endif
 
 	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
-	       cpu_name, processor_id, (int)processor_id & 15,
+	       ARM_cpu_name, processor_id, (int)processor_id & 15,
 	       proc_arch[cpu_architecture()], cr_alignment);
 
 	sprintf(init_utsname()->machine, "%s%c", list->arch_name, ENDIANNESS);
@@ -922,7 +922,7 @@ static int c_show(struct seq_file *m, void *v)
 	int i;
 
 	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
-		   cpu_name, (int)processor_id & 15, elf_platform);
+		   ARM_cpu_name, (int)processor_id & 15, elf_platform);
 
 #if defined(CONFIG_SMP)
 	for_each_online_cpu(i) {
diff --git a/kernel/kgdb.c b/kernel/kgdb.c
index 1aa8440..f9abfe4 100644
--- a/kernel/kgdb.c
+++ b/kernel/kgdb.c
@@ -39,6 +39,7 @@
 #include <linux/ptrace.h>
 #include <linux/reboot.h>
 #include <linux/string.h>
+#include <linux/utsname.h>
 #include <linux/delay.h>
 #include <linux/sched.h>
 #include <linux/sysrq.h>
@@ -1069,6 +1070,48 @@ static void gdb_cmd_query(struct kgdb_state *ks)
 			kgdb_mem2hex(tmpstr, remcom_out_buffer, strlen(tmpstr));
 		}
 		break;
+	case 'c':
+		if (memcmp(remcom_in_buffer + 1, "cpu,", 3) == 0) {
+			/* This is the qcpu command.
+			 *
+			 * The response is
+			 * arch,endian,kernel rev,arch specific
+			 */
+			strcpy(remcom_out_buffer, utsname()->machine);
+			strcat(remcom_out_buffer, ",");
+#ifdef __BIG_ENDIAN
+			strcat(remcom_out_buffer, "big,");
+#else
+			strcat(remcom_out_buffer, "little,");
+#endif
+			strcat(remcom_out_buffer, utsname()->release);
+			strcat(remcom_out_buffer, ",");
+#if defined(CONFIG_PPC64) || defined(CONFIG_PPC)
+			strcat(remcom_out_buffer, cur_cpu_spec[0].cpu_name);
+#elif defined(CONFIG_ARM)
+			{
+				extern const char *ARM_cpu_name;
+				if (ARM_cpu_name)
+					strcat(remcom_out_buffer, ARM_cpu_name);
+			}
+#elif defined(CONFIG_MIPS)
+			{
+				char fmt[64];
+				char fmt2[80];
+				unsigned int version =
+					cpu_data[0].processor_id;
+				unsigned int fp_vers = cpu_data[0].fpu_id;
+				sprintf(fmt, "%%s V%%d.%%d%s",
+					cpu_data[0].options &
+					MIPS_CPU_FPU ? "  FPU V%d.%d" : "");
+				sprintf(fmt2, fmt, __cpu_name[0],
+					(version >> 4) & 0x0f, version & 0x0f,
+					(fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
+				strcat(remcom_out_buffer, fmt2);
+			}
+#endif
+		}
+		break;
 	}
 }
 
-- 
1.7.0.4

