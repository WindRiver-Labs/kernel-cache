From d45ba421c51b42291195d33f5e666a9c87ab6685 Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Wed, 10 Sep 2008 11:38:26 -0500
Subject: [PATCH] kgdb: Add custom qcpu query for cpu / arch information

This patch implements the ability to query the target architecture
via the gdb serial protocol.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 kernel/kgdb.c |   50 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 50 insertions(+), 0 deletions(-)

diff --git a/kernel/kgdb.c b/kernel/kgdb.c
index 5d48873..537a02e 100644
--- a/kernel/kgdb.c
+++ b/kernel/kgdb.c
@@ -39,6 +39,7 @@
 #include <linux/ptrace.h>
 #include <linux/reboot.h>
 #include <linux/string.h>
+#include <linux/utsname.h>
 #include <linux/delay.h>
 #include <linux/sched.h>
 #include <linux/sysrq.h>
@@ -53,6 +54,9 @@
 #include <asm/atomic.h>
 #include <asm/system.h>
 #include <asm/unaligned.h>
+#ifdef CONFIG_ARM
+#include <asm/procinfo.h>
+#endif
 
 static int kgdb_break_asap;
 
@@ -1068,6 +1072,52 @@ static void gdb_cmd_query(struct kgdb_state *ks)
 			kgdb_mem2hex(tmpstr, remcom_out_buffer, strlen(tmpstr));
 		}
 		break;
+	case 'c':
+		if (memcmp(remcom_in_buffer + 1, "cpu,", 3) == 0) {
+			/* This is the qcpu command.
+			 *
+			 * The response is
+			 * arch,endian,kernel rev,arch specific
+			 */
+			strcpy(remcom_out_buffer, utsname()->machine);
+			strcat(remcom_out_buffer, ",");
+#ifdef __BIG_ENDIAN
+			strcat(remcom_out_buffer, "big,");
+#else
+			strcat(remcom_out_buffer, "little,");
+#endif
+			strcat(remcom_out_buffer, utsname()->release);
+			strcat(remcom_out_buffer, ",");
+#if defined(CONFIG_PPC64) || defined(CONFIG_PPC)
+			strcat(remcom_out_buffer, cur_cpu_spec[0].cpu_name);
+#elif defined(CONFIG_ARM)
+			{
+				extern struct proc_info_list
+					*lookup_processor_type(unsigned int);
+				struct proc_info_list *list;
+				list = lookup_processor_type(read_cpuid_id());
+				if (list)
+					strcat(remcom_out_buffer,
+					       list->cpu_name);
+			}
+#elif defined(CONFIG_MIPS)
+			{
+				char fmt[64];
+				char fmt2[80];
+				unsigned int version =
+					cpu_data[0].processor_id;
+				unsigned int fp_vers = cpu_data[0].fpu_id;
+				sprintf(fmt, "%%s V%%d.%%d%s",
+					cpu_data[0].options &
+					MIPS_CPU_FPU ? "  FPU V%d.%d" : "");
+				sprintf(fmt2, fmt, __cpu_name[0],
+					(version >> 4) & 0x0f, version & 0x0f,
+					(fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
+				strcat(remcom_out_buffer, fmt2);
+			}
+#endif
+		}
+		break;
 	}
 }
 
-- 
1.5.5.1

