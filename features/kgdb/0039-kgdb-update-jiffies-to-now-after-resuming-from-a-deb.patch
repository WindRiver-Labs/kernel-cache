From ddedd2688eccdac7b35b801e87712392855f49f7 Mon Sep 17 00:00:00 2001
From: DDD <Dongdong.deng@windriver.com>
Date: Tue, 29 Sep 2009 22:08:32 +0800
Subject: [PATCH] kgdb: update jiffies to now after resuming from a debug session

If the sched_clock() was realized based on jiffies, kgdb often
causes softlock warning messages on resuming or detaching from
a debug session.

Analysis:
1: "cpu sched clock" are "jiffies A" prior to a call to
kgdb_handle_exception()

2: Debugger waits in kgdb_handle_exception() for 80 seconds, on exit the
following is called touch_softlockup_watchdog().

3: The value of jiffies didn't be updated in kgdb due to the interrupts
were disabled. so the touch_timestamp of the softlockup_watchdog is
still "jiffies A" in the first timer interrupt after resuming from
kgdb_handle_exception.

4: jiffies was updated to "jiffies B" on the tick_do_timer_cpu.
so "jiffies B" = "jiffies A" + 80 seconds.

5: because ("jiffies B" - "jiffies A") >= 60 seconds, then it will trip
 the softlockup warning.

Workaround:
updating jiffies to now on exit from kgdb_handle_exception.

Signed-off-by: Dongdong Deng <dongdong.deng@windriver.com>
---
 include/linux/sched.h     |    4 ++++
 include/linux/tick.h      |    4 ++++
 kernel/kgdb.c             |    3 +++
 kernel/softlockup.c       |   16 ++++++++++++++++
 kernel/time/tick-common.c |    5 +++++
 kernel/time/tick-sched.c  |   27 +++++++++++++++++++++++++++
 6 files changed, 59 insertions(+), 0 deletions(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index b42c488..57e2e2d 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -297,6 +297,7 @@ extern void softlockup_tick(void);
 extern void touch_softlockup_watchdog(void);
 extern void touch_softlockup_watchdog_sync(void);
 extern void touch_all_softlockup_watchdogs(void);
+extern void softlockup_update_jiffies(void);
 extern unsigned int  softlockup_panic;
 extern unsigned long sysctl_hung_task_check_count;
 extern unsigned long sysctl_hung_task_timeout_secs;
@@ -318,6 +319,9 @@ static inline void touch_softlockup_watchdog_sync(void)
 static inline void touch_all_softlockup_watchdogs(void)
 {
 }
+static inline void softlockup_update_jiffies(void)
+{
+}
 #endif
 
 
diff --git a/include/linux/tick.h b/include/linux/tick.h
index 8cf8cfe..9b3416b 100644
--- a/include/linux/tick.h
+++ b/include/linux/tick.h
@@ -69,6 +69,7 @@ struct tick_sched {
 extern void __init tick_init(void);
 extern int tick_is_oneshot_available(void);
 extern struct tick_device *tick_get_device(int cpu);
+extern int get_tick_do_timer_cpu(void); 
 
 # ifdef CONFIG_HIGH_RES_TIMERS
 extern int tick_init_highres(void);
@@ -96,9 +97,11 @@ extern cpumask_t *tick_get_broadcast_oneshot_mask(void);
 extern void tick_clock_notify(void);
 extern int tick_check_oneshot_change(int allow_nohz);
 extern struct tick_sched *tick_get_tick_sched(int cpu);
+extern int tick_update_jiffies(void);
 # else
 static inline void tick_clock_notify(void) { }
 static inline int tick_check_oneshot_change(int allow_nohz) { return 0; }
+static inline int tick_update_jiffies(void) { return 0; }
 # endif
 
 #else /* CONFIG_GENERIC_CLOCKEVENTS */
@@ -106,6 +109,7 @@ static inline void tick_init(void) { }
 static inline void tick_cancel_sched_timer(int cpu) { }
 static inline void tick_clock_notify(void) { }
 static inline int tick_check_oneshot_change(int allow_nohz) { return 0; }
+static inline int get_tick_do_timer_cpu(void) { return 0; }
 #endif /* !CONFIG_GENERIC_CLOCKEVENTS */
 
 # ifdef CONFIG_NO_HZ
diff --git a/kernel/kgdb.c b/kernel/kgdb.c
index 235c3ff..304fb65 100644
--- a/kernel/kgdb.c
+++ b/kernel/kgdb.c
@@ -1565,6 +1565,9 @@ acquirelock:
 	atomic_set(&cpu_in_kgdb[ks->cpu], 0);
 
 	if (!kgdb_single_step) {
+		/* we should set a flag for update jiffy before releasing others cpu */
+		softlockup_update_jiffies();
+
 		for (i = NR_CPUS-1; i >= 0; i--)
 			atomic_set(&passive_cpu_wait[i], 0);
 		/*
diff --git a/kernel/softlockup.c b/kernel/softlockup.c
index 8b24917..80e8033 100644
--- a/kernel/softlockup.c
+++ b/kernel/softlockup.c
@@ -16,6 +16,7 @@
 #include <linux/lockdep.h>
 #include <linux/notifier.h>
 #include <linux/module.h>
+#include <linux/tick.h>
 
 #include <asm/irq_regs.h>
 
@@ -79,6 +80,12 @@ void touch_softlockup_watchdog(void)
 EXPORT_SYMBOL(touch_softlockup_watchdog);
 
 static int softlock_touch_sync[NR_CPUS];
+atomic_t __read_mostly softlock_update_jiffies;
+
+void softlockup_update_jiffies(void)
+{
+	atomic_set(&softlock_update_jiffies, 1);
+}
 
 void touch_softlockup_watchdog_sync(void)
 {
@@ -123,6 +130,15 @@ void softlockup_tick(void)
 			 * make sure the scheduler tick is up to date.
 			 */
 			softlock_touch_sync[this_cpu] = 0;
+
+			if (atomic_read(&softlock_update_jiffies)) {
+				if (get_tick_do_timer_cpu() != this_cpu)
+					return;
+
+				tick_update_jiffies();
+				atomic_set(&softlock_update_jiffies, 0);
+			}
+
 			sched_clock_tick();
 		}
 		__touch_softlockup_watchdog();
diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index bad22e2..60e9bee 100644
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -36,6 +36,11 @@ ktime_t tick_period;
 int tick_do_timer_cpu __read_mostly = TICK_DO_TIMER_BOOT;
 DEFINE_SPINLOCK(tick_device_lock);
 
+int get_tick_do_timer_cpu(void)
+{
+	return tick_do_timer_cpu;
+}
+
 /*
  * Debugging: see timer_list.c
  */
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index cb02324..93f1325 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -83,6 +83,33 @@ static void tick_do_update_jiffies64(ktime_t now)
 }
 
 /*
+ * tick_update_jiffies() - update the global jiffies
+ *
+ * If current CPU is the CPU which responsible for global tick, then
+ * do update the jiffies value. or it will do nothing, and return 1.
+ *	
+ */
+int tick_update_jiffies(void)
+{
+	unsigned long flags;
+	int cpu = smp_processor_id();
+
+	if (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE))
+		tick_do_timer_cpu = cpu;
+
+	/* Check, if the jiffies need an update */
+	if (tick_do_timer_cpu != cpu)
+		return 1;
+
+	/* do update jiffies */
+	local_irq_save(flags);
+	tick_do_update_jiffies64(ktime_get());
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/*
  * Initialize and return retrieve the jiffies update.
  */
 static ktime_t tick_init_jiffy_update(void)
-- 
1.6.3.3

