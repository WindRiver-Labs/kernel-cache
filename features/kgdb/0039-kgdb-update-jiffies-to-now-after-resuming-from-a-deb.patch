From 1bd452ede34513d9baaf59c2aaa79cf7075ca67b Mon Sep 17 00:00:00 2001
From: Dongdong Deng <dongdong.deng@windriver.com>
Date: Mon, 12 Oct 2009 10:19:29 +0800
Subject: [PATCH] kgdb: update jiffies to now after resuming from a debug session

If the sched_clock() was realized based on jiffies, kgdb often
causes softlock warning messages on resuming or detaching from
a debug session.

Analysis:
1: "cpu sched clock" are "jiffies A" prior to a call to
kgdb_handle_exception()

2: Debugger waits in kgdb_handle_exception() for 80 seconds, on exit the
following is called touch_softlockup_watchdog().

3: The value of jiffies didn't be updated in kgdb due to the interrupts
were disabled. so the touch_timestamp of the softlockup_watchdog is
still "jiffies A" in the first timer interrupt after resuming from
kgdb_handle_exception.

4: jiffies was updated to "jiffies B" on the tick_do_timer_cpu.
so "jiffies B" = "jiffies A" + 80 seconds.

5: because ("jiffies B" - "jiffies A") >= 60 seconds, then it will trip
 the softlockup warning.

Workaround:
updating jiffies to now on exit from kgdb_handle_exception.

Signed-off-by: Dongdong Deng <dongdong.deng@windriver.com>
---
 include/linux/sched.h     |    4 ++++
 include/linux/tick.h      |    5 +++++
 kernel/kgdb.c             |   15 +++++++++++++++
 kernel/softlockup.c       |   23 ++++++++++++++++++-----
 kernel/time/tick-common.c |    5 +++++
 kernel/time/tick-sched.c  |   26 ++++++++++++++++++++++++++
 6 files changed, 73 insertions(+), 5 deletions(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index eaee43c..f01fa74 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -297,6 +297,7 @@ extern void softlockup_tick(void);
 extern void touch_softlockup_watchdog(void);
 extern void touch_softlockup_watchdog_sync(void);
 extern void touch_all_softlockup_watchdogs(void);
+extern void softlockup_update_jiffies(void);
 extern unsigned int  softlockup_panic;
 extern unsigned long sysctl_hung_task_check_count;
 extern unsigned long sysctl_hung_task_timeout_secs;
@@ -318,6 +319,9 @@ static inline void touch_softlockup_watchdog_sync(void)
 static inline void touch_all_softlockup_watchdogs(void)
 {
 }
+static inline void softlockup_update_jiffies(void)
+{
+}
 #endif
 
 
diff --git a/include/linux/tick.h b/include/linux/tick.h
index 8cf8cfe..620a372 100644
--- a/include/linux/tick.h
+++ b/include/linux/tick.h
@@ -69,6 +69,7 @@ struct tick_sched {
 extern void __init tick_init(void);
 extern int tick_is_oneshot_available(void);
 extern struct tick_device *tick_get_device(int cpu);
+extern int get_tick_do_timer_cpu(void);
 
 # ifdef CONFIG_HIGH_RES_TIMERS
 extern int tick_init_highres(void);
@@ -96,9 +97,11 @@ extern cpumask_t *tick_get_broadcast_oneshot_mask(void);
 extern void tick_clock_notify(void);
 extern int tick_check_oneshot_change(int allow_nohz);
 extern struct tick_sched *tick_get_tick_sched(int cpu);
+extern int tick_update_jiffies(void);
 # else
 static inline void tick_clock_notify(void) { }
 static inline int tick_check_oneshot_change(int allow_nohz) { return 0; }
+static inline int tick_update_jiffies(void) { return 0; }
 # endif
 
 #else /* CONFIG_GENERIC_CLOCKEVENTS */
@@ -106,6 +109,8 @@ static inline void tick_init(void) { }
 static inline void tick_cancel_sched_timer(int cpu) { }
 static inline void tick_clock_notify(void) { }
 static inline int tick_check_oneshot_change(int allow_nohz) { return 0; }
+static inline int get_tick_do_timer_cpu(void) { return 0; }
+static inline int tick_update_jiffies(void) { return 0; }
 #endif /* !CONFIG_GENERIC_CLOCKEVENTS */
 
 # ifdef CONFIG_NO_HZ
diff --git a/kernel/kgdb.c b/kernel/kgdb.c
index 235c3ff..bbe49bb 100644
--- a/kernel/kgdb.c
+++ b/kernel/kgdb.c
@@ -48,6 +48,7 @@
 #include <linux/pid.h>
 #include <linux/smp.h>
 #include <linux/mm.h>
+#include <linux/tick.h>
 
 #include <asm/cacheflush.h>
 #include <asm/byteorder.h>
@@ -1565,6 +1566,12 @@ acquirelock:
 	atomic_set(&cpu_in_kgdb[ks->cpu], 0);
 
 	if (!kgdb_single_step) {
+		/*
+		 * Set update jiffy flags before releasing
+		 * the others cpu.
+		 */
+		softlockup_update_jiffies();
+
 		for (i = NR_CPUS-1; i >= 0; i--)
 			atomic_set(&passive_cpu_wait[i], 0);
 		/*
@@ -1585,6 +1592,14 @@ kgdb_restore:
 		else
 			kgdb_sstep_pid = 0;
 	}
+
+	/*
+	 * update the jiffies value if the current cpu is the CPU
+	 * which responsible for global tick when kgdb do single setp.
+	 */
+	if (kgdb_single_step && get_tick_do_timer_cpu() == cpu)
+		softlockup_update_jiffies();
+
 	/* Free kgdb_active */
 	atomic_set(&kgdb_active, -1);
 	touch_softlockup_watchdog_sync();
diff --git a/kernel/softlockup.c b/kernel/softlockup.c
index 8b24917..1215d0b 100644
--- a/kernel/softlockup.c
+++ b/kernel/softlockup.c
@@ -16,6 +16,7 @@
 #include <linux/lockdep.h>
 #include <linux/notifier.h>
 #include <linux/module.h>
+#include <linux/tick.h>
 
 #include <asm/irq_regs.h>
 
@@ -79,6 +80,13 @@ void touch_softlockup_watchdog(void)
 EXPORT_SYMBOL(touch_softlockup_watchdog);
 
 static int softlock_touch_sync[NR_CPUS];
+atomic_t __read_mostly softlock_update_jiffies = ATOMIC_INIT(0);
+
+
+void softlockup_update_jiffies(void)
+{
+	atomic_inc(&softlock_update_jiffies);
+}
 
 void touch_softlockup_watchdog_sync(void)
 {
@@ -118,12 +126,17 @@ void softlockup_tick(void)
 
 	if (touch_timestamp == 0) {
 		if (unlikely(softlock_touch_sync[this_cpu])) {
-			/*
-			 * If the time stamp was touched atomically
-			 * make sure the scheduler tick is up to date.
-			 */
-			softlock_touch_sync[this_cpu] = 0;
+			/* make sure the jiffies is up to date. */
+			if (unlikely(atomic_read(&softlock_update_jiffies))) {
+				if (tick_update_jiffies())
+					return;
+				atomic_set(&softlock_update_jiffies, 0);
+			}
+
+			/* make sure the scheduler tick is up to date. */
 			sched_clock_tick();
+
+			softlock_touch_sync[this_cpu] = 0;
 		}
 		__touch_softlockup_watchdog();
 		return;
diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index bad22e2..60e9bee 100644
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -36,6 +36,11 @@ ktime_t tick_period;
 int tick_do_timer_cpu __read_mostly = TICK_DO_TIMER_BOOT;
 DEFINE_SPINLOCK(tick_device_lock);
 
+int get_tick_do_timer_cpu(void)
+{
+	return tick_do_timer_cpu;
+}
+
 /*
  * Debugging: see timer_list.c
  */
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index cb02324..0898427 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -83,6 +83,32 @@ static void tick_do_update_jiffies64(ktime_t now)
 }
 
 /*
+ * tick_update_jiffies() - update the global jiffies
+ *
+ * If current CPU is the CPU which responsible for global tick, then
+ * do update the jiffies value. or it will do nothing, and return 1.
+ */
+int tick_update_jiffies(void)
+{
+	unsigned long flags;
+	int cpu = smp_processor_id();
+
+	if (unlikely(tick_do_timer_cpu == TICK_DO_TIMER_NONE))
+		tick_do_timer_cpu = cpu;
+
+	/* Check, if the jiffies need an update */
+	if (tick_do_timer_cpu != cpu)
+		return 1;
+
+	/* do update jiffies */
+	local_irq_save(flags);
+	tick_do_update_jiffies64(ktime_get());
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/*
  * Initialize and return retrieve the jiffies update.
  */
 static ktime_t tick_init_jiffy_update(void)
-- 
1.6.3.3

