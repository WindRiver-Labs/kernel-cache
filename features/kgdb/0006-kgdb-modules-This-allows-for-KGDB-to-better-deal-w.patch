From bfd1c68ce605fcf0843f9152b4b3bdf0c1434d45 Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Wed, 10 Sep 2008 11:38:24 -0500
Subject: [PATCH] kgdb, modules: This allows for KGDB to better deal with autoloaded modules.

With more information in the kernel, gdb can be modified in such a way
as to automatically read the kernel module section information and
allow for easy kernel module debugging.

In gdb the solib-search-path must contain the location of any module
to be debugged.  When a module is loaded GDB acts like a shared
library has been loaded and will collect the information about the
memory location so the kernel module can be debugged or inspected.

Even when not using kgdb+gdb, it is quite useful for a
debugger+ICE/jtag to have the module section information, which
can be obtained by configure KGDB into the kernel or using
CONFIG_KALLSYMS.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 include/linux/module.h |    8 +++++---
 kernel/kgdb.c          |   18 ++++++++++++++++++
 kernel/module.c        |   35 +++++++++++++++++++++++------------
 lib/Kconfig.kgdb       |    8 ++++++++
 4 files changed, 54 insertions(+), 15 deletions(-)

diff --git a/include/linux/module.h b/include/linux/module.h
index 68e0955..d9ae8e5 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -314,13 +314,15 @@ struct module
 	unsigned int num_symtab;
 	char *strtab;
 
-	/* Section attributes */
-	struct module_sect_attrs *sect_attrs;
-
 	/* Notes attributes */
 	struct module_notes_attrs *notes_attrs;
 #endif
 
+#if defined(CONFIG_KALLSYMS) || defined(CONFIG_KGDB_MODULES)
+	/* Section attributes */
+	struct module_sect_attrs *sect_attrs;
+#endif
+
 	/* Per-cpu data. */
 	void *percpu;
 
diff --git a/kernel/kgdb.c b/kernel/kgdb.c
index 42bf8a3..4f651e8 100644
--- a/kernel/kgdb.c
+++ b/kernel/kgdb.c
@@ -1530,6 +1530,22 @@ kgdb_restore:
 	return error;
 }
 
+/*
+ * GDB places a breakpoint at this function to know dynamically
+ * loaded objects. It's not defined static so that only one instance with this
+ * name exists in the kernel.
+ */
+
+static int module_event(struct notifier_block *self, unsigned long val,
+	void *data)
+{
+	return 0;
+}
+
+static struct notifier_block kgdb_module_load_nb = {
+	.notifier_call	= module_event,
+};
+
 int kgdb_nmicallback(int cpu, void *regs)
 {
 #ifdef CONFIG_SMP
@@ -1627,6 +1643,7 @@ static void kgdb_register_callbacks(void)
 	if (!kgdb_io_module_registered) {
 		kgdb_io_module_registered = 1;
 		kgdb_arch_init();
+		register_module_notifier(&kgdb_module_load_nb);
 		register_reboot_notifier(&kgdb_reboot_notifier);
 #ifdef CONFIG_MAGIC_SYSRQ
 		register_sysrq_key('g', &sysrq_gdb_op);
@@ -1647,6 +1664,7 @@ static void kgdb_unregister_callbacks(void)
 	 */
 	if (kgdb_io_module_registered) {
 		unregister_reboot_notifier(&kgdb_reboot_notifier);
+		unregister_module_notifier(&kgdb_module_load_nb);
 		kgdb_io_module_registered = 0;
 		kgdb_arch_exit();
 #ifdef CONFIG_MAGIC_SYSRQ
diff --git a/kernel/module.c b/kernel/module.c
index 9db1191..1513499 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -633,6 +633,9 @@ static void module_unload_free(struct module *mod)
 			}
 		}
 	}
+	blocking_notifier_call_chain(&module_notify_list,
+				MODULE_STATE_GOING,
+				mod);
 }
 
 #ifdef CONFIG_MODULE_FORCE_UNLOAD
@@ -1048,7 +1051,9 @@ static unsigned long resolve_symbol(Elf_Shdr *sechdrs,
  * /sys/module/foo/sections stuff
  * J. Corbet <corbet@lwn.net>
  */
-#if defined(CONFIG_KALLSYMS) && defined(CONFIG_SYSFS)
+#ifdef CONFIG_SYSFS
+#if (defined(CONFIG_KGDB_MODULES) || defined(CONFIG_KALLSYMS))
+#ifdef CONFIG_KALLSYMS
 struct module_sect_attr
 {
 	struct module_attribute mattr;
@@ -1070,6 +1075,7 @@ static ssize_t module_sect_show(struct module_attribute *mattr,
 		container_of(mattr, struct module_sect_attr, mattr);
 	return sprintf(buf, "0x%lx\n", sattr->address);
 }
+#endif /* CONFIG_KALLSYMS */
 
 static void free_sect_attrs(struct module_sect_attrs *sect_attrs)
 {
@@ -1116,7 +1122,9 @@ static void add_sect_attrs(struct module *mod, unsigned int nsect,
 		if (sattr->name == NULL)
 			goto out;
 		sect_attrs->nsections++;
+#ifdef CONFIG_KALLSYMS
 		sattr->mattr.show = module_sect_show;
+#endif
 		sattr->mattr.store = NULL;
 		sattr->mattr.attr.name = sattr->name;
 		sattr->mattr.attr.mode = S_IRUGO;
@@ -1144,7 +1152,21 @@ static void remove_sect_attrs(struct module *mod)
 		mod->sect_attrs = NULL;
 	}
 }
+#else /* ! (CONFIG_KALLSYMS || CONFIG_KGDB_MODULES) */
+
+static inline void add_sect_attrs(struct module *mod, unsigned int nsect,
+		char *sectstrings, Elf_Shdr *sechdrs)
+{
+}
+
+static inline void remove_sect_attrs(struct module *mod)
+{
+}
 
+#endif /* CONFIG_KALLSYMS || CONFIG_KGDB_MODULES */
+#endif /* CONFIG_SYSFS */
+
+#ifdef CONFIG_KALLSYMS
 /*
  * /sys/module/foo/notes/.section.name gives contents of SHT_NOTE sections.
  */
@@ -1238,18 +1260,7 @@ static void remove_notes_attrs(struct module *mod)
 	if (mod->notes_attrs)
 		free_notes_attrs(mod->notes_attrs, mod->notes_attrs->notes);
 }
-
 #else
-
-static inline void add_sect_attrs(struct module *mod, unsigned int nsect,
-		char *sectstrings, Elf_Shdr *sechdrs)
-{
-}
-
-static inline void remove_sect_attrs(struct module *mod)
-{
-}
-
 static inline void add_notes_attrs(struct module *mod, unsigned int nsect,
 				   char *sectstrings, Elf_Shdr *sechdrs)
 {
diff --git a/lib/Kconfig.kgdb b/lib/Kconfig.kgdb
index 9b5d1d7..230a5d8 100644
--- a/lib/Kconfig.kgdb
+++ b/lib/Kconfig.kgdb
@@ -18,6 +18,14 @@ menuconfig KGDB
 
 if KGDB
 
+config KGDB_MODULES
+	bool "KGDB: Debug modules without KALLSYMS"
+	depends on KGDB && !KALLSYMS && SYSFS
+	default y
+	help
+	  This option allows you to debug kernel modules with a
+	  kernel module aware debugger without using KALLSYMS.
+
 config KGDB_SERIAL_CONSOLE
 	tristate "KGDB: use kgdb over the serial console"
 	select CONSOLE_POLL
-- 
1.5.5.1

