From 73352a9e35bf334b217d729516e7f8d8bb27197c Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Wed, 10 Sep 2008 11:38:25 -0500
Subject: [PATCH] kgdb, serial_core: early init API for kgdb8250

This patch adds an early initialization API for the kgdb8250 driver to
allow an architecture or board specific implementation to debug as
early as possible (IE: right after the uarts and exceptions are
setup).

This patch also allows for the kgdb8250 driver to accept a memory base
instead of a map base for boards that require it.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 Documentation/DocBook/kgdb.tmpl |   63 +++++++++++++++++++++++++++++++++++++-
 drivers/serial/8250_kgdb.c      |   54 +++++++++++++++++++++++++++++----
 drivers/serial/serial_core.c    |   10 +++++-
 include/linux/kgdb8250.h        |   42 ++++++++++++++++++++++++++
 4 files changed, 160 insertions(+), 9 deletions(-)
 create mode 100644 include/linux/kgdb8250.h

diff --git a/Documentation/DocBook/kgdb.tmpl b/Documentation/DocBook/kgdb.tmpl
index d12e508..651d710 100644
--- a/Documentation/DocBook/kgdb.tmpl
+++ b/Documentation/DocBook/kgdb.tmpl
@@ -192,11 +192,13 @@
     <orderedlist>
     <listitem><para>Full serial address specification:
     <itemizedlist>
-    <listitem><para><constant>kgdb8250=&lt;io|mmio&gt;,&lt;address&gt;[/&lt;regshift&gt;],&lt;baud rate&gt;,&lt;irq&gt;</constant></para></listitem>
+    <listitem><para><constant>kgdb8250=&lt;io|mmio|mbase&gt;,&lt;address&gt;[/&lt;regshift&gt;],&lt;baud rate&gt;,&lt;irq&gt;</constant></para></listitem>
     <listitem><para>
     The values <constant>io</constant> or <constant>mmio</constant>
     refer to if the address being passed next needs to be memory
-    mapped (<constant>mmio</constant>) or not.  The
+    mapped (<constant>mmio</constant>) or not.  The mbase (short for
+    membase) parameter is only used if mapbase is set to zero for uart
+    definition, which is the case for some ppc boards.  The
     <constant>address</constant> must be passed in hex and is the
     hardware address and will be remapped if passed as
     <constant>mmio</constant>. An optional
@@ -533,6 +535,63 @@
   going to mean pressing the reset button.
   </para>
   </sect1>
+  <sect1 id="kgdb8250Internals">
+  <title>kgdb8250 API</title>
+  <para>
+  The kgdb8250 driver essentially hijacks a uart for use with kgdb.
+  The aim of the implementation is to provide debugging as early as
+  possible after the exception processing and uarts are initialized.
+  </para>
+  <para>
+  On some architectures or specific boards the kgdb8250 driver's
+  registration needs to be delayed beyond the kernel argument
+  processing time.  With the kgdb8250 driver it is possible to
+  override the default implementation so as to provide a hook to delay
+  the I/O driver registration for kgdb.
+  </para>
+  <para>
+  The following is and example of code that would go into the
+  architecture or board specific implementation to delay the kgdb8250
+  final initialization to the correct time.
+  <programlisting>
+#include &lt;linux/kgdb8250.h&gt;
+
+/* ... other arch or board specific functions ... */
+
+#ifdef CONFIG_KGDB_8250
+static int kgdb8250_ready;
+int kgdb8250_early_debug_ready(void)
+{
+	return kgdb8250_ready;
+}
+#endif
+
+/* This is an example uart init function, the important part is
+ * adding in the part inclusive of the #ifdef
+ */
+void example_uart_init(void)
+{
+
+/* ... uart and exceptions are finally setup ... */
+#ifdef CONFIG_KGDB_8250
+	kgdb8250_ready = 1;
+	kgdb8250_arch_init();
+#endif
+
+/* Note, that if kgdbwait was specified on the
+ * kernel command line the board will stop at this
+ * point and wait for the debugger
+ */
+
+}
+  </programlisting>
+  </para>
+  <para>
+  The API function descriptions follow for kgdb8250_early_debug_ready() and
+  kgdb8250_arch_init().
+  </para>
+!Iinclude/linux/kgdb8250.h
+  </sect1>
   </chapter>
   <chapter id="credits">
      <title>Credits</title>
diff --git a/drivers/serial/8250_kgdb.c b/drivers/serial/8250_kgdb.c
index ea42ea7..84d8d33 100644
--- a/drivers/serial/8250_kgdb.c
+++ b/drivers/serial/8250_kgdb.c
@@ -49,6 +49,9 @@ static struct uart_port kgdb8250_port;
 /* UART port we might have stolen from the 8250 driver */
 static int hijacked_line;
 
+/* Flag for if we need to call request_mem_region */
+static int kgdb8250_needs_request_mem_region;
+
 static int late_init_passed;
 static int fully_initialized;
 static int buffered_char = -1;
@@ -57,6 +60,18 @@ static struct kgdb_io kgdb8250_io_ops;	/* initialized later */
 
 static int kgdb8250_uart_init(void);
 
+#ifdef CONFIG_KGDB_8250
+/* Weak alias in case a particular arch need to implment a specific
+ * point where the serial initialization is completed for early debug.
+ * This is only applicable if the kgdb8250 driver is a built-in.
+ */
+int __weak kgdb8250_early_debug_ready(void)
+{
+	return 1;
+}
+#endif
+
+
 static inline unsigned int kgdb8250_ioread(u8 mask)
 {
 	return ioread8(kgdb8250_addr + (mask << kgdb8250_port.regshift));
@@ -208,7 +223,7 @@ static int kgdb8250_uart_init(void)
 
 /*
  * Syntax for this cmdline option is:
- *   <io|mmio>,<address>[/<regshift>],<baud rate>,<irq> or
+ *   <io|mmio|mbase>,<address>[/<regshift>],<baud rate>,<irq> or
  *   ttyS<n>,<baud rate>
  */
 static int kgdb8250_parse_config(char *str)
@@ -218,6 +233,11 @@ static int kgdb8250_parse_config(char *str)
 	/* Save the option string in case we fail and can retry later. */
 	strncpy(config, str, KGD8250_MAX_CONFIG_STR-1);
 
+#ifdef CONFIG_KGDB_8250
+	if (!kgdb8250_early_debug_ready())
+		return 0;
+#endif
+
 	/* Empty config or leading white space (like LF) means "disabled" */
 	if (!strlen(config) || isspace(config[0]))
 		return 0;
@@ -229,6 +249,10 @@ static int kgdb8250_parse_config(char *str)
 		kgdb8250_port.iotype = UPIO_MEM;
 		kgdb8250_port.flags = UPF_IOREMAP;
 		str += 4;
+	} else if (!strncmp(str, "mbase", 5)) {
+		kgdb8250_port.iotype = UPIO_MEM;
+		kgdb8250_port.flags &= ~UPF_IOREMAP;
+		str += 5;
 	} else if (!strncmp(str, "ttyS", 4)) {
 		str += 4;
 		if (*str < '0' || *str > '9')
@@ -242,7 +266,7 @@ static int kgdb8250_parse_config(char *str)
 			if (late_init_passed)
 				return err;
 			printk(KERN_WARNING "kgdb8250: ttyS%d init delayed, "
-			       "use io/mmio syntax for early init.\n",
+			       "use io/mmio/mbase syntax for early init.\n",
 			       line);
 			return 0;
 		}
@@ -268,9 +292,12 @@ static int kgdb8250_parse_config(char *str)
 
 	if (kgdb8250_port.iotype == UPIO_PORT)
 		kgdb8250_port.iobase = simple_strtoul(str, &str, 16);
-	else
+	else if (kgdb8250_port.flags & UPF_IOREMAP)
 		kgdb8250_port.mapbase =
-			(unsigned long)simple_strtoul(str, &str, 16);
+			(unsigned long) simple_strtoul(str, &str, 16);
+	else
+		kgdb8250_port.membase =
+			(void *) simple_strtoul(str, &str, 16);
 
 	if (*str == '/') {
 		str++;
@@ -304,6 +331,9 @@ static int kgdb8250_early_init(void)
 	/* Internal driver setup. */
 	switch (kgdb8250_port.iotype) {
 	case UPIO_MEM:
+		kgdb8250_needs_request_mem_region = 0;
+		if (kgdb8250_port.mapbase)
+			kgdb8250_needs_request_mem_region = 1;
 		if (kgdb8250_port.flags & UPF_IOREMAP)
 			kgdb8250_port.membase = ioremap(kgdb8250_port.mapbase,
 						8 << kgdb8250_port.regshift);
@@ -354,7 +384,8 @@ static int kgdb8250_late_init(void)
 
 	/* Request memory/io regions that we use. */
 	if (kgdb8250_port.iotype == UPIO_MEM) {
-		if (!request_mem_region(kgdb8250_port.mapbase,
+		if (kgdb8250_needs_request_mem_region &&
+			!request_mem_region(kgdb8250_port.mapbase,
 					8 << kgdb8250_port.regshift, "kgdb"))
 			goto rollback;
 	} else {
@@ -417,7 +448,8 @@ static void kgdb8250_cleanup(void)
 	if (kgdb8250_port.iotype == UPIO_MEM) {
 		if (kgdb8250_port.flags & UPF_IOREMAP)
 			iounmap(kgdb8250_port.membase);
-		release_mem_region(kgdb8250_port.mapbase,
+		if (kgdb8250_needs_request_mem_region)
+			release_mem_region(kgdb8250_port.mapbase,
 				   8 << kgdb8250_port.regshift);
 	} else {
 		ioport_unmap(ioaddr);
@@ -485,5 +517,15 @@ module_param_call(kgdb8250, kgdb8250_set_config, param_get_string, &kps, 0644);
 MODULE_PARM_DESC(kgdb8250, "ttyS<n>,<baud rate>");
 
 #ifdef CONFIG_KGDB_8250
+/* This function can be called for a board that has early debugging
+ * but later than early param processing time.  It is expected that
+ * this function is called as soon as it is permissible for the board
+ * to start taking exceptions and the serial IO mappings are in
+ * place.
+ */
+void kgdb8250_arch_init(void)
+{
+	kgdb8250_parse_config(config);
+}
 early_param("kgdb8250", kgdb8250_parse_config);
 #endif
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index f977c98..73e9b8f 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -2166,7 +2166,13 @@ uart_report_port(struct uart_driver *drv, struct uart_port *port)
 	case UPIO_AU:
 	case UPIO_TSI:
 	case UPIO_DWAPB:
-		snprintf(address, sizeof(address),
+		if (port->mapbase == 0)
+			snprintf(address, sizeof(address),
+			 "MMIO 0x%llx membase %p",
+			 (unsigned long long)port->mapbase,
+			 port->membase);
+		else
+			snprintf(address, sizeof(address),
 			 "MMIO 0x%llx", (unsigned long long)port->mapbase);
 		break;
 	default:
@@ -2580,6 +2586,8 @@ int uart_match_port(struct uart_port *port1, struct uart_port *port2)
 	case UPIO_AU:
 	case UPIO_TSI:
 	case UPIO_DWAPB:
+		if (port1->mapbase == 0 && port2->mapbase == 0)
+			return (port1->membase == port2->membase);
 		return (port1->mapbase == port2->mapbase);
 	}
 	return 0;
diff --git a/include/linux/kgdb8250.h b/include/linux/kgdb8250.h
new file mode 100644
index 0000000..74f46f8
--- /dev/null
+++ b/include/linux/kgdb8250.h
@@ -0,0 +1,42 @@
+/*
+ * This header specifies the early debug hooks for the kgdb8250
+ * driver, which can be implemented per arch and per board.
+ *
+ * Author: Jason Wessel <jason.wessel@windriver.com>
+ *
+ * 2008 (c) Wind River System, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+#ifndef _KGDB8250_H_
+#define _KGDB8250_H_
+
+#include <linux/kgdb.h>
+
+/**
+ * kgdb8250_early_debug_ready - indicates when it safe to issue uart I/O
+ *
+ * This function should return 1 when it is safe to read and write
+ * to the uart.  By default this is a weak alias which always returns
+ * true, unless overriden by an architecture or board specific
+ * implementation.  This is overriden in case that uart I/O is only
+ * available some time after early kernel parameter processing.
+ */
+extern int kgdb8250_early_debug_ready(void);
+
+/**
+ * kgdb8250_arch_init - active early debugging, if configured
+ *
+ * This function must be implemented and called in the architecture or
+ * board specific code if kgdb8250_early_debug_ready() is implemented.
+ * This function should be called as soon as the board is able to
+ * process exceptions and the uart is setup for reading and writing.
+ * This function will invoke the kgdb I/O driver registration routines
+ * and immediately wait for the debugger if kgdbwait was specified on
+ * the kernel command line.
+ */
+extern void kgdb8250_arch_init(void);
+
+#endif /* _KGDB8250_H_ */
-- 
1.5.5.1

