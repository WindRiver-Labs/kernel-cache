From 4e0a33c6c5c23086682e392333f9d182d26c8de3 Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Thu, 9 Jun 2011 16:54:21 -0500
Subject: [PATCH] kgdboc: fix lost characters with scheduled breakpoint

When using the rx_poll api to snoop a tty session for the '$'
character or a control-c, a break point is scheduled when either
character is detected.  All of the data must then go into the queue up
until kgdb is fully entered.

Prior to this patch these characters would be lost and as a result the
debugger connection sequences for gdb would end up timing out or have
a retry or sometimes occasionally complete failure to connect.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 drivers/serial/kgdboc.c   |   19 +++++++++++--------
 include/linux/kgdb.h      |    1 +
 kernel/debug/debug_core.c |    6 ++++++
 kernel/debug/gdbstub.c    |    1 +
 4 files changed, 19 insertions(+), 8 deletions(-)

diff --git a/drivers/serial/kgdboc.c b/drivers/serial/kgdboc.c
index 451ac63..70621be 100644
--- a/drivers/serial/kgdboc.c
+++ b/drivers/serial/kgdboc.c
@@ -108,7 +108,8 @@ static int schedule_breakpoints;
  */
 static int kgdboc_rx_callback(u8 c)
 {
-	if (likely(atomic_read(&kgdb_active) == -1)) {
+	if (likely(atomic_read(&kgdb_active) == -1 &&
+		   !kgdb_is_waiting_on_breakpoint())) {
 		if (no_polled_breaks)
 			return 0;
 		if (c == break_char ||
@@ -234,6 +235,8 @@ do_register:
 		goto noconfig;
 
 	configured = 1;
+	ch_head = 0;
+	ch_tail = 0;
 
 	return 0;
 
@@ -273,11 +276,6 @@ static int kgdboc_get_char(void)
 	if (buffered_char >= 0)
 		return xchg(&buffered_char, -1);
 
-	ret = kgdb_tty_driver->ops->poll_get_char(kgdb_tty_driver,
-						  kgdb_tty_line);
-	if (ret != -2)
-		return ret;
-
 	/* A return of -2 means use the poll character ring */
 	if (ch_head != ch_tail) {
 		ret = ch_ring[ch_head];
@@ -287,6 +285,11 @@ static int kgdboc_get_char(void)
 		return ret;
 	}
 
+	ret = kgdb_tty_driver->ops->poll_get_char(kgdb_tty_driver,
+						  kgdb_tty_line);
+	if (ret != -2)
+		return ret;
+
 	return -1;
 }
 
@@ -348,8 +351,6 @@ static void kgdboc_pre_exp_handler(void)
 	/* Increment the module count when the debugger is active */
 	if (!kgdb_connected)
 		try_module_get(THIS_MODULE);
-	ch_head = 0;
-	ch_tail = 0;
 }
 
 static void kgdboc_post_exp_handler(void)
@@ -366,6 +367,8 @@ static void kgdboc_post_exp_handler(void)
 			dbg_post_vt_hook();
 		}
 	}
+	ch_head = 0;
+	ch_tail = 0;
 	kgdboc_clear_kbd();
 }
 
diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 1a908fb..aad7a1b 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -292,6 +292,7 @@ extern int kgdb_hex2mem(char *buf, char *mem, int count);
 
 extern int kgdb_isremovedbreak(unsigned long addr);
 extern void kgdb_schedule_breakpoint(void);
+extern int kgdb_is_waiting_on_breakpoint(void);
 
 extern int
 kgdb_handle_exception(int ex_vector, int signo, int err_code,
diff --git a/kernel/debug/debug_core.c b/kernel/debug/debug_core.c
index ebd3510..220e708 100644
--- a/kernel/debug/debug_core.c
+++ b/kernel/debug/debug_core.c
@@ -906,6 +906,12 @@ void kgdb_schedule_breakpoint(void)
 }
 EXPORT_SYMBOL_GPL(kgdb_schedule_breakpoint);
 
+int kgdb_is_waiting_on_breakpoint(void)
+{
+	return atomic_read(&kgdb_break_tasklet_var);
+}
+EXPORT_SYMBOL_GPL(kgdb_is_waiting_on_breakpoint);
+
 static void kgdb_initial_breakpoint(void)
 {
 	kgdb_break_asap = 0;
diff --git a/kernel/debug/gdbstub.c b/kernel/debug/gdbstub.c
index 6dce035..0d64633 100644
--- a/kernel/debug/gdbstub.c
+++ b/kernel/debug/gdbstub.c
@@ -1163,6 +1163,7 @@ int gdbstub_state(struct kgdb_state *ks, char *cmd)
 	case 'c':
 		strcpy(remcom_in_buffer, cmd);
 		return 0;
+	case '+':
 	case '$':
 		strcpy(remcom_in_buffer, cmd);
 		gdbstub_use_prev_in_buf = strlen(remcom_in_buffer);
-- 
1.7.0.4

