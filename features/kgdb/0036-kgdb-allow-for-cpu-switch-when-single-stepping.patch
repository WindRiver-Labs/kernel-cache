From e2b9dad7b28c89c054c809f0fb55162f67aad0fc Mon Sep 17 00:00:00 2001
From: DDD <Dongdong.deng@windriver.com>
Date: Fri, 28 Aug 2009 16:06:53 +0800
Subject: [PATCH 36/36] kgdb: allow for cpu switch when single stepping

Message-Id: <615274efac8c8099d1b09d249bb6e774f5b870f8.1251443149.git.dongdong.deng@windriver.com>
In-Reply-To: <6939b7131b37f487e96b9dc0ee52bb786033cd3d.1251443149.git.dongdong.deng@windriver.com>
References: <6939b7131b37f487e96b9dc0ee52bb786033cd3d.1251443149.git.dongdong.deng@windriver.com>
The kgdb core should not assume that a single step operation of a
kernel thread will complete on the same CPU.  The single step flag is
set at the "thread" level and it is possible in a multi cpu system
that a kernel thread can get scheduled on another cpu the next time it
run.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Integrated-off-by: Dongdong Deng <dongdong.deng@windriver.com>
---
 kernel/kgdb.c |   14 +++++++++++---
 1 files changed, 11 insertions(+), 3 deletions(-)

diff --git a/kernel/kgdb.c b/kernel/kgdb.c
index 86ba25e..235c3ff 100644
--- a/kernel/kgdb.c
+++ b/kernel/kgdb.c
@@ -135,6 +135,7 @@ struct task_struct		*kgdb_usethread;
 struct task_struct		*kgdb_contthread;
 
 int				kgdb_single_step;
+pid_t				kgdb_sstep_pid;
 
 /* Our I/O buffers. */
 static char			remcom_in_buffer[BUFMAX];
@@ -1482,9 +1483,9 @@ acquirelock:
 	 * debugger on a different CPU via a single step
 	 */
 	if (kgdb_single_step &&
-		 atomic_read(&kgdb_cpu_doing_single_step) != -1 &&
-	    atomic_read(&kgdb_cpu_doing_single_step) != cpu) {
-
+			atomic_read(&kgdb_cpu_doing_single_step) != -1 &&
+			kgdb_info[cpu].task &&
+			kgdb_info[cpu].task->pid != kgdb_sstep_pid) {
 		atomic_set(&kgdb_active, -1);
 		touch_softlockup_watchdog_sync();
 		clocksource_touch_watchdog();
@@ -1577,6 +1578,13 @@ acquirelock:
 	}
 
 kgdb_restore:
+	if (atomic_read(&kgdb_cpu_doing_single_step) != -1) {
+		int sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);
+		if (kgdb_info[sstep_cpu].task)
+			kgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;
+		else
+			kgdb_sstep_pid = 0;
+	}
 	/* Free kgdb_active */
 	atomic_set(&kgdb_active, -1);
 	touch_softlockup_watchdog_sync();
-- 
1.6.3.3

