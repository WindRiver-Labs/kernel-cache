From 7985c638d30dc66118765534fe2200bdc94c0e1c Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Wed, 11 Feb 2009 18:46:32 -0600
Subject: [PATCH 03/34] usb-serial,sysrq: Run the sysrq handler in a tasklet

If a sysrq is processed on the while holding the usb hcd lock, it is
impossible to drain the queue of urbs via the polling interface and
all the printk output is lost.

Using a tasklet to schedule the sysrq allows the hcd device lock to
free up, and you can issue a sysrq-t to get the task list.

CC: Greg Kroah-Hartman <gregkh@suse.de>
CC: Alan Cox <alan@linux.intel.com>
CC: Alan Stern <stern@rowland.harvard.edu>
CC: linux-usb@vger.kernel.org
Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Signed-off-by: He Zhe <zhe.he@windriver.com>
---
 drivers/tty/sysrq.c          | 27 +++++++++++++++++++++++++++
 drivers/usb/serial/generic.c |  2 +-
 include/linux/sysrq.h        |  4 ++++
 3 files changed, 32 insertions(+), 1 deletion(-)

diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c
index ce396ec..c04c7f6 100644
--- a/drivers/tty/sysrq.c
+++ b/drivers/tty/sysrq.c
@@ -1068,6 +1068,33 @@ int unregister_sysrq_key(int key, struct sysrq_key_op *op_p)
 }
 EXPORT_SYMBOL(unregister_sysrq_key);
 
+/* The sysrq tasklet is used only in the rare case that an
+ * input/output character device processes a sysrq in its input
+ * routine while holding a lock required for the output routine for
+ * the console device.
+ */
+static struct sysrq_tasklet_data {
+	unsigned int key;
+	int pending;
+} priv_sysrq_data;
+
+static void sysrq_task(unsigned long args)
+{
+	handle_sysrq(priv_sysrq_data.key);
+	priv_sysrq_data.pending = 0;
+}
+static DECLARE_TASKLET(sysrq_tasklet, sysrq_task, 0);
+
+void handle_sysrq_tasklet(int key)
+{
+	if (priv_sysrq_data.pending)
+		return;
+	priv_sysrq_data.pending = 1;
+	priv_sysrq_data.key = key;
+	tasklet_schedule(&sysrq_tasklet);
+}
+EXPORT_SYMBOL(handle_sysrq_tasklet);
+
 #ifdef CONFIG_PROC_FS
 /*
  * writing 'C' to /proc/sysrq-trigger is like sysrq-C
diff --git a/drivers/usb/serial/generic.c b/drivers/usb/serial/generic.c
index b63ce02..cb21299 100644
--- a/drivers/usb/serial/generic.c
+++ b/drivers/usb/serial/generic.c
@@ -518,7 +518,7 @@ int usb_serial_handle_sysrq_char(struct usb_serial_port *port, unsigned int ch)
 {
 	if (port->sysrq && port->port.console) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch);
+			handle_sysrq_tasklet(ch);
 			port->sysrq = 0;
 			return 1;
 		}
diff --git a/include/linux/sysrq.h b/include/linux/sysrq.h
index 387fa7d..26dda5f 100644
--- a/include/linux/sysrq.h
+++ b/include/linux/sysrq.h
@@ -42,6 +42,7 @@ struct sysrq_key_op {
  * are available -- else NULL's).
  */
 
+void handle_sysrq_tasklet(int key);
 void handle_sysrq(int key);
 void __handle_sysrq(int key, bool check_mask);
 int register_sysrq_key(int key, struct sysrq_key_op *op);
@@ -69,6 +70,9 @@ static inline int unregister_sysrq_key(int key, struct sysrq_key_op *op)
 {
 	return -EINVAL;
 }
+static inline void handle_sysrq_tasklet(int key)
+{
+}
 
 #endif
 
-- 
2.0.2

