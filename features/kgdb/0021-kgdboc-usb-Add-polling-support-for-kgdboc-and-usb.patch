From 4be7d65e4635a2d03224f4c02b54e52400bcd0d7 Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Mon, 3 Nov 2008 12:41:38 -0600
Subject: [PATCH] kgdboc, usb: Add polling support for kgdboc and usb serial

Add polling support to the USB serial driver and kgdboc.

For the USB polling support to work the usb interrupt routine is
called while the kernel is stopped in kgdb.  This will be called withe
interrupts disabled as well as all of the CPUs being halted.  This
might not work so well on an SMP system...

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 drivers/usb/serial/ftdi_sio.c   |   21 +++++++-
 drivers/usb/serial/pl2303.c     |   29 +++++++++
 drivers/usb/serial/usb-serial.c |  120 +++++++++++++++++++++++++++++++++++++++
 include/linux/usb/serial.h      |    8 +++
 4 files changed, 177 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c
index 3dc93b5..ba38cee 100644
--- a/drivers/usb/serial/ftdi_sio.c
+++ b/drivers/usb/serial/ftdi_sio.c
@@ -723,6 +723,9 @@ static int  ftdi_ioctl(struct tty_struct *tty, struct file *file,
 static void ftdi_break_ctl(struct tty_struct *tty, int break_state);
 static void ftdi_throttle(struct tty_struct *tty);
 static void ftdi_unthrottle(struct tty_struct *tty);
+#ifdef CONFIG_CONSOLE_POLL
+static int ftdi_poll_get_char(struct usb_serial_port *port);
+#endif
 
 static unsigned short int ftdi_232am_baud_base_to_divisor(int baud, int base);
 static unsigned short int ftdi_232am_baud_to_divisor(int baud);
@@ -756,6 +759,9 @@ static struct usb_serial_driver ftdi_sio_device = {
 	.set_termios =		ftdi_set_termios,
 	.break_ctl =		ftdi_break_ctl,
 	.shutdown =		ftdi_shutdown,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_get_char = ftdi_poll_get_char,
+#endif
 };
 
 
@@ -1841,6 +1847,13 @@ static void ftdi_read_bulk_callback(struct urb *urb)
 
 } /* ftdi_read_bulk_callback */
 
+#ifdef CONFIG_CONSOLE_POLL
+static int ftdi_poll_get_char(struct usb_serial_port *port)
+{
+	/* Indicate this driver requires high level polling */
+	return -2;
+}
+#endif /* CONFIG_CONSOLE_POLL */
 
 static void ftdi_process_read(struct work_struct *work)
 { /* ftdi_process_read */
@@ -1961,14 +1974,20 @@ static void ftdi_process_read(struct work_struct *work)
 			dbg("FRAMING error");
 		}
 		if (length > 0) {
+			need_flip = 1;
 			for (i = 2; i < length+2; i++) {
 				/* Note that the error flag is duplicated for
 				   every character received since we don't know
 				   which character it applied to */
+#ifdef CONFIG_CONSOLE_POLL
+				if (port->poll_rx_cb &&
+				    port->poll_rx_cb(data[packet_offset + i]))
+					need_flip = 0;
+				else
+#endif
 				tty_insert_flip_char(tty,
 					data[packet_offset + i], error_flag);
 			}
-			need_flip = 1;
 		}
 
 #ifdef NOT_CORRECT_BUT_KEEPING_IT_FOR_NOW
diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1ede144..00a81a4 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -997,6 +997,20 @@ exit:
 			__func__, retval);
 }
 
+#ifdef CONFIG_CONSOLE_POLL
+static int pl2303_proc_pollrx(struct usb_serial_port *port,
+			      unsigned char *data, int count)
+{
+	int char_consumed = 0;
+	int i;
+
+	for (i = 0; i < count; i++)
+		if (port->poll_rx_cb(data[i]))
+			char_consumed = 1;
+	return char_consumed;
+}
+#endif
+
 static void pl2303_read_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port *port =  urb->context;
@@ -1058,6 +1072,10 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	dbg("%s - tty_flag = %d", __func__, tty_flag);
 
 	tty = port->port.tty;
+#ifdef CONFIG_CONSOLE_POLL
+	if (!(port->poll_rx_cb &&
+	      pl2303_proc_pollrx(port, data, urb->actual_length)))
+#endif
 	if (tty && urb->actual_length) {
 		tty_buffer_request_room(tty, urb->actual_length + 1);
 		/* overrun is special, not associated with a char */
@@ -1122,6 +1140,14 @@ static void pl2303_write_bulk_callback(struct urb *urb)
 	pl2303_send(port);
 }
 
+#ifdef CONFIG_CONSOLE_POLL
+static int pl2303_poll_get_char(struct usb_serial_port *port)
+{
+	/* Indicate this driver requires high level polling */
+	return -2;
+}
+#endif /* CONFIG_CONSOLE_POLL */
+
 /* All of the device info needed for the PL2303 SIO serial converter */
 static struct usb_serial_driver pl2303_device = {
 	.driver = {
@@ -1146,6 +1172,9 @@ static struct usb_serial_driver pl2303_device = {
 	.chars_in_buffer =	pl2303_chars_in_buffer,
 	.attach =		pl2303_startup,
 	.shutdown =		pl2303_shutdown,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_get_char = pl2303_poll_get_char,
+#endif
 };
 
 static int __init pl2303_init(void)
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 4f7f9e3..c3390cc 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -32,6 +32,7 @@
 #include <linux/uaccess.h>
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
+#include "../core/hcd.h"
 #include "pl2303.h"
 
 /*
@@ -1082,6 +1083,120 @@ int usb_serial_resume(struct usb_interface *intf)
 }
 EXPORT_SYMBOL(usb_serial_resume);
 
+#ifdef CONFIG_CONSOLE_POLL
+static int serial_poll_init(struct tty_driver *driver, int line,
+		char *options, void *rx_callback)
+{
+	struct usb_serial *serial;
+	struct usb_serial_port *port;
+
+	/* TODO: Speed initialization is not implemented here, it must be
+	 * attached to an open console to use it at boot, or with an stty
+	 * command from the user space
+	 */
+	serial = usb_serial_get_by_index(line);
+	if (!serial)
+		return -1;
+
+	if (!serial->type->poll_get_char)
+		return -1;
+
+	port = serial->port[line - serial->minor];
+	if (rx_callback)
+		port->poll_rx_cb = rx_callback;
+
+	return 0;
+}
+
+static int serial_poll_get_char(struct tty_driver *driver, int line)
+{
+	struct usb_serial *serial;
+	struct usb_serial_port *port;
+	struct usb_hcd *hcd;
+	struct urb *urb;
+	int ret = -1;
+
+	serial = usb_serial_get_by_index(line);
+	if (!serial)
+		return -1;
+
+	port = serial->port[line - serial->minor];
+
+	if (serial->type->poll_get_char)
+		ret = serial->type->poll_get_char(port);
+	if (ret != -2)
+		return ret;
+	/*
+	 * -2 indicates that low level driver wants the interrupt
+	 * service routine to be polled in order to service character
+	 * poll requests.  This involves making a direct request to
+	 * the HCD.
+	 */
+	urb = port->read_urb;
+	if (!urb) {
+		printk("%s - bad read_urb pointer - exiting", __func__);
+		return -1;
+	}
+
+	hcd = bus_to_hcd(urb->dev->bus);
+	if (hcd)
+		usb_hcd_irq(0, hcd);
+
+	return ret;
+}
+
+static void serial_poll_put_char(struct tty_driver *driver, int line, char ch)
+{
+	struct usb_serial *serial;
+	struct usb_serial_port *port;
+	struct usb_hcd *hcd;
+	struct urb *urb;
+	int failcnt;
+	char buf[2];
+	int retval;
+
+	serial = usb_serial_get_by_index(line);
+	if (!serial)
+		return;
+
+	if (serial->dev->state == USB_STATE_NOTATTACHED)
+		return;
+
+	port = serial->port[line - serial->minor];
+
+	if (!port->port.count)
+		return;
+
+	buf[0] = ch;
+
+	retval = 0;
+	failcnt = 100000;
+	urb = port->read_urb;
+	if (!urb) {
+		printk(KERN_CRIT "%s - bad read_urb pointer - exiting", __func__);
+		return;
+	}
+	hcd = bus_to_hcd(urb->dev->bus);
+	/* Perform the chip level write */
+	while (failcnt) {
+		if (serial->type->write)
+			retval = serial->type->write(NULL, port, buf, 1);
+		else
+			retval = usb_serial_generic_write(NULL, port, buf, 1);
+		if (retval == 1)
+			break;
+		/* Run the hcd device to clear out extra packets */
+		if (hcd)
+			usb_hcd_irq(0, hcd);
+		failcnt--;
+	}
+	if (retval <= 0)
+		printk(KERN_CRIT "USB-SERIAL: error writing '%c' to port\n", ch);
+
+	return;
+}
+#endif
+
 static const struct tty_operations serial_ops = {
 	.open =			serial_open,
 	.close =		serial_close,
@@ -1096,6 +1211,11 @@ static const struct tty_operations serial_ops = {
 	.read_proc =		serial_read_proc,
 	.tiocmget =		serial_tiocmget,
 	.tiocmset =		serial_tiocmset,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_init	= serial_poll_init,
+	.poll_get_char	= serial_poll_get_char,
+	.poll_put_char	= serial_poll_put_char,
+#endif
 };
 
 struct tty_driver *usb_serial_tty_driver;
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 655341d..d89a60d 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -57,6 +57,7 @@
  * @open_count: number of times this port has been opened.
  * @throttled: nonzero if the read urb is inactive to throttle the device
  * @throttle_req: nonzero if the tty wants to throttle us
+ * @poll_rx_cb: Optional console polling callback routine
  *
  * This structure is used by the usb-serial core and drivers for the specific
  * ports of a device.
@@ -94,6 +95,10 @@ struct usb_serial_port {
 	char			throttle_req;
 	char			console;
 	struct device		dev;
+#ifdef CONFIG_CONSOLE_POLL
+	int	(*poll_rx_cb)(u8);
+#endif
+
 };
 #define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)
 
@@ -242,6 +247,9 @@ struct usb_serial_driver {
 	void (*write_int_callback)(struct urb *urb);
 	void (*read_bulk_callback)(struct urb *urb);
 	void (*write_bulk_callback)(struct urb *urb);
+#ifdef CONFIG_CONSOLE_POLL
+	int (*poll_get_char)(struct usb_serial_port *port);
+#endif
 };
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
-- 
1.6.0.90.g436ed

