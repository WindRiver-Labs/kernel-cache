From 07ffedce70d7a1af80b779956604b84db1e5346a Mon Sep 17 00:00:00 2001
From: DDD <dongdong.deng@windriver.com>
Date: Wed, 28 Oct 2009 19:20:59 +0800
Subject: [PATCH] mips kgdb: add low level debug hook

The only way the debugger can handle a trap in inside notify_die,
or atomic_notifier_call_chain without a recursive fault is to have
a low level "first opportunity handler" do_trap_or_bp() handler.

After the debugger is done, the standard system rules will be in play
for the original exception.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Integrated-by: Dongdong Deng <dongdong.deng@windriver.com>
---
 arch/mips/kernel/kgdb.c  |   26 ++++++++++++++++++++++++++
 arch/mips/kernel/traps.c |    6 ++++++
 include/asm-mips/kgdb.h  |    3 +++
 include/linux/kgdb.h     |    1 +
 kernel/kgdb.c            |    2 +-
 5 files changed, 37 insertions(+), 1 deletions(-)

diff --git a/arch/mips/kernel/kgdb.c b/arch/mips/kernel/kgdb.c
index bc3a8b6..305b212 100644
--- a/arch/mips/kernel/kgdb.c
+++ b/arch/mips/kernel/kgdb.c
@@ -221,6 +221,17 @@ static int kgdb_mips_notify(struct notifier_block *self, unsigned long cmd,
 	if (user_mode(regs))
 		return NOTIFY_DONE;
 
+	/*
+	 * Only process the die trap if it did not come through the
+	 * notifier, because we only want to process it once and the
+	 * debugger gets the first crack at the die trap processing when
+	 * it is active via the kgdb_ll_trap() callback
+	 */
+
+	if (self && cmd == DIE_TRAP)
+		return NOTIFY_DONE;
+
+
 	if (atomic_read(&kgdb_active) != -1)
 		kgdb_nmicallback(smp_processor_id(), regs);
 
@@ -280,6 +291,21 @@ static int kgdb_mips_notify(struct notifier_block *self, unsigned long cmd,
 	return NOTIFY_STOP;
 }
 
+int kgdb_ll_trap(int cmd, const char *str,
+			    struct pt_regs *regs, long err, int trap, int sig)
+{
+	struct die_args args = {
+		.regs   = regs,
+		.str    = str,
+		.err    = err,
+		.trapnr = trap,
+		.signr  = sig,
+
+	};
+
+	return kgdb_mips_notify(NULL, cmd, &args);
+}
+
 static struct notifier_block kgdb_notifier = {
 	.notifier_call = kgdb_mips_notify,
 };
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 6fa59ac..0648874 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -698,6 +698,12 @@ static void do_trap_or_bp(struct pt_regs *regs, unsigned int code,
 	siginfo_t info;
 	char b[40];
 
+#ifdef CONFIG_KGDB
+	if (kgdb_io_module_registered &&
+			kgdb_ll_trap(DIE_TRAP, str, regs, code, 0, 0) == NOTIFY_STOP)
+		return;
+#endif
+
 	if (notify_die(DIE_TRAP, str, regs, code, 0, 0) == NOTIFY_STOP)
 		return;
 
diff --git a/include/asm-mips/kgdb.h b/include/asm-mips/kgdb.h
index 48223b0..7677267 100644
--- a/include/asm-mips/kgdb.h
+++ b/include/asm-mips/kgdb.h
@@ -39,6 +39,9 @@ extern void *saved_vectors[32];
 extern void handle_exception(struct pt_regs *regs);
 extern void breakinst(void);
 
+extern int kgdb_ll_trap(int cmd, const char *str,
+		struct pt_regs *regs, long err, int trap, int sig);
+
 #endif				/* __KERNEL__ */
 
 #endif /* __ASM_KGDB_H_ */
diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 3df90af..5587156 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -73,6 +73,7 @@ struct uart_port;
 void kgdb_breakpoint(void);
 
 extern int kgdb_connected;
+extern int kgdb_io_module_registered;
 
 extern atomic_t			kgdb_setting_breakpoint;
 extern atomic_t			kgdb_cpu_doing_single_step;
diff --git a/kernel/kgdb.c b/kernel/kgdb.c
index bbe49bb..e3f7072 100644
--- a/kernel/kgdb.c
+++ b/kernel/kgdb.c
@@ -86,7 +86,7 @@ int				kgdb_connected;
 EXPORT_SYMBOL_GPL(kgdb_connected);
 
 /* All the KGDB handlers are installed */
-static int			kgdb_io_module_registered;
+int			kgdb_io_module_registered;
 
 /* Guard for recursive entry */
 static int			exception_level;
-- 
1.6.5.2

