From 56274705bcdd5f0784421316a4689e6232fa3e7f Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Fri, 25 Feb 2011 17:08:01 -0600
Subject: [PATCH] x86,kgdb,immediate: Fix race condition between dynamic trap handlers

In some instances kgdb can catch a trap that was intended for the
dynamically registered immediate int3 handler.  A special case is
needed in the kgdb trap handler to ignore this condition to avoid a
crash for an improperly handled exception.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 arch/x86/include/asm/immediate.h |    2 ++
 arch/x86/kernel/immediate.c      |    6 ++++--
 arch/x86/kernel/kgdb.c           |    7 +++++++
 3 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/arch/x86/include/asm/immediate.h b/arch/x86/include/asm/immediate.h
index 14f30ec..ed8c012 100644
--- a/arch/x86/include/asm/immediate.h
+++ b/arch/x86/include/asm/immediate.h
@@ -108,5 +108,7 @@ struct __imv {
 	})
 
 extern int arch_imv_update(const struct __imv *imv, int early);
+extern unsigned long bypass_after_int3;
+extern unsigned long target_after_int3;
 
 #endif /* _ASM_X86_IMMEDIATE_H */
diff --git a/arch/x86/kernel/immediate.c b/arch/x86/kernel/immediate.c
index 5d77ac3..4d5b0b9 100644
--- a/arch/x86/kernel/immediate.c
+++ b/arch/x86/kernel/immediate.c
@@ -101,9 +101,9 @@
 #define BREAKPOINT_INS_LEN	1
 #define NR_NOPS			10
 
-static unsigned long target_after_int3;	/* EIP of the target after the int3 */
+unsigned long target_after_int3;	/* EIP of the target after the int3 */
 static unsigned long bypass_eip;	/* EIP of the bypass. */
-static unsigned long bypass_after_int3;	/* EIP after the end-of-bypass int3 */
+unsigned long bypass_after_int3;	/* EIP after the end-of-bypass int3 */
 static unsigned long after_imv;	/*
 					 * EIP where to resume after the
 					 * single-stepping.
@@ -295,6 +295,8 @@ __kprobes int arch_imv_update(const struct __imv *imv, int early)
 		synchronize_sched();
 		unregister_die_notifier(&imv_notify);
 		/* unregister_die_notifier has memory barriers */
+		target_after_int3 = 0;
+		bypass_after_int3 = 0;
 	} else
 		text_poke_early((void *)imv->imv, (void *)imv->var,
 			imv->size);
diff --git a/arch/x86/kernel/kgdb.c b/arch/x86/kernel/kgdb.c
index 465e0e5..42ac846 100644
--- a/arch/x86/kernel/kgdb.c
+++ b/arch/x86/kernel/kgdb.c
@@ -577,6 +577,13 @@ static int __kgdb_notify(struct die_args *args, unsigned long cmd)
 			return NOTIFY_DONE;
 	}
 
+#ifdef CONFIG_IMMEDIATE
+	if (cmd == DIE_INT3 &&
+		((target_after_int3 && target_after_int3 == regs->ip) ||
+		 (bypass_after_int3 && bypass_after_int3 == regs->ip)))
+		return NOTIFY_DONE;
+#endif /* CONFIG_USE_IMMEDIATE */
+
 	if (kgdb_handle_exception(args->trapnr, args->signr, cmd, regs))
 		return NOTIFY_DONE;
 
-- 
1.6.5.2

