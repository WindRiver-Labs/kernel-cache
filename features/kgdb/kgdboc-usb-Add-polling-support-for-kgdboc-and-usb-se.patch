From 20d7c17e876c6a09998178ebcc59fe34b2d9036a Mon Sep 17 00:00:00 2001
From: Jason Wessel <jason.wessel@windriver.com>
Date: Fri, 10 Aug 2012 22:24:46 -0500
Subject: [PATCH 13/31] kgdboc, usb: Add polling support for kgdboc and usb
 serial

Add polling support to the USB serial driver and kgdboc.

For the USB polling support to work the usb interrupt routine is
called while the kernel is stopped in kgdb.  This will be called with
interrupts disabled as well as all of the CPUs being halted.  This
might not work so well on an SMP system...

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
---
 drivers/usb/serial/ftdi_sio.c   |   23 ++++++-
 drivers/usb/serial/pl2303.c     |   25 ++++++-
 drivers/usb/serial/usb-serial.c |  137 +++++++++++++++++++++++++++++++++++++++
 include/linux/usb/serial.h      |    7 ++
 4 files changed, 189 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c
index 53e3e2c..48fb002 100644
--- a/drivers/usb/serial/ftdi_sio.c
+++ b/drivers/usb/serial/ftdi_sio.c
@@ -912,6 +912,9 @@ static int ftdi_get_icount(struct tty_struct *tty,
 static int  ftdi_ioctl(struct tty_struct *tty,
 			unsigned int cmd, unsigned long arg);
 static void ftdi_break_ctl(struct tty_struct *tty, int break_state);
+#ifdef CONFIG_CONSOLE_POLL
+static int ftdi_poll_get_char(struct usb_serial_port *port);
+#endif
 
 static unsigned short int ftdi_232am_baud_base_to_divisor(int baud, int base);
 static unsigned short int ftdi_232am_baud_to_divisor(int baud);
@@ -946,6 +949,9 @@ static struct usb_serial_driver ftdi_sio_device = {
 	.ioctl =		ftdi_ioctl,
 	.set_termios =		ftdi_set_termios,
 	.break_ctl =		ftdi_break_ctl,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_get_char = ftdi_poll_get_char,
+#endif
 };
 
 static struct usb_serial_driver * const serial_drivers[] = {
@@ -2039,8 +2045,16 @@ static int ftdi_process_packet(struct tty_struct *tty,
 	priv->icount.rx += len;
 	ch = packet + 2;
 
-	if (port->port.console && port->sysrq) {
+	if ((port->port.console && port->sysrq)
+#ifdef CONFIG_CONSOLE_POLL
+	    || port->poll_rx_cb
+#endif /* CONFIG_CONSOLE_POLL */
+	    ) {
 		for (i = 0; i < len; i++, ch++) {
+#ifdef CONFIG_CONSOLE_POLL
+			if (port->poll_rx_cb && port->poll_rx_cb(*ch))
+				continue;
+#endif /* CONFIG_CONSOLE_POLL */
 			if (!usb_serial_handle_sysrq_char(port, *ch))
 				tty_insert_flip_char(tty, *ch, flag);
 		}
@@ -2461,6 +2475,13 @@ static void __exit ftdi_exit(void)
 	usb_serial_deregister_drivers(&ftdi_driver, serial_drivers);
 }
 
+#ifdef CONFIG_CONSOLE_POLL
+static int ftdi_poll_get_char(struct usb_serial_port *port)
+{
+	/* Indicate this driver requires high level polling */
+	return -2;
+}
+#endif /* CONFIG_CONSOLE_POLL */
 
 module_init(ftdi_init);
 module_exit(ftdi_exit);
diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a1a9062..7e2d1ad 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -813,10 +813,20 @@ static void pl2303_process_read_urb(struct urb *urb)
 	if (line_status & UART_OVERRUN_ERROR)
 		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 
-	if (port->port.console && port->sysrq) {
-		for (i = 0; i < urb->actual_length; ++i)
+	if ((port->port.console && port->sysrq)
+#ifdef CONFIG_CONSOLE_POLL
+	    || port->poll_rx_cb
+#endif /* CONFIG_CONSOLE_POLL */
+	    ) {
+		for (i = 0; i < urb->actual_length; ++i) {
+#ifdef CONFIG_CONSOLE_POLL
+			if (port->poll_rx_cb &&
+			    port->poll_rx_cb(data[i]))
+				continue;
+#endif /* CONFIG_CONSOLE_POLL */
 			if (!usb_serial_handle_sysrq_char(port, data[i]))
 				tty_insert_flip_char(tty, data[i], tty_flag);
+		}
 	} else {
 		tty_insert_flip_string_fixed_flag(tty, data, tty_flag,
 							urb->actual_length);
@@ -826,6 +836,14 @@ static void pl2303_process_read_urb(struct urb *urb)
 	tty_kref_put(tty);
 }
 
+#ifdef CONFIG_CONSOLE_POLL
+static int pl2303_poll_get_char(struct usb_serial_port *port)
+{
+	/* Indicate this driver requires high level polling */
+	return -2;
+}
+#endif /* CONFIG_CONSOLE_POLL */
+
 /* All of the device info needed for the PL2303 SIO serial converter */
 static struct usb_serial_driver pl2303_device = {
 	.driver = {
@@ -849,6 +867,9 @@ static struct usb_serial_driver pl2303_device = {
 	.read_int_callback =	pl2303_read_int_callback,
 	.attach =		pl2303_startup,
 	.release =		pl2303_release,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_get_char = pl2303_poll_get_char,
+#endif
 };
 
 static struct usb_serial_driver * const serial_drivers[] = {
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index bcf2617..8beb817 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -35,6 +35,8 @@
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
 #include <linux/kfifo.h>
+#include <linux/kgdb.h>
+#include "linux/usb/hcd.h"
 #include "pl2303.h"
 
 /*
@@ -1183,6 +1185,136 @@ int usb_serial_resume(struct usb_interface *intf)
 }
 EXPORT_SYMBOL(usb_serial_resume);
 
+#ifdef CONFIG_CONSOLE_POLL
+static int serial_poll_init(struct tty_driver *driver, int line,
+		char *options, void *rx_callback)
+{
+	struct usb_serial *serial;
+	struct usb_serial_port *port;
+
+#if 0
+	struct uart_driver *drv = driver->driver_state;
+	struct uart_state *state = drv->state + line;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+#endif
+
+	serial = usb_serial_get_by_index(line);
+	if (!serial)
+		return -1;
+
+	if (!serial->type->poll_get_char)
+		return -1;
+
+	port = serial->port[line - serial->minor];
+	if (rx_callback + 1 == 0)
+		port->poll_rx_cb = NULL;
+	else
+		port->poll_rx_cb = rx_callback;
+
+#if 0
+	port = state->port;
+	if (!(port->ops->poll_get_char && port->ops->poll_put_char))
+		return -1;
+
+	if (options) {
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+		return uart_set_options(port, NULL, baud, parity, bits, flow);
+	}
+#endif
+
+	return 0;
+}
+
+static int serial_poll_get_char(struct tty_driver *driver, int line)
+{
+	struct usb_serial *serial;
+	struct usb_serial_port *port;
+	struct usb_hcd *hcd;
+	struct urb *urb;
+	int ret = -1;
+
+	serial = usb_serial_get_by_index(line);
+	if (!serial)
+		return -1;
+
+	port = serial->port[line - serial->minor];
+
+	if (serial->type->poll_get_char)
+		ret = serial->type->poll_get_char(port);
+	if (ret != -2)
+		return ret;
+	/*
+	 * -2 indicates that low level driver wants the interrupt
+	 * service routine to be polled in order to service character
+	 * poll requests.  This involves making a direct request to
+	 * the HCD.
+	 */
+	urb = port->read_urb;
+	if (!urb)
+		return -1;
+
+	hcd = bus_to_hcd(urb->dev->bus);
+	if (hcd)
+		usb_hcd_irq(0, hcd);
+
+	return ret;
+}
+
+static void serial_poll_put_char(struct tty_driver *driver, int line, char ch)
+{
+	struct usb_serial *serial;
+	struct usb_serial_port *port;
+	struct usb_hcd *hcd;
+	struct urb *urb;
+	int failcnt;
+	char buf[2];
+	int retval;
+
+	serial = usb_serial_get_by_index(line);
+	if (!serial)
+		return;
+
+	if (serial->dev->state == USB_STATE_NOTATTACHED)
+		return;
+
+	port = serial->port[line - serial->minor];
+
+	if (!port->port.count)
+		return;
+
+	buf[0] = ch;
+
+	retval = 0;
+	failcnt = 100000;
+	urb = port->read_urb;
+	if (!urb) {
+		pr_crit("%s - bad read_urb pointer - exiting", __func__);
+		return;
+	}
+	hcd = bus_to_hcd(urb->dev->bus);
+	/* Perform the chip level write */
+	while (failcnt) {
+		if (serial->type->write)
+			retval = serial->type->write(NULL, port, buf, 1);
+		else
+			retval = usb_serial_generic_write(NULL, port, buf, 1);
+		if (retval == 1)
+			break;
+		/* Run the hcd device to clear out extra packets */
+		if (hcd)
+			usb_hcd_irq(0, hcd);
+		failcnt--;
+	}
+	if (retval <= 0)
+		pr_crit("USB-SERIAL: error writing '%c' to port\n", ch);
+
+	return;
+}
+#endif
+
 static const struct tty_operations serial_ops = {
 	.open =			serial_open,
 	.close =		serial_close,
@@ -1201,6 +1333,11 @@ static const struct tty_operations serial_ops = {
 	.cleanup =		serial_cleanup,
 	.install =		serial_install,
 	.proc_fops =		&serial_proc_fops,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_init	= serial_poll_init,
+	.poll_get_char	= serial_poll_get_char,
+	.poll_put_char	= serial_poll_put_char,
+#endif
 };
 
 
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 4742838..5c620cb 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -69,6 +69,7 @@
  * @work: work queue entry for the line discipline waking up.
  * @throttled: nonzero if the read urb is inactive to throttle the device
  * @throttle_req: nonzero if the tty wants to throttle us
+ * @poll_rx_cb: Optional console polling callback routine
  * @dev: pointer to the serial device
  *
  * This structure is used by the usb-serial core and drivers for the specific
@@ -115,6 +116,9 @@ struct usb_serial_port {
 	struct work_struct	work;
 	char			throttled;
 	char			throttle_req;
+#ifdef CONFIG_CONSOLE_POLL
+	int			(*poll_rx_cb)(u8);
+#endif /* CONFIG_CONSOLE_POLL */
 	unsigned long		sysrq; /* sysrq timeout */
 	struct device		dev;
 };
@@ -288,6 +292,9 @@ struct usb_serial_driver {
 	/* Called by the generic write implementation */
 	int (*prepare_write_buffer)(struct usb_serial_port *port,
 						void *dest, size_t size);
+#ifdef CONFIG_CONSOLE_POLL
+	int (*poll_get_char)(struct usb_serial_port *port);
+#endif
 };
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
-- 
1.7.9.7

