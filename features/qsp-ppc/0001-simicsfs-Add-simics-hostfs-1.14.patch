From 00fa634965edc78e6da427cf5a04849adbfa947d Mon Sep 17 00:00:00 2001
From: Ivar Holmqvist <ivarholmqvist@gmail.com>
Date: Tue, 17 Apr 2012 17:12:54 +0200
Subject: [PATCH 01/22] simicsfs: Add simics hostfs 1.14.

[Original patch is from simics-pkg-12514-4.8.1-linux64.tar]

Signed-off-by: Ruan Zhengwang <zhengwang.ruan@windriver.com>
---
 fs/Kconfig                 |    1 +
 fs/Makefile                |    2 +
 fs/simicsfs/Kconfig        |   18 +
 fs/simicsfs/Makefile       |   11 +
 fs/simicsfs/hostfs.h       |  263 ++++++++++++++++
 fs/simicsfs/hostfs_data.h  |  355 +++++++++++++++++++++
 fs/simicsfs/hostfs_dir.c   |   77 +++++
 fs/simicsfs/hostfs_file.c  |  150 +++++++++
 fs/simicsfs/hostfs_host.c  |  163 ++++++++++
 fs/simicsfs/hostfs_inode.c |  748 ++++++++++++++++++++++++++++++++++++++++++++
 fs/simicsfs/hostfs_linux.h |  143 +++++++++
 fs/simicsfs/hostfs_super.c |  191 +++++++++++
 12 files changed, 2122 insertions(+), 0 deletions(-)
 create mode 100644 fs/simicsfs/Kconfig
 create mode 100644 fs/simicsfs/Makefile
 create mode 100644 fs/simicsfs/hostfs.h
 create mode 100644 fs/simicsfs/hostfs_data.h
 create mode 100644 fs/simicsfs/hostfs_dir.c
 create mode 100644 fs/simicsfs/hostfs_file.c
 create mode 100644 fs/simicsfs/hostfs_host.c
 create mode 100644 fs/simicsfs/hostfs_inode.c
 create mode 100644 fs/simicsfs/hostfs_linux.h
 create mode 100644 fs/simicsfs/hostfs_super.c

diff --git a/fs/Kconfig b/fs/Kconfig
index df7f99e..a96596d 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -225,6 +225,7 @@ source "fs/ufs/Kconfig"
 source "fs/pramfs/Kconfig"
 source "fs/axfs/Kconfig"
 source "fs/exofs/Kconfig"
+source "fs/simicsfs/Kconfig"
 
 endif # MISC_FILESYSTEMS
 
diff --git a/fs/Makefile b/fs/Makefile
index 3a08584..4f94065 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -131,3 +131,5 @@ obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
 obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
 obj-$(CONFIG_PRAMFS)		+= pramfs/
+obj-$(CONFIG_SIMICSFS)		+= simicsfs/
+
diff --git a/fs/simicsfs/Kconfig b/fs/simicsfs/Kconfig
new file mode 100644
index 0000000..801ba83
--- /dev/null
+++ b/fs/simicsfs/Kconfig
@@ -0,0 +1,18 @@
+config SIMICSFS
+       tristate "Simics hostfs"
+       help
+          This filesystem allows Simics to acces the host filesystem.
+
+          To compile this file system support as a module, choose M here. The
+          module will be called simicsfs.
+
+          If unsure, say N.
+
+config SIMICSFS_ADDRESS
+       string "SimicsFS physical address"
+       depends on SIMICSFS
+       help
+          The default address at which the Simics hostfs module is mapped.
+          Can be overriden by setting the phys_addr module parameter.
+
+          If you are not sure, leave it blank.
diff --git a/fs/simicsfs/Makefile b/fs/simicsfs/Makefile
new file mode 100644
index 0000000..d1168f7
--- /dev/null
+++ b/fs/simicsfs/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for Simics hostfs
+
+ifeq (,$(CONFIG_SIMICSFS))
+CONFIG_SIMICSFS=m
+endif
+
+obj-$(CONFIG_SIMICSFS) += simicsfs.o
+
+simicsfs-objs := hostfs_inode.o hostfs_super.o hostfs_dir.o hostfs_file.o \
+	hostfs_host.o
diff --git a/fs/simicsfs/hostfs.h b/fs/simicsfs/hostfs.h
new file mode 100644
index 0000000..a60f855
--- /dev/null
+++ b/fs/simicsfs/hostfs.h
@@ -0,0 +1,263 @@
+/*
+   hostfs for Linux
+   Copyright 2001-2006 Virtutech AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef _HOST_FS_H
+#define _HOST_FS_H
+
+#define HOSTFS_VERSION 1
+#define HOSTFS_SUBVERSION 14 /* update before release, reset to 99 when done */
+
+#if defined(__powerpc__)
+ #define HOSTFS_DEV    0xff660000
+#elif defined(__arm__)
+ #define HOSTFS_DEV    0x50000000
+#elif defined(__mips__)
+ #define HOSTFS_DEV    0x1c000000
+#else
+ #define HOSTFS_DEV    0xffe81000
+#endif
+
+#define HOSTFS_MAGIC 0x66685456 		/* "VThf" */
+
+#define DATA_BUF_LEN        1040
+#define HOSTFS_FILENAME_LEN  512
+#define DEBUG_LEN           1024
+#define XFER_DATA_WORDS      256 /* 1024/4 */
+
+#define SYMBOL_TO_STRING2(n) #n
+#define SYMBOL_TO_STRING(n) SYMBOL_TO_STRING2(n)
+
+/* used on target */
+#define DPRINTF_0 printk
+#define DPRINTF_1 if (hostfs_debug >= 1) printf
+#define DPRINTF_2 if (hostfs_debug >= 2) printf
+
+enum {
+        HF_FREAD   = 0x01,
+        HF_FWRITE  = 0x02,
+        HF_FNDELAY = 0x04,
+        HF_FAPPEND = 0x08,
+        HF_FSYNC   = 0x10
+};
+
+/* identifies a host file for the filesystem */
+typedef uint host_node_t;
+
+/* only in target part */
+extern dev_t hostfs_dev;
+extern int hostfs_debug;
+
+struct hf_node;
+typedef struct hf_node hf_node_t;
+
+typedef enum host_func {
+        hf_VfsStat,
+        hf_Root,
+        hf_GetAttr,
+        hf_SetAttr,
+        hf_Open,
+        hf_Close,
+        hf_Readdir,
+        hf_Lookup,
+        hf_Seek,
+        hf_Read,
+        hf_Write,
+        hf_Create,
+        hf_Remove,
+        hf_MkDir,
+        hf_Parent,
+        hf_Rename,
+        hf_Link,
+        hf_Symlink,
+        hf_Readlink,
+        hf_Debug,
+        hf_Handshake,
+        hf_Unmount,
+        hf_Functions
+} host_func_t;
+
+typedef struct host_funcs {
+        host_func_t func;
+        const char *name;
+        int out;
+        int in;
+        int ie_out;
+        int ie_in;
+} host_funcs_t;
+
+/*********
+ *
+ *IMPORTANT:
+ * If you change the parameters make sure the ie_out and ie_in are still
+ * correct. They signal the first entry to do endian conversion on.
+ * -1 is no conversion at all.
+ *
+ */
+
+struct hf_common_data {
+        uint sys_error;
+};
+
+struct hf_hnode_data {
+        uint sys_error;
+        uint hnode;
+        uint type;
+};
+
+struct hf_vfsstat_data {
+        uint bsize;
+        uint frsize;
+        uint blocks;
+        uint bfree;
+        uint bavail;
+        uint files;
+        uint ffree;
+        uint favail;
+};
+
+struct hf_getattr_data {
+        uint sys_error;
+        uint mode;      /* access mode */
+        uint uid;       /* user id */
+        uint gid;       /* group id */
+        uint link;      /* number of references */
+        uint size_hi;   /* file size */
+        uint size_lo;   
+        uint atime_hi;  /* access time */
+        uint atime_lo;  
+        uint mtime_hi;  /* modification time */
+        uint mtime_lo;  
+        uint ctime_hi;  /* creation time */
+        uint ctime_lo;  
+        uint blksize;   /* fundamental block size */
+        uint blocks_hi; /* blocks allocated */
+        uint blocks_lo; 
+};
+
+struct hf_setattr_data {
+        uint set_atime;
+        uint set_mtime;
+        uint set_mode;
+        uint set_uid;
+        uint set_gid;
+        uint atime_hi;  /* access time */
+        uint atime_lo;  
+        uint mtime_hi;  /* modification time */
+        uint mtime_lo;
+        uint mode;
+        uint uid;
+        uint gid;
+        uint set_size;
+        uint size_hi;
+        uint size_lo;
+};
+
+struct hf_setattr_data_v0 {
+        uint set_atime;
+        uint set_mtime;
+        uint set_mode;
+        uint set_uid;
+        uint set_gid;
+        uint atime_hi;  /* access time */
+        uint atime_lo;  
+        uint mtime_hi;  /* modification time */
+        uint mtime_lo;
+        uint mode;
+        uint uid;
+        uint gid;
+};
+
+struct hf_readdir_data {
+        uint sys_error;
+        host_node_t hnode;
+        char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_readlink_data {
+        uint sys_error;
+        char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_lookup_data {
+        char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_remove_data {
+        char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_rename_data {
+        uint new_hnode;
+        char old_name[HOSTFS_FILENAME_LEN];
+        char new_name[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_create_data {
+        uint excl;
+        uint trunc;
+        uint mode;
+        char filename[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_mkdir_data {
+        uint mode;
+        char dirname[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_seek_data {
+        uint off_hi;
+        uint off_lo;
+};
+
+struct hf_read_data {
+        uint sys_error;
+        uint size;
+        uint data[XFER_DATA_WORDS]; /* max 480 bytes of data */
+};
+
+struct hf_write_data {
+        uint size;
+        uint append;
+        uint data[XFER_DATA_WORDS]; /* max 480 bytes of data */
+};
+
+struct hf_link_data {
+        uint hnode;
+        char link[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_symlink_data {
+        char target[HOSTFS_FILENAME_LEN];
+        char link[HOSTFS_FILENAME_LEN];
+};
+
+struct hf_debug_data {
+        char string[DEBUG_LEN];
+};
+
+struct hf_handshake_data {
+        uint version;
+};
+
+struct hf_handshake_reply_data {
+        uint sys_error;
+        uint magic;
+};
+
+#endif /* _HOST_FS_H */
diff --git a/fs/simicsfs/hostfs_data.h b/fs/simicsfs/hostfs_data.h
new file mode 100644
index 0000000..1e69558
--- /dev/null
+++ b/fs/simicsfs/hostfs_data.h
@@ -0,0 +1,355 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef _HOST_FS_DATA_H
+#define _HOST_FS_DATA_H
+
+/* WARNING: Only include once. Contains definitions */
+
+/* when transferring data the following protocol is used:
+ *
+ *   to host:  4 byte  function
+ *   to host:  4 bytes hnode
+ *   to host:  X bytes out data (defined by fkn_len[fkn].out)
+ * from host:  X bytes in data  (defined by fkn_len[fkn].in)  ( X > 0 !!! )
+ *
+ */
+
+static host_funcs_t host_funcs[] = {
+        { hf_VfsStat,
+          "VfsStat",
+          0,
+          sizeof(struct hf_vfsstat_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Root,
+          "Root",
+          0,
+          sizeof(struct hf_hnode_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_GetAttr,
+          "GetAttr",
+          0,
+          sizeof(struct hf_getattr_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_SetAttr,
+          "SetAttr",
+          sizeof(struct hf_setattr_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Open,
+          "Open",
+          1,
+          sizeof(struct hf_common_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Close,
+          "Close",
+          0,
+          1,
+          -1,
+          -1 },
+
+        { hf_Readdir,
+          "Readdir",
+          1,
+          sizeof(struct hf_readdir_data) >> 2,
+          -1,
+          2 },
+
+        { hf_Lookup,
+          "Lookup",
+          sizeof(struct hf_lookup_data),
+          sizeof(struct hf_hnode_data) >> 2,
+          0,
+          -1 },
+
+        { hf_Seek,
+          "Seek",
+          sizeof(struct hf_seek_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Read,
+          "Read",
+          1,
+          sizeof(struct hf_read_data) >> 2,
+          -1,
+          2 },
+
+        { hf_Write,
+          "Write",
+          sizeof(struct hf_write_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          2,
+          -1 },
+
+        { hf_Create,
+          "Create",
+          sizeof(struct hf_create_data) >> 2,
+          sizeof(struct hf_hnode_data) >> 2,
+          3,
+          -1 },
+
+        { hf_Remove,
+          "Remove",
+          sizeof(struct hf_remove_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          0,
+          -1 },
+
+        { hf_MkDir,
+          "MkDir",
+          sizeof(struct hf_mkdir_data) >> 2,
+          sizeof(struct hf_hnode_data) >> 2,
+          1,
+          -1 },
+
+        { hf_Parent,
+          "Parent",
+          0,
+          sizeof(struct hf_hnode_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Rename,
+          "Rename",
+          sizeof(struct hf_rename_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          1,
+          -1 },
+
+        { hf_Link,
+          "Link",
+          sizeof(struct hf_link_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          1,
+          -1 },
+
+        { hf_Symlink,
+          "Symlink",
+          sizeof(struct hf_symlink_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          0,
+          -1 },
+
+        { hf_Readlink,
+          "Readlink",
+          0,
+          sizeof(struct hf_readlink_data) >> 2,
+          -1,
+          1},
+
+        { hf_Debug,
+          "Debug",
+          sizeof(struct hf_debug_data) >> 2,
+          1,
+          0,
+          -1 },
+
+        { hf_Handshake,
+          "Handshake",
+          sizeof(struct hf_handshake_data) >> 2,
+          sizeof(struct hf_handshake_reply_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Unmount,
+          "Unmount",
+          0,
+          sizeof(struct hf_common_data) >> 2,
+          -1,
+          -1 }
+};
+
+typedef int check_enough_host_funcs[sizeof(host_funcs) / sizeof(host_funcs[0])
+                                    == hf_Functions ? 1 : -1];
+
+#if defined(HOSTFS_HOST)
+static host_funcs_t host_funcs_v0[] = {
+        { hf_VfsStat,
+          "VfsStat",
+          0,
+          sizeof(struct hf_vfsstat_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Root,
+          "Root",
+          0,
+          sizeof(struct hf_hnode_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_GetAttr,
+          "GetAttr",
+          0,
+          sizeof(struct hf_getattr_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_SetAttr,
+          "SetAttr",
+          sizeof(struct hf_setattr_data_v0) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Open,
+          "Open",
+          1,
+          sizeof(struct hf_common_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Close,
+          "Close",
+          0,
+          1,
+          -1,
+          -1 },
+
+        { hf_Readdir,
+          "Readdir",
+          1,
+          sizeof(struct hf_readdir_data) >> 2,
+          -1,
+          2 },
+
+        { hf_Lookup,
+          "Lookup",
+          sizeof(struct hf_lookup_data),
+          sizeof(struct hf_hnode_data) >> 2,
+          0,
+          -1 },
+
+        { hf_Seek,
+          "Seek",
+          sizeof(struct hf_seek_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Read,
+          "Read",
+          1,
+          sizeof(struct hf_read_data) >> 2,
+          -1,
+          2 },
+
+        { hf_Write,
+          "Write",
+          sizeof(struct hf_write_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          2,
+          -1 },
+
+        { hf_Create,
+          "Create",
+          sizeof(struct hf_create_data) >> 2,
+          sizeof(struct hf_hnode_data) >> 2,
+          3,
+          -1 },
+
+        { hf_Remove,
+          "Remove",
+          sizeof(struct hf_remove_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          0,
+          -1 },
+
+        { hf_MkDir,
+          "MkDir",
+          sizeof(struct hf_mkdir_data) >> 2,
+          sizeof(struct hf_hnode_data) >> 2,
+          1,
+          -1 },
+
+        { hf_Parent,
+          "Parent",
+          0,
+          sizeof(struct hf_hnode_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Rename,
+          "Rename",
+          sizeof(struct hf_rename_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          1,
+          -1 },
+
+        { hf_Link,
+          "Link",
+          sizeof(struct hf_link_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          1,
+          -1 },
+
+        { hf_Symlink,
+          "Symlink",
+          sizeof(struct hf_symlink_data) >> 2,
+          sizeof(struct hf_common_data) >> 2,
+          0,
+          -1 },
+
+        { hf_Readlink,
+          "Readlink",
+          0,
+          sizeof(struct hf_readlink_data) >> 2,
+          -1,
+          1},
+
+        { hf_Debug,
+          "Debug",
+          sizeof(struct hf_debug_data) >> 2,
+          1,
+          0,
+          -1 },
+
+        { hf_Handshake,
+          "Handshake",
+          sizeof(struct hf_handshake_data) >> 2,
+          sizeof (struct hf_handshake_reply_data) >> 2,
+          -1,
+          -1 },
+
+        { hf_Unmount,
+          "Unmount",
+          0,
+          0,
+          -1,
+          -1 }
+};
+
+typedef int check_enough_host_funcs_v0[
+                    sizeof(host_funcs_v0) / sizeof(host_funcs_v0[0])
+                    == hf_Functions ? 1 : -1];
+#endif /* HOSTFS_HOST */
+
+#endif /* _HOST_FS_DATA */
diff --git a/fs/simicsfs/hostfs_dir.c b/fs/simicsfs/hostfs_dir.c
new file mode 100644
index 0000000..de47668
--- /dev/null
+++ b/fs/simicsfs/hostfs_dir.c
@@ -0,0 +1,77 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   $Id: hostfs_dir.c,v 1.3 2006/03/31 10:25:53 am Exp $
+*/
+
+#include "hostfs_linux.h"
+
+static int
+hostfs_fo_readdir(struct file *file, void *buf, filldir_t fill)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+        struct dentry *dentry = file->f_path.dentry;
+#else
+        struct dentry *dentry = file->f_dentry;
+#endif
+        struct inode *inode = dentry->d_inode;
+        struct hf_readdir_data data;
+        uint offset = file->f_pos;
+
+/*          DPRINT1(DEVICE_NAME " hostfs_fo_readdir("); */
+/*          DPRINTFILE1(file); */
+/*          DPRINT1(", %p, %p)\n", buf, fill); */
+/*          DPRINT1("   file->fpos == %ld\n", (long)file->f_pos); */
+
+        get_host_data(hf_Readdir, inode->i_ino, &offset, &data);
+        while (data.hnode) {
+                int res;
+                NTOHSWAP(data.filename);
+                if ((res = fill(buf, data.filename, strlen(data.filename),
+                                offset, data.hnode, DT_UNKNOWN))) {
+                        return 0;
+                }
+                file->f_pos = ++offset;
+                get_host_data(hf_Readdir, inode->i_ino, &offset, &data);
+        }
+        return 0;
+}
+
+static ssize_t
+hostfs_fo_dir_read(struct file *file, char *buf, size_t len, loff_t *off)
+{
+/*          DPRINT1(DEVICE_NAME " hostfs_fo_dir_read()\n"); */
+        return -EISDIR;
+}
+
+
+static int
+hostfs_dir_release(struct inode *inode, struct file *file)
+{
+        uint dummy;
+        get_host_data(hf_Close, inode->i_ino, NULL, &dummy);
+        return 0;
+}
+
+
+struct file_operations hostfs_file_dirops = {
+        read: hostfs_fo_dir_read,
+        readdir: hostfs_fo_readdir,
+	release: hostfs_dir_release,
+};
diff --git a/fs/simicsfs/hostfs_file.c b/fs/simicsfs/hostfs_file.c
new file mode 100644
index 0000000..01d25d1
--- /dev/null
+++ b/fs/simicsfs/hostfs_file.c
@@ -0,0 +1,150 @@
+
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   $Id: hostfs_file.c,v 1.3 2006/03/31 10:25:53 am Exp $
+*/
+
+#include "hostfs_linux.h"
+
+static int
+hostfs_fo_open(struct inode *inode, struct file *file)
+{
+        struct hf_common_data idata;
+        uint oflag = 0, flag = file->f_flags;
+
+        DPRINT1("hostfs_fo_open %ld flags %x\n", inode->i_ino, file->f_flags);
+
+        switch (flag & O_ACCMODE) {
+        case O_RDONLY:
+                oflag = HF_FREAD;
+                break;
+        case O_RDWR:
+                oflag = HF_FREAD; 
+                /* fallthrough */
+        case O_WRONLY:
+                oflag |= HF_FWRITE;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        get_host_data(hf_Open, inode->i_ino, &oflag, &idata);
+
+        if (idata.sys_error)
+                return -idata.sys_error;
+
+        return 0;
+}
+
+static int
+hostfs_fo_release(struct inode *inode, struct file *file)
+{
+        uint dummy;
+
+        /* DPRINT1("hostfs_fo_release %ld fcount %d icount %d\n",
+        	(long)inode->i_ino, atomic_read(&file->f_count),
+        	atomic_read(&inode->i_count)); */
+
+        get_host_data(hf_Close, inode->i_ino, NULL, &dummy);
+        return 0;
+}
+
+static ssize_t
+hostfs_read(struct file *file, char *buf, size_t len, loff_t *ppos)
+{
+        DPRINT1("hostfs: hostfs_read %ld\n", file->f_dentry->d_inode->i_ino);
+        if (!hostfs_revalidate_inode(file->f_dentry->d_inode))
+                return 0;
+#if defined(KERNEL_2_6)
+        return do_sync_read(file, buf, len, ppos);
+#else
+        return generic_file_read(file, buf, len, ppos);
+#endif
+}
+
+static ssize_t
+hostfs_write(struct file *file, const char *buf, size_t len, loff_t *ppos)
+{
+        DPRINT1("hostfs: hostfs_write %ld\n", file->f_dentry->d_inode->i_ino);
+        if (!hostfs_revalidate_inode(file->f_dentry->d_inode))
+                return 0;
+#if defined(KERNEL_2_6)
+        return do_sync_write(file, buf, len, ppos);
+#else
+        return generic_file_write(file, buf, len, ppos);
+#endif
+}
+
+#if defined(KERNEL_2_6)
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+static ssize_t
+hostfs_aio_read(struct kiocb *kiocb, const struct iovec *iovec,
+                unsigned long len, loff_t ofs)
+ #else
+static ssize_t
+hostfs_aio_read(struct kiocb *kiocb, char *buf, size_t len, loff_t ppos)
+ #endif
+{
+        DPRINT1("hostfs: hostfs_aio_read %ld\n",
+                kiocb->ki_filp->f_dentry->d_inode->i_ino);
+        if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
+                return 0;
+        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+                return generic_file_aio_read(kiocb, iovec, len, ofs);
+        #else
+                return generic_file_aio_read(kiocb, buf, len, ppos);
+        #endif
+}
+
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+static ssize_t
+hostfs_aio_write(struct kiocb *kiocb, const struct iovec *iovec,
+                 unsigned long len, loff_t ofs)
+ #else
+static ssize_t
+hostfs_aio_write(struct kiocb *kiocb, const char *buf, size_t len, loff_t ppos)
+ #endif
+{
+        DPRINT1("hostfs: hostfs_aio_write %ld\n",
+                kiocb->ki_filp->f_dentry->d_inode->i_ino);
+        if (!hostfs_revalidate_inode(kiocb->ki_filp->f_dentry->d_inode))
+                return 0;
+        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+                return generic_file_aio_write(kiocb, iovec, len, ofs);
+        #else
+                return generic_file_aio_write(kiocb, buf, len, ppos);
+        #endif
+}
+#endif
+
+struct file_operations hostfs_file_fops = {
+#if defined(KERNEL_2_6)
+        read: hostfs_read,
+        write: hostfs_write,
+        aio_read: hostfs_aio_read,
+        aio_write: hostfs_aio_write,
+#else
+        read: hostfs_read,
+        write: hostfs_write,
+#endif
+        mmap: generic_file_mmap,
+        open: hostfs_fo_open,
+	release: hostfs_fo_release,
+};
diff --git a/fs/simicsfs/hostfs_host.c b/fs/simicsfs/hostfs_host.c
new file mode 100644
index 0000000..5aea029
--- /dev/null
+++ b/fs/simicsfs/hostfs_host.c
@@ -0,0 +1,163 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   $Id: hostfs_host.c,v 1.8 2006/03/31 14:56:52 ekloef Exp $
+*/
+
+
+#include "hostfs_linux.h"
+
+#if !defined(__sparc_v9__)
+static volatile void *hostfs_dev_data;
+#endif
+
+static void
+write_value(uint value)
+{
+#if defined(__sparc_v9__)
+        asm volatile ("wr %0, 0, %%asr31" :: "r"(value));
+#else
+        writel(value, hostfs_dev_data);
+#endif
+}
+
+static uint
+read_value(void)
+{
+        uint value;
+#if defined(__sparc_v9__)
+        asm volatile ("rd %%asr31, %0" : "=r" (value));
+#else
+        value = readl(hostfs_dev_data);
+#endif
+        return value;
+}
+
+static void
+data_to_host(uint *data, int len)
+{
+        int i;
+
+        for (i = 0; i < len; i++)
+                write_value(data[i]);
+}
+
+static void
+data_from_host(uint *data, int len)
+{
+        int i;
+
+        for (i = 0; i < len; i++) 
+                data[i] = read_value();
+}
+
+spinlock_t get_host_data_lock;
+spinlock_t hostfs_position_lock;
+
+
+int
+get_host_data(host_func_t func, host_node_t hnode, void *in_buf, void *out_buf)
+{
+        uint data;
+
+        if (func != host_funcs[func].func)
+                printk(DEVICE_NAME " INTERNAL ERROR: host_funcs_t != func\n");
+
+        spin_lock(&get_host_data_lock);
+
+        data = func;
+        data_to_host(&data, 1);
+        data_to_host(&hnode, 1);
+        data_to_host(in_buf, host_funcs[func].out);
+        data_from_host(out_buf, host_funcs[func].in);
+
+        spin_unlock(&get_host_data_lock);
+
+        return 0;
+}
+
+
+/* internal function */
+int
+hf_do_seek(ino_t inode, loff_t off)
+{
+        struct hf_seek_data odata;
+        struct hf_common_data idata;
+
+        SET_HI_LO(odata.off, off);
+        get_host_data(hf_Seek, inode, &odata, &idata);
+        return idata.sys_error;
+}
+
+
+/*
+ * Dynamic configuration support.
+ * You can specify simicsfs.phys_addr=0xff00ff00 on the kernel command line, or
+ * insmod simicsfs phys_addr=0xff00ff00
+ */
+
+#ifdef KERNEL_2_6
+# include <linux/moduleparam.h>
+
+#ifdef CONFIG_SIMICSFS_ADDRESS
+static char *phys_addr = CONFIG_SIMICSFS_ADDRESS;
+#else
+static char *phys_addr;
+#endif
+
+module_param(phys_addr, charp, 0);
+MODULE_PARM_DESC(phys_addr, "Physical address where simicsfs is mapped.");
+
+#endif
+
+int
+init_host_fs(void)
+{
+        unsigned long long hostfs_dev = HOSTFS_DEV;
+
+#ifdef KERNEL_2_6
+        if (phys_addr && strcmp(phys_addr, "") != 0)
+                hostfs_dev = simple_strtoull(phys_addr, NULL, 0);
+#endif
+
+#if defined(__alpha)
+        hostfs_dev_data = (void *)phys_to_virt(hostfs_dev);
+#elif defined(__i386) || defined(__x86_64__) || defined(__ia64) \
+        || defined(__powerpc__) || defined(__arm__) || defined(__mips__) \
+        || defined(__m68k__)
+# ifdef CONFIG_440
+	hostfs_dev_data = (void *)ioremap64(hostfs_dev, 16);
+# else
+	hostfs_dev_data = (void *)ioremap(hostfs_dev, 16);
+# endif
+	if (!hostfs_dev_data) {
+		printk("hostfs: cannot map 0x%08llx\n", hostfs_dev);
+		return -EIO;
+	}
+	printk(KERN_INFO "Mapping hostfs from p:%08llx to %p\n",
+               hostfs_dev, hostfs_dev_data);
+#elif defined(__sparc_v9__)
+#else
+#error "No device mapping for this architecture"
+#endif
+
+        spin_lock_init(&get_host_data_lock);
+        spin_lock_init(&hostfs_position_lock);
+	return 0;
+}
diff --git a/fs/simicsfs/hostfs_inode.c b/fs/simicsfs/hostfs_inode.c
new file mode 100644
index 0000000..6e97c9c
--- /dev/null
+++ b/fs/simicsfs/hostfs_inode.c
@@ -0,0 +1,748 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   $Id: hostfs_inode.c,v 1.5 2006/03/31 10:25:53 am Exp $
+*/
+
+#include "hostfs_linux.h"
+#include <linux/slab.h>		/* for kmalloc/kfree */
+
+
+static struct address_space_operations hostfs_file_aops;
+static struct inode_operations hostfs_symlink_iops, hostfs_dir_iops;
+
+static struct inode_operations hostfs_file_iops;
+
+int
+hostfs_revalidate_inode(struct inode *inode)
+{
+#ifdef KERNEL_2_6
+        struct inode updated_inode = *inode;
+
+        DPRINT1("hostfs_revalidate %ld\n", (long)inode->i_ino);
+
+        hostfs_read_inode(&updated_inode);
+
+        if (memcmp(&updated_inode, inode, sizeof(updated_inode)) != 0) {
+                DPRINT1("hostfs: inode changed, flushing pages\n");
+                memcpy(inode, &updated_inode, sizeof updated_inode);
+
+                /* TODO: can we do a better guess when to invalidate pages and
+                   when not to? */
+                invalidate_inode_pages2(inode->i_mapping);
+        } else {
+                DPRINT1("hostfs: inode not changed\n");
+        }
+#endif  /* KERNEL_2_6 */
+        return 1;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+struct inode *
+hostfs_iget(struct super_block *sb, unsigned long ino)
+{
+        struct inode *inode;
+
+        inode = iget_locked(sb, ino);
+        if (!inode)
+                return ERR_PTR(-ENOMEM);
+        if (!(inode->i_state & I_NEW))
+                return inode;
+
+        hostfs_read_inode(inode);
+
+        unlock_new_inode(inode);
+        return inode;
+}
+#endif
+
+void
+hostfs_read_inode(struct inode *inode)
+{
+        struct hf_getattr_data data;
+        uint mask;
+
+        get_host_data(hf_GetAttr, inode->i_ino, &mask, &data);
+        if (data.sys_error) {
+                printk(DEVICE_NAME "get_host_data(hf_GetAttr, %ld, ...) "
+                       "had an error\n", inode->i_ino);
+                return;
+        }
+
+        DPRINT1("hostfs_read_inode(%ld) flags %lx\n", inode->i_ino,
+                (long)inode->i_flags);
+
+        inode->i_flags = 0;
+        inode->i_mode = data.mode;
+        inode->i_uid = data.uid;
+        inode->i_gid = data.gid;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)
+        set_nlink(inode, data.link);
+#else
+        inode->i_nlink = data.link;
+#endif
+        GET_HI_LO(inode->i_size,  data.size);
+#ifndef KERNEL_2_6
+        GET_HI_LO(inode->i_atime, data.atime);
+        GET_HI_LO(inode->i_mtime, data.mtime);
+        GET_HI_LO(inode->i_ctime, data.ctime);
+#else /* KERNEL_2_6 */
+        GET_HI_LO(inode->i_atime.tv_sec, data.atime);
+        GET_HI_LO(inode->i_mtime.tv_sec, data.mtime);
+        GET_HI_LO(inode->i_ctime.tv_sec, data.ctime);
+        inode->i_atime.tv_nsec = 0;
+        inode->i_mtime.tv_nsec = 0;
+        inode->i_ctime.tv_nsec = 0;
+#endif /* KERNEL_2_6 */
+        #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+                /* blksize field completely removed in 2.6.19 */
+                inode->i_blksize = data.blksize;
+        #endif
+        GET_HI_LO(inode->i_blocks, data.blocks);
+
+        if (S_ISLNK(inode->i_mode)) {
+                inode->i_op = &hostfs_symlink_iops;
+        } else if (S_ISDIR(inode->i_mode)) {
+                inode->i_op = &hostfs_dir_iops;
+		inode->i_fop = &hostfs_file_dirops;
+        } else {
+		inode->i_fop = &hostfs_file_fops;
+		inode->i_op = &hostfs_file_iops;
+                inode->i_mapping->a_ops = &hostfs_file_aops;
+        }
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)
+int hostfs_write_inode(struct inode *inode, struct writeback_control *wbc)
+#else
+#  ifdef KERNEL_2_6
+int hostfs_write_inode(struct inode *inode, int sync)
+#  else
+void hostfs_write_inode(struct inode *inode, int sync)
+#  endif
+#endif
+{
+        /*
+         * it might be pointless to implement this function since
+         * supposedly all changes will have been updated by
+         * notify_change anyway, but I'm sure it can't hurt
+         */
+
+        struct hf_setattr_data odata;
+        struct hf_common_data idata;
+
+        DPRINT1(DEVICE_NAME " hostfs_write_inode(%ld)\n", inode->i_ino);
+
+        memset(&odata, 0, sizeof odata);
+        odata.set_atime = 1;
+#ifndef KERNEL_2_6
+        SET_HI_LO(odata.atime, inode->i_atime);
+        SET_HI_LO(odata.mtime, inode->i_mtime);
+#else /* KERNEL_2_6 */
+        SET_HI_LO(odata.atime, inode->i_atime.tv_sec);
+        SET_HI_LO(odata.mtime, inode->i_mtime.tv_sec);
+#endif /* KERNEL_2_6 */
+        odata.set_mtime = 1;
+        odata.set_mode = 1;
+        odata.mode = inode->i_mode;
+        odata.set_uid = 1;
+        odata.uid = inode->i_uid;
+        odata.set_gid = 1;
+        odata.gid = inode->i_gid;
+        get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
+#ifdef KERNEL_2_6
+        return 0;
+#endif
+}
+
+static int
+hostfs_setattr(struct dentry *dentry, struct iattr *iattr)
+{
+        struct hf_setattr_data odata;
+        struct hf_common_data idata;
+        struct inode *inode = dentry->d_inode;
+        int error;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+        int setsize = 0;
+#endif
+
+        DPRINT1(DEVICE_NAME " hostfs_notify_change(%ld, 0x%lx)\n",
+                inode->i_ino, (long)iattr->ia_valid);
+
+        if ((error = inode_change_ok(inode, iattr)))
+            return error;
+
+        memset(&odata, 0, sizeof odata);
+        if (iattr->ia_valid & ATTR_ATIME) {
+            odata.set_atime = 1;
+#ifndef KERNEL_2_6
+            SET_HI_LO(odata.atime, iattr->ia_atime);
+#else /* KERNEL_2_6 */
+            SET_HI_LO(odata.atime, iattr->ia_atime.tv_sec);
+#endif /* KERNEL_2_6 */
+        }
+        if (iattr->ia_valid & ATTR_MTIME) {
+            odata.set_mtime = 1;
+#ifndef KERNEL_2_6
+            SET_HI_LO(odata.mtime, iattr->ia_mtime);
+#else /* KERNEL_2_6 */
+            SET_HI_LO(odata.mtime, iattr->ia_mtime.tv_sec);
+#endif /* KERNEL_2_6 */
+        }
+        if (iattr->ia_valid & ATTR_MODE) {
+            odata.set_mode = 1;
+            odata.mode = iattr->ia_mode;
+        }
+        if (iattr->ia_valid & ATTR_UID) {
+            odata.set_uid = 1;
+            odata.uid = iattr->ia_uid;
+        }
+        if (iattr->ia_valid & ATTR_GID) {
+            odata.set_gid = 1;
+            odata.gid = iattr->ia_gid;
+        }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+        if (iattr->ia_valid & ATTR_SIZE && iattr->ia_size != inode->i_size) {
+            setsize = 1;
+            odata.set_size = 1;
+            SET_HI_LO(odata.size, iattr->ia_size);
+        }
+#endif
+        get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
+
+        DPRINT1("         hf_SetAttr returned %d\n", idata.sys_error);
+
+        if (idata.sys_error)
+            return -idata.sys_error;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+        if (setsize)
+            truncate_setsize(inode, iattr->ia_size);
+        setattr_copy(inode, iattr);
+        mark_inode_dirty(inode);
+        return 0;
+#else
+        return inode_setattr(inode, iattr);
+#endif
+}
+
+#ifdef KERNEL_2_6
+static int
+hostfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
+{
+        DPRINT1("hostfs: getattr\n");
+        if (!hostfs_revalidate_inode(dentry->d_inode))
+                return 0;
+        generic_fillattr(dentry->d_inode, stat);
+        return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+static int
+hostfs_write_begin(struct file *file, struct address_space *mapping,
+                   loff_t pos, unsigned len, unsigned flags,
+                   struct page **pagep, void **fsdata)
+{
+        pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+        struct page *page = grab_cache_page_write_begin(mapping, index, flags);
+
+        *pagep = page;
+        if (page == NULL)
+                return -ENOMEM;
+
+        return 0;
+}
+#else
+static int
+hostfs_prepare_write(struct file *file, struct page *page, unsigned offset,
+                     unsigned to)
+{
+	return 0;
+}
+#endif
+
+static int
+hostfs_do_writepage(struct inode *inode, struct page *page, unsigned from,
+                    unsigned to)
+{
+	int offset = (page->index << PAGE_CACHE_SHIFT) + from;
+	unsigned bytes = to - from;
+	unsigned long int address = (unsigned long)page_address(page) + from;
+	uint ino = inode->i_ino;
+	int res;
+        struct hf_write_data *odata;
+
+	if (page->index > (0x7fffffff/PAGE_CACHE_SIZE)-1)
+		return -EFBIG;
+
+        /* It is risky to allocate the write buffer on the stack since we
+           have limited stack space */
+        odata = kmalloc(sizeof *odata, GFP_KERNEL);
+
+        if (!odata)
+                return -ENOMEM;
+
+        spin_lock(&hostfs_position_lock);
+
+        DPRINT1("hostfs_do_writepage: offset:%u bytes:%u address:%lx\n",
+                offset, bytes, address);
+
+        hf_do_seek(ino, offset);
+
+	res = 0;
+        while (bytes > 0) {
+                struct hf_common_data idata;
+                uint cnt = MIN(bytes, XFER_DATA_WORDS * 4);
+                odata->append = 0;
+                odata->size = cnt;
+                memcpy(odata->data, (char *)address, cnt);
+                HTONSWAP(odata->data);
+                get_host_data(hf_Write, ino, odata, &idata);
+                if (idata.sys_error) {
+                        res = -idata.sys_error;
+                        DPRINT1(DEVICE_NAME " failed with errcode %d\n", res);
+                        SetPageError(page);
+			ClearPageUptodate(page);
+                        goto got_error;
+                }
+                address += cnt;
+                bytes -= cnt;
+		res += cnt;
+        }
+        DPRINT1(DEVICE_NAME "wrote %d bytes\n", (int)res);
+
+	SetPageUptodate(page);
+
+ got_error:
+        kfree(odata);
+        spin_unlock(&hostfs_position_lock);
+
+        return res;
+}
+
+static int
+#ifndef KERNEL_2_6
+hostfs_writepage(struct page *page)
+#else /* KERNEL_2_6 */
+hostfs_writepage(struct page *page, struct writeback_control *wbc)
+#endif /* KERNEL_2_6 */
+{
+	struct inode *inode = page->mapping->host;
+	int err = -EIO;
+	int bytes = PAGE_CACHE_SIZE;
+	unsigned long end_index = inode->i_size >> PAGE_CACHE_SHIFT;
+	if (page->index <= end_index) {
+		if (page->index == end_index)
+			bytes = inode->i_size & (PAGE_CACHE_SIZE-1);
+		kmap(page);
+		err = hostfs_do_writepage(inode, page, 0, bytes);
+		kunmap(page);
+	}
+#ifndef KERNEL_2_6
+	UnlockPage(page);
+#else /* KERNEL_2_6 */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+        unlock_page(page);
+ #else
+	ClearPageLocked(page);
+ #endif
+#endif /* KERNEL_2_6 */
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
+static int
+hostfs_write_end(struct file *file, struct address_space *mapping,
+                 loff_t pos, unsigned len, unsigned copied,
+                 struct page *page, void *fsdata)
+{
+        unsigned from = pos & (PAGE_CACHE_SIZE - 1);
+        unsigned to = from + copied;
+
+	struct inode *inode = mapping->host;
+	int err;
+
+        kmap(page);
+	err = hostfs_do_writepage(inode, page, from, to);
+
+	if (err >= 0) {
+		loff_t s = ((page->index) << PAGE_CACHE_SHIFT) + to;
+		if (s > inode->i_size) {
+			inode->i_size = s;
+                }
+	}
+
+	kunmap(page);
+
+        unlock_page(page);
+        page_cache_release(page);
+	return err;
+}
+
+#else
+
+static int
+hostfs_commit_write(struct file *file, struct page *page, unsigned from,
+                    unsigned to)
+{
+	struct inode *inode = page->mapping->host;
+	int err;
+
+        kmap(page);
+	err = hostfs_do_writepage(inode, page, from, to);
+	kunmap(page);
+
+	if (err < 0)
+		return err;
+
+	{
+		loff_t s = ((page->index) << PAGE_CACHE_SHIFT) + to;
+		if (s > inode->i_size)
+			inode->i_size = s;
+	}
+	return 0;
+}
+#endif
+
+static int
+hostfs_inode_readpage(struct file *file, struct page *page)
+{
+        char *address;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+        struct inode *inode = file->f_path.dentry->d_inode;
+#else
+        struct inode *inode = file->f_dentry->d_inode;
+#endif
+        uint count = PAGE_CACHE_SIZE;
+        int err;
+        struct hf_read_data *data;
+
+	if (page->index > (0xffffffff/PAGE_CACHE_SIZE)-1)
+		return -EFBIG;
+
+        data = kmalloc(sizeof *data, GFP_KERNEL);
+        if (!data)
+                return -ENOMEM;
+
+	ClearPageError(page);
+        count = PAGE_SIZE;
+
+/*          DPRINT1("readpage seek %ld\n", (long)page->offset); */
+
+	address = kmap(page);
+
+        spin_lock(&hostfs_position_lock);
+
+        if ((err = hf_do_seek(inode->i_ino,
+                              page->index << PAGE_CACHE_SHIFT))) {
+                err = -err;
+                goto out_error;
+        }
+
+        while (count > 0) {
+                uint to_read = MIN(count, XFER_DATA_WORDS * 4);
+
+                get_host_data(hf_Read, inode->i_ino, &to_read, data);
+                if (data->sys_error) {
+                        err = -data->sys_error;
+                        goto out_error;
+                }
+
+/*              DPRINT1("readpage count %d out of %d\n", data.size, count); */
+
+		if (!data->size) {
+			memset(address,0,count);
+			break;
+		}
+
+                NTOHSWAP(data->data);
+
+                memcpy(address, data->data, data->size);
+
+
+                address += data->size;
+                count -= data->size;
+        }
+
+        err = 0;
+        spin_unlock(&hostfs_position_lock);
+
+	SetPageUptodate(page);
+out_error:
+        kfree(data);
+
+        if (err)
+                SetPageError(page);
+#ifndef KERNEL_2_6
+        UnlockPage(page);
+#else /* KERNEL_2_6 */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+        unlock_page(page);
+ #else
+	ClearPageLocked(page);
+ #endif
+#endif /* KERNEL_2_6 */
+        kunmap(page);
+
+/*          DPRINT1("postuse %ld\n", (long)atomic_read(&page->count)); */
+
+        return err;
+}
+
+static int
+hostfs_inode_readlink(struct dentry *dentry, char *buf, int size)
+{
+	struct hf_readlink_data data;
+
+	get_host_data(hf_Readlink, dentry->d_inode->i_ino, NULL, &data);
+	if (data.sys_error)
+		return -data.sys_error;
+	NTOHSWAP(data.filename);
+	return vfs_readlink(dentry, buf, size, data.filename);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,13)
+static void *
+#else
+static int
+#endif
+hostfs_inode_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+/*       DPRINT1("hostfs_inode_follow_link ino %ld %ld %d\n",
+                 base->d_inode->i_ino, dentry->d_inode->i_ino, follow); */
+	struct hf_readlink_data data;
+	char *name;
+        int ret_val;
+
+	get_host_data(hf_Readlink, dentry->d_inode->i_ino, NULL, &data);
+	if (data.sys_error)
+		name = ERR_PTR(-data.sys_error);
+	else {
+		name = data.filename;
+		NTOHSWAP(data.filename);
+	}
+
+        ret_val = vfs_follow_link(nd, data.filename);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,13)
+        return ERR_PTR(ret_val);
+#else
+        return ret_val;
+#endif
+}
+
+static struct dentry *
+#ifndef KERNEL_2_6
+hostfs_inode_lookup(struct inode *dir, struct dentry *dentry)
+#else /* KERNEL_2_6 */
+hostfs_inode_lookup(struct inode *dir, struct dentry *dentry,
+                    struct nameidata *name_data)
+#endif /* KERNEL_2_6 */
+{
+        struct hf_lookup_data odata;
+        struct hf_hnode_data idata;
+        struct inode *inode;
+
+/*          DPRINT1("hostfs_inode_lookup(%ld, dent %p = %s)\n", dir->i_ino, dentry, dentry->d_name.name); */
+
+	/* protect lots of stupid strcpy()s */
+	if (dentry->d_name.len > HOSTFS_FILENAME_LEN-1)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	memcpy(odata.filename, dentry->d_name.name, dentry->d_name.len);
+	odata.filename[dentry->d_name.len] = 0;
+	HTONSWAP(odata.filename);
+	get_host_data(hf_Lookup, dir->i_ino, &odata, &idata);
+ 
+        if (idata.sys_error) {
+                if (idata.sys_error != ENOENT)
+                        return ERR_PTR(-idata.sys_error);
+                inode = NULL;
+        } else {
+                #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+                        inode = hostfs_iget(dir->i_sb, idata.hnode);
+                #else
+                        inode = iget(dir->i_sb, idata.hnode);
+                #endif
+        }
+
+        d_add(dentry, inode);
+
+        return ERR_PTR(0);
+}
+
+static int
+hostfs_inode_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+        struct hf_mkdir_data odata;
+        struct hf_hnode_data idata;
+        struct inode *inode;
+
+        DPRINT1("hostfs_inode_mkdir()\n");
+
+        odata.mode = mode;
+        strcpy(odata.dirname, dentry->d_name.name);
+        HTONSWAP(odata.dirname);
+
+        get_host_data(hf_MkDir, dir->i_ino, &odata, &idata);
+        if (idata.sys_error)
+                return -idata.sys_error;;
+
+        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+                inode = hostfs_iget(dir->i_sb, idata.hnode);
+        #else
+                inode = iget(dir->i_sb, idata.hnode);
+                hostfs_read_inode(inode);
+        #endif
+        mark_inode_dirty(inode);
+        d_instantiate(dentry, inode);
+
+        return 0;
+}
+
+static int
+hostfs_inode_rmdir(struct inode *dir, struct dentry *dentry)
+{
+        struct hf_remove_data odata;
+        struct hf_common_data idata;
+
+        DPRINT1("hostfs_inode_rmdir()\n");
+
+        strcpy(odata.filename, dentry->d_name.name);
+        HTONSWAP(odata.filename);
+        get_host_data(hf_Remove, dir->i_ino, &odata, &idata);
+        mark_inode_dirty(dir);
+
+        return -idata.sys_error;
+}
+
+static int
+#ifndef KERNEL_2_6
+hostfs_inode_create(struct inode *dir, struct dentry *dentry, int mode)
+#else /* KERNEL_2_6 */
+hostfs_inode_create(struct inode *dir, struct dentry *dentry, int mode,
+                    struct nameidata *name_data)
+#endif /* KERNEL_2_6 */
+{
+        struct hf_create_data odata;
+        struct hf_hnode_data idata;
+        struct inode *inode;
+
+        DPRINT1("hostfs_inode_create(%ld, mode = %d)\n", dir->i_ino, mode);
+
+        odata.mode = mode & S_IALLUGO;
+        odata.excl = 0;
+        odata.trunc = 0;
+        strncpy(odata.filename, dentry->d_name.name, sizeof(odata.filename));
+        HTONSWAP(odata.filename);
+
+        get_host_data(hf_Create, dir->i_ino, &odata, &idata);
+
+        if (idata.sys_error) {
+                return -idata.sys_error;
+        }
+
+        #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+                inode = hostfs_iget(dir->i_sb, idata.hnode);
+        #else
+                inode = iget(dir->i_sb, idata.hnode);
+                hostfs_read_inode(inode);
+        #endif
+        DPRINT1("    read inode mode 0%o  uid %d\n", inode->i_mode,
+                inode->i_uid);
+        mark_inode_dirty(inode);
+        d_instantiate(dentry, inode);
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+static void
+hostfs_inode_truncate(struct inode *inode)
+{
+        struct hf_setattr_data odata;
+        struct hf_common_data idata;
+
+        DPRINT1("hostfs_inode_truncate(inode = %ld)\n", inode->i_ino);
+
+        memset(&odata, 0, sizeof odata);
+        odata.set_size = 1;
+        SET_HI_LO(odata.size, inode->i_size);
+        get_host_data(hf_SetAttr, inode->i_ino, &odata, &idata);
+
+        if (idata.sys_error) {
+                printk("[hostfs] call to truncate() failed with error %d!\n",
+                       idata.sys_error);
+        }
+}
+#endif
+
+static int
+hostfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+        struct hf_remove_data odata;
+        struct hf_common_data idata;
+
+        DPRINT1("hostfs_unlink(dir = %ld, dentry = %s)\n", dir->i_ino,
+                dentry->d_name.name);
+
+        strcpy(odata.filename, dentry->d_name.name);
+        HTONSWAP(odata.filename);
+        get_host_data(hf_Remove, dir->i_ino, &odata, &idata);
+
+        return -idata.sys_error;
+}
+
+static struct inode_operations hostfs_dir_iops = {
+        create: hostfs_inode_create,
+        lookup: hostfs_inode_lookup,
+        unlink: hostfs_unlink,
+        mkdir: hostfs_inode_mkdir,
+        rmdir: hostfs_inode_rmdir,
+};
+
+static struct inode_operations hostfs_symlink_iops = {
+        readlink: hostfs_inode_readlink,
+        follow_link: hostfs_inode_follow_link,
+};
+
+static struct inode_operations hostfs_file_iops = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+        truncate: hostfs_inode_truncate,
+#endif
+	setattr: hostfs_setattr,
+#ifdef KERNEL_2_6
+        getattr: hostfs_getattr,
+#endif
+};
+
+static struct address_space_operations hostfs_file_aops = {
+	readpage: hostfs_inode_readpage,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+        write_begin: hostfs_write_begin,
+        write_end: hostfs_write_end,
+#else
+	prepare_write: hostfs_prepare_write,
+	commit_write: hostfs_commit_write,
+#endif
+	writepage: hostfs_writepage,
+};
+
+MODULE_LICENSE("GPL");
diff --git a/fs/simicsfs/hostfs_linux.h b/fs/simicsfs/hostfs_linux.h
new file mode 100644
index 0000000..951cb34
--- /dev/null
+++ b/fs/simicsfs/hostfs_linux.h
@@ -0,0 +1,143 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   $Id: hostfs_linux.h,v 1.4 2006/03/31 10:25:53 am Exp $
+*/
+
+#ifndef HOSTFS_H
+#define HOSTFS_H 1
+
+#include <linux/version.h>
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+  /* linux/config.h has been deprecated way before 2.6.19, but has at least
+     worked. Starting with 2.6.19 it does not */
+ #include <linux/config.h>
+#endif
+
+#define DEVICE_NAME "[simicsfs]"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,0,0)
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+   #define KERNEL_2_6
+ #endif
+#else
+ #error "Unsupported kernel version"
+#endif
+
+#include <linux/sched.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/unistd.h>
+#include <linux/errno.h>
+#include <asm/io.h>
+#include <linux/init.h>
+
+#ifdef KERNEL_2_6
+ #include <linux/statfs.h>
+#endif /* KERNEL_2_6 */
+
+#define TARGETOS_LINUX
+#include "hostfs.h"
+#include "hostfs_data.h"
+
+#define GET_HI_LO(tgt, src) do {                                          \
+        typedef int check_tgt_size[sizeof (tgt) == 8 || sizeof (tgt) == 4 \
+                                   ? 1 : -1];                             \
+        if (sizeof (tgt) == 4)                                            \
+                tgt = src ## _lo;                                         \
+        else if (sizeof (tgt) == 8) {                                     \
+                tgt = src ## _hi;                                         \
+                tgt <<= 16;                                               \
+                tgt <<= 16;                                               \
+                tgt |= src ## _lo;                                        \
+        } else                                                            \
+                printk("hostfs GET_HI_LO panic, sizeof (" #tgt ") "       \
+                       "in %s:%d == %dn",                                 \
+                       __FILE__, __LINE__, (int)sizeof (tgt));            \
+} while (0)
+
+#define SET_HI_LO(tgt, src) do {                                          \
+        typedef int check_src_size[sizeof (src) == 8 || sizeof (src) == 4 \
+                                   ? 1 : -1];                             \
+        if (sizeof (src) == 4) {                                          \
+                tgt ## _lo = src;                                         \
+                tgt ## _hi = 0;                                           \
+        } else if (sizeof (src) == 8) {                                   \
+                unsigned long long tmp = src;                             \
+                tgt ## _lo = (uint)src;                                   \
+                tgt ## _hi = tmp >> 32;                                   \
+        }                                                                 \
+} while (0)
+
+#define DEBUG_LEVEL 0
+#define HOSTFS_BLOCK_BITS 10
+#define HOSTFS_BLOCK_SIZE (1 << HOSTFS_BLOCK_BITS)
+
+#define HOSTFS_ROOT_INO 1
+
+#define DPRINT1 if (DEBUG_LEVEL >= 1) printk
+#define DPRINTINODE1(inode) do {                        \
+        if (DEBUG_LEVEL >= 1) print_inode(inode);       \
+} while (0)
+
+#define DPRINTFILE1(file) do { } while (0)
+
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+#define NTOHSWAP(field) do {                                            \
+        int __i;                                                        \
+        for (__i = 0; __i < (sizeof (field) + 3) / 4; ++__i) {          \
+                ((uint *)&field)[__i] = ntohl(((uint *)&field)[__i]);   \
+        }                                                               \
+} while(0)
+
+#define HTONSWAP(field) NTOHSWAP(field)
+
+extern struct file_operations hostfs_file_fops;
+extern struct file_operations hostfs_file_dirops;
+
+int hostfs_revalidate_inode(struct inode *inode);
+void hostfs_read_inode(struct inode *inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)
+int hostfs_write_inode(struct inode *inode, struct writeback_control *wbc);
+#else
+#  ifdef KERNEL_2_6
+int hostfs_write_inode(struct inode *inode, int sync);
+#  else
+void hostfs_write_inode(struct inode *inode, int sync);
+#  endif
+#endif
+
+extern spinlock_t get_host_data_lock;
+extern spinlock_t hostfs_position_lock;
+
+
+/* host interface */
+int get_host_data(host_func_t func, host_node_t hnode, void *in_buf,
+		  void *out_buf);
+int hf_do_seek(ino_t inode, loff_t off);
+int init_host_fs(void);
+
+#endif
diff --git a/fs/simicsfs/hostfs_super.c b/fs/simicsfs/hostfs_super.c
new file mode 100644
index 0000000..ec62795
--- /dev/null
+++ b/fs/simicsfs/hostfs_super.c
@@ -0,0 +1,191 @@
+/*
+   hostfs for Linux
+   Copyright 2001 - 2006 Virtutech AB
+   Copyright 2001 SuSE
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+   NON INFRINGEMENT.  See the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   $Id: hostfs_super.c,v 1.6 2006/03/31 10:25:53 am Exp $
+*/
+
+
+#include "hostfs_linux.h"
+
+static struct super_operations hostfs_super_ops;
+
+
+static int
+#ifndef KERNEL_2_6
+hostfs_statfs(struct super_block *sb, struct statfs *buf)
+#else /* KERNEL_2_6 */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+hostfs_statfs(struct dentry *de, struct kstatfs *buf)
+ #else
+hostfs_statfs(struct super_block *sb, struct kstatfs *buf)
+ #endif
+#endif /* KERNEL_2_6 */
+{
+        struct hf_vfsstat_data data;
+
+        get_host_data(hf_VfsStat, 0, NULL, &data);
+
+        memset(buf, 0, sizeof *buf);
+        buf->f_type = HOSTFS_MAGIC;
+        buf->f_bsize = data.bsize;
+        buf->f_blocks = data.blocks;
+        buf->f_bfree = data.bfree;
+        buf->f_bavail = data.bavail;
+        buf->f_files = data.files;
+        buf->f_ffree = data.ffree;
+        buf->f_namelen = HOSTFS_FILENAME_LEN;
+
+	return 0;
+}
+
+
+#ifndef KERNEL_2_6
+static struct super_block *
+#else /* KERNEL_2_6 */
+static int
+#endif /* KERNEL_2_6 */
+hostfs_read_super(struct super_block *sb, void *data, int silent)
+{
+        struct inode *root_inode;
+        struct hf_handshake_data odata;
+        struct hf_handshake_reply_data idata;
+
+        odata.version = HOSTFS_VERSION;
+        get_host_data(hf_Handshake, 0, &odata, &idata);
+
+        if (idata.sys_error || idata.magic != HOSTFS_MAGIC) {
+                printk(DEVICE_NAME " Handshake with Simics module failed "
+                       "(err=%d, magic=%x/expected %x!\n", idata.sys_error,
+                       idata.magic, HOSTFS_MAGIC);
+                goto out_fail;
+        }
+
+        printk(DEVICE_NAME " mounted\n");
+
+        sb->s_op = &hostfs_super_ops;
+        sb->s_magic = HOSTFS_MAGIC;
+        sb->s_blocksize = HOSTFS_BLOCK_SIZE;
+        sb->s_blocksize_bits = HOSTFS_BLOCK_BITS;
+        root_inode = new_inode(sb);
+        if (!root_inode)
+                goto out_fail;
+        root_inode->i_ino = HOSTFS_ROOT_INO;
+        hostfs_read_inode(root_inode);
+        sb->s_root = d_alloc_root(root_inode);
+        if (!sb->s_root)
+                goto out_no_root;
+
+#ifndef KERNEL_2_6
+        return sb;
+#else /* KERNEL_2_6 */
+        return 0;
+#endif /* KERNEL_2_6 */
+
+ out_no_root:
+        printk(DEVICE_NAME " get root inode failed\n");
+        iput(root_inode);
+
+ out_fail:
+#ifndef KERNEL_2_6
+        return NULL;
+#else /* KERNEL_2_6 */
+        return -EINVAL;
+#endif /* KERNEL_2_6 */
+}
+
+
+static void
+hostfs_put_super(struct super_block *sb)
+{
+        struct hf_common_data idata;
+        get_host_data(hf_Unmount, 0, NULL, &idata);
+}
+
+
+static struct super_operations hostfs_super_ops = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+        read_inode: hostfs_read_inode,
+#endif
+        write_inode: hostfs_write_inode,
+        put_super: hostfs_put_super,
+        statfs:   hostfs_statfs,
+};
+
+#ifndef KERNEL_2_6
+static DECLARE_FSTYPE(host_fs_type, "simicsfs", hostfs_read_super, 0);
+#else /* KERNEL_2_6 */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
+static struct dentry *
+hostfs_mount(struct file_system_type *fs_type,
+             int flags, const char *dev_name, void *data)
+{
+        return mount_nodev(fs_type, flags, data, hostfs_read_super);
+}
+ #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+static int
+hostfs_get_sb(struct file_system_type *fs_type,
+              int flags, const char *dev_name, void *data,
+              struct vfsmount *mnt)
+{
+        return get_sb_nodev(fs_type, flags, data, hostfs_read_super, mnt);
+}
+ #else
+static struct super_block *
+hostfs_get_sb(struct file_system_type *fs_type,
+              int flags, const char *dev_name, void *data)
+{
+	return get_sb_nodev(fs_type, flags, data, hostfs_read_super);
+}
+ #endif
+
+static struct file_system_type host_fs_type = {
+	.owner =	THIS_MODULE,
+	.name =		"simicsfs",
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
+	.mount =	hostfs_mount,
+ #else
+	.get_sb =	hostfs_get_sb,
+ #endif
+	.kill_sb =	kill_anon_super,
+};
+
+#endif /* KERNEL_2_6 */
+
+static int
+__init init_hostfs(void)
+{
+        printk(DEVICE_NAME " " SYMBOL_TO_STRING(HOSTFS_VERSION) "."     \
+               SYMBOL_TO_STRING(HOSTFS_SUBVERSION) " loaded\n");
+        init_host_fs();
+        return register_filesystem(&host_fs_type);
+}
+
+static void
+__exit cleanup_hostfs(void)
+{
+        unregister_filesystem(&host_fs_type);
+        printk(DEVICE_NAME " unloaded\n");
+}
+
+#ifndef KERNEL_2_6
+EXPORT_NO_SYMBOLS;
+#endif /* KERNEL_2_6 */
+
+module_init(init_hostfs)
+module_exit(cleanup_hostfs)
-- 
1.7.1

