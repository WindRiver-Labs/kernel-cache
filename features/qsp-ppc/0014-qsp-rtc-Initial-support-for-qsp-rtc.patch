From 5e6c79e71e8c0d68f22d131bab0db65472dbd200 Mon Sep 17 00:00:00 2001
From: Ivar Holmqvist <ivarholmqvist@gmail.com>
Date: Mon, 16 Jul 2012 17:54:50 +0200
Subject: [PATCH 14/22] qsp-rtc: Initial support for qsp rtc.

[Original patch is from simics-pkg-12514-4.8.1-linux64.tar]

Signed-off-by: Ruan Zhengwang <zhengwang.ruan@windriver.com>
---
 drivers/rtc/Kconfig   |    7 +++
 drivers/rtc/Makefile  |    1 +
 drivers/rtc/rtc-qsp.c |  145 +++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 153 insertions(+), 0 deletions(-)
 create mode 100644 drivers/rtc/rtc-qsp.c

diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index fe282fb..b1988db 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1109,4 +1109,11 @@ config RTC_DRV_LOONGSON1
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ls1x.
 
+config RTC_DRV_QSP
+	tristate "RTC support for QSP"
+	depends on RTC_CLASS || QSP
+	default y
+	help
+	  This option enables build of the RTC QSP platform driver.
+
 endif # RTC_CLASS
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index ca197ce..c29f6e4 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -114,3 +114,4 @@ obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
 obj-$(CONFIG_RTC_MC34708)	+= rtc-mc34708.o
 obj-$(CONFIG_RTC_DRV_MXC_V2)	+= rtc-mxc_v2.o
+obj-$(CONFIG_RTC_DRV_QSP)	+= rtc-qsp.o
diff --git a/drivers/rtc/rtc-qsp.c b/drivers/rtc/rtc-qsp.c
new file mode 100644
index 0000000..ac7df87
--- /dev/null
+++ b/drivers/rtc/rtc-qsp.c
@@ -0,0 +1,145 @@
+/*
+ * .../drivers/rtc/rtc-qsp.c
+ *
+ * Real-time clock driver for the QSP platform
+ *
+ * Copyright (c) 2012 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/rtc.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/qsp/qsp.h>
+
+/* Register offsets */
+#define ID_REG           0x00
+#define TIME_REG         0x04
+#define OFFSET_REG       0x08
+
+struct qsp_rtc_priv {
+	unsigned char __iomem *membase;
+	struct rtc_device *rtc;
+};
+
+static int qsp_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct qsp_rtc_priv *priv = dev_get_drvdata(dev);
+	unsigned long now;
+
+	now = readl(priv->membase + TIME_REG) +
+		readl(priv->membase + OFFSET_REG);
+	pr_debug("%s: %li\n", __func__, now);
+	rtc_time_to_tm(now, tm);
+
+	return 0;
+}
+
+
+static int qsp_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct qsp_rtc_priv *priv = dev_get_drvdata(dev);
+	unsigned long now;
+
+	rtc_tm_to_time(tm, &now);
+	now = now - readl(priv->membase + TIME_REG);
+
+	pr_debug("%s: %li\n", __func__, now);
+	writel(now, priv->membase + OFFSET_REG);
+
+	return 0;
+}
+
+static const struct rtc_class_ops qsp_rtc_ops = {
+	.read_time = qsp_rtc_read_time,
+	.set_time = qsp_rtc_set_time,
+};
+
+static int __devinit qsp_rtc_probe(struct platform_device *pdev)
+{
+	struct qsp_rtc_priv *priv;
+
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+
+	priv = kzalloc(sizeof(struct qsp_rtc_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENODEV;
+
+	priv->membase = of_iomap(pdev->dev.of_node, 0);
+	if (priv->membase == NULL)
+		goto err1;
+
+	if (qsp_device_valid(priv->membase, QSP_RTC_ID_VAL) != 0)
+		goto err2;
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->rtc = rtc_device_register("qsp-rtc", &pdev->dev,
+					&qsp_rtc_ops, THIS_MODULE);
+	if (IS_ERR_OR_NULL(priv->rtc)) {
+		dev_err(&pdev->dev, "Can't register RTC device (%p)\n",
+			priv->rtc);
+		goto err2;
+	}
+
+	return 0;
+
+err2:
+	iounmap(priv->membase);
+err1:
+	kfree(priv);
+	return -ENODEV;
+}
+
+static int __devexit qsp_rtc_remove(struct platform_device *pdev)
+{
+	struct qsp_rtc_priv *priv = platform_get_drvdata(pdev);
+
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+
+	rtc_device_unregister(priv->rtc);
+	platform_set_drvdata(pdev, NULL);
+	iounmap(priv->membase);
+	kfree(priv);
+
+	return 0;
+}
+
+static struct of_device_id of_qsp_rtc_match[] __devinitdata = {
+	{ .compatible = "qsp-rtc", },
+	{},
+};
+
+static struct platform_driver qsp_rtc_driver = {
+	.probe = qsp_rtc_probe,
+	.remove = __devexit_p(qsp_rtc_remove),
+	.driver = {
+		.name = "qsp-rtc",
+		.owner = THIS_MODULE,
+		.of_match_table = of_qsp_rtc_match,
+	},
+};
+
+module_platform_driver(qsp_rtc_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("LED support for QSP");
+MODULE_AUTHOR("Anders Wallin <anders.wallin@windriver.com>");
-- 
1.7.1

